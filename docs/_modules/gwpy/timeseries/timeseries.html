

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>gwpy.timeseries.timeseries &mdash; GWexpy Documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=9edc463e" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=5929fcd5"></script>
      <script src="../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            GWexpy
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../web/en/index.html">GWexpy Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../web/ja/index.html">GWexpy ドキュメントへようこそ</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">GWexpy</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">gwpy.timeseries.timeseries</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for gwpy.timeseries.timeseries</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="c1"># Copyright (C) Duncan Macleod (2014-2020)</span>
<span class="c1">#</span>
<span class="c1"># This file is part of GWpy.</span>
<span class="c1">#</span>
<span class="c1"># GWpy is free software: you can redistribute it and/or modify</span>
<span class="c1"># it under the terms of the GNU General Public License as published by</span>
<span class="c1"># the Free Software Foundation, either version 3 of the License, or</span>
<span class="c1"># (at your option) any later version.</span>
<span class="c1">#</span>
<span class="c1"># GWpy is distributed in the hope that it will be useful,</span>
<span class="c1"># but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c1"># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="c1"># GNU General Public License for more details.</span>
<span class="c1">#</span>
<span class="c1"># You should have received a copy of the GNU General Public License</span>
<span class="c1"># along with GWpy.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>

<span class="sd">&quot;&quot;&quot;Array with metadata</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">math</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="kn">import</span> <span class="n">fft</span> <span class="k">as</span> <span class="n">npfft</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy</span><span class="w"> </span><span class="kn">import</span> <span class="n">signal</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">astropy</span><span class="w"> </span><span class="kn">import</span> <span class="n">units</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">..segments</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span><span class="n">Segment</span><span class="p">,</span> <span class="n">SegmentList</span><span class="p">,</span> <span class="n">DataQualityFlag</span><span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">..signal</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span><span class="n">filter_design</span><span class="p">,</span> <span class="n">qtransform</span><span class="p">,</span> <span class="n">spectral</span><span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">..signal.window</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span><span class="n">get_window</span><span class="p">,</span> <span class="n">recommended_overlap</span><span class="p">,</span> <span class="n">planck</span><span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.core</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span><span class="n">TimeSeriesBase</span><span class="p">,</span> <span class="n">TimeSeriesBaseDict</span><span class="p">,</span> <span class="n">TimeSeriesBaseList</span><span class="p">,</span>
                   <span class="n">as_series_dict_class</span><span class="p">)</span>

<span class="n">__author__</span> <span class="o">=</span> <span class="s1">&#39;Duncan Macleod &lt;duncan.macleod@ligo.org&gt;&#39;</span>

<span class="n">DEFAULT_FFT_METHOD</span> <span class="o">=</span> <span class="s2">&quot;median&quot;</span>


<span class="c1"># -- utilities ----------------------------------------------------------------</span>

<span class="k">def</span><span class="w"> </span><span class="nf">_fft_length_default</span><span class="p">(</span><span class="n">dt</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Choose an appropriate FFT length (in seconds) based on a sample rate</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dt : `~astropy.units.Quantity`</span>
<span class="sd">        the sampling time interval, in seconds</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    fftlength : `int`</span>
<span class="sd">        a choice of FFT length, in seconds</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="mi">2048</span> <span class="o">*</span> <span class="n">dt</span><span class="o">.</span><span class="n">decompose</span><span class="p">()</span><span class="o">.</span><span class="n">value</span><span class="p">)))</span>


<span class="c1"># -- TimeSeries ---------------------------------------------------------------</span>

<span class="k">class</span><span class="w"> </span><span class="nc">TimeSeries</span><span class="p">(</span><span class="n">TimeSeriesBase</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A time-domain data array.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    value : array-like</span>
<span class="sd">        input data array</span>

<span class="sd">    unit : `~astropy.units.Unit`, optional</span>
<span class="sd">        physical unit of these data</span>

<span class="sd">    t0 : `~gwpy.time.LIGOTimeGPS`, `float`, `str`, optional</span>
<span class="sd">        GPS epoch associated with these data,</span>
<span class="sd">        any input parsable by `~gwpy.time.to_gps` is fine</span>

<span class="sd">    dt : `float`, `~astropy.units.Quantity`, optional</span>
<span class="sd">        time between successive samples (seconds), can also be given inversely</span>
<span class="sd">        via `sample_rate`</span>

<span class="sd">    sample_rate : `float`, `~astropy.units.Quantity`, optional</span>
<span class="sd">        the rate of samples per second (Hertz), can also be given inversely</span>
<span class="sd">        via `dt`</span>

<span class="sd">    times : `array-like`</span>
<span class="sd">        the complete array of GPS times accompanying the data for this series.</span>
<span class="sd">        This argument takes precedence over `t0` and `dt` so should be given</span>
<span class="sd">        in place of these if relevant, not alongside</span>

<span class="sd">    name : `str`, optional</span>
<span class="sd">        descriptive title for this array</span>

<span class="sd">    channel : `~gwpy.detector.Channel`, `str`, optional</span>
<span class="sd">        source data stream for these data</span>

<span class="sd">    dtype : `~numpy.dtype`, optional</span>
<span class="sd">        input data type</span>

<span class="sd">    copy : `bool`, optional</span>
<span class="sd">        choose to copy the input data to new memory</span>

<span class="sd">    subok : `bool`, optional</span>
<span class="sd">        allow passing of sub-classes by the array generator</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The necessary metadata to reconstruct timing information are recorded</span>
<span class="sd">    in the `epoch` and `sample_rate` attributes. This time-stamps can be</span>
<span class="sd">    returned via the :attr:`~TimeSeries.times` property.</span>

<span class="sd">    All comparison operations performed on a `TimeSeries` will return a</span>
<span class="sd">    `~gwpy.timeseries.StateTimeSeries` - a boolean array</span>
<span class="sd">    with metadata copied from the starting `TimeSeries`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from gwpy.timeseries import TimeSeries</span>

<span class="sd">    To create an array of random numbers, sampled at 100 Hz, in units of</span>
<span class="sd">    &#39;metres&#39;:</span>

<span class="sd">    &gt;&gt;&gt; from numpy import random</span>
<span class="sd">    &gt;&gt;&gt; series = TimeSeries(random.random(1000), sample_rate=100, unit=&#39;m&#39;)</span>

<span class="sd">    which can then be simply visualised via</span>

<span class="sd">    &gt;&gt;&gt; plot = series.plot()</span>
<span class="sd">    &gt;&gt;&gt; plot.show()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">fft</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nfft</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the one-dimensional discrete Fourier transform of</span>
<span class="sd">        this `TimeSeries`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nfft : `int`, optional</span>
<span class="sd">            length of the desired Fourier transform, input will be</span>
<span class="sd">            cropped or padded to match the desired length.</span>
<span class="sd">            If nfft is not given, the length of the `TimeSeries`</span>
<span class="sd">            will be used</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : `~gwpy.frequencyseries.FrequencySeries`</span>
<span class="sd">            the normalised, complex-valued FFT `FrequencySeries`.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        numpy.fft.rfft : The FFT implementation used in this method.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method, in constrast to the :func:`numpy.fft.rfft` method</span>
<span class="sd">        it calls, applies the necessary normalisation such that the</span>
<span class="sd">        amplitude of the output `~gwpy.frequencyseries.FrequencySeries` is</span>
<span class="sd">        correct.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">..frequencyseries</span><span class="w"> </span><span class="kn">import</span> <span class="n">FrequencySeries</span>
        <span class="k">if</span> <span class="n">nfft</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">nfft</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span>
        <span class="n">dft</span> <span class="o">=</span> <span class="n">npfft</span><span class="o">.</span><span class="n">rfft</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">nfft</span><span class="p">)</span> <span class="o">/</span> <span class="n">nfft</span>
        <span class="n">dft</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">*=</span> <span class="mf">2.0</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">FrequencySeries</span><span class="p">(</span><span class="n">dft</span><span class="p">,</span> <span class="n">epoch</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">epoch</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">,</span>
                              <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">channel</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">channel</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">new</span><span class="o">.</span><span class="n">frequencies</span> <span class="o">=</span> <span class="n">npfft</span><span class="o">.</span><span class="n">rfftfreq</span><span class="p">(</span><span class="n">nfft</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">new</span><span class="o">.</span><span class="n">frequencies</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">new</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">nfft</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new</span>

<div class="viewcode-block" id="TimeSeries.average_fft">
<a class="viewcode-back" href="../../../web/ja/reference/api/timeseries.html#gwexpy.timeseries.TimeSeries.average_fft">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">average_fft</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fftlength</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">overlap</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the averaged one-dimensional DFT of this `TimeSeries`.</span>

<span class="sd">        This method computes a number of FFTs of duration ``fftlength``</span>
<span class="sd">        and ``overlap`` (both given in seconds), and returns the mean</span>
<span class="sd">        average. This method is analogous to the Welch average method</span>
<span class="sd">        for power spectra.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fftlength : `float`</span>
<span class="sd">            number of seconds in single FFT, default, use</span>
<span class="sd">            whole `TimeSeries`</span>

<span class="sd">        overlap : `float`, optional</span>
<span class="sd">            number of seconds of overlap between FFTs, defaults to the</span>
<span class="sd">            recommended overlap for the given window (if given), or 0</span>

<span class="sd">        window : `str`, `numpy.ndarray`, optional</span>
<span class="sd">            window function to apply to timeseries prior to FFT,</span>
<span class="sd">            see :func:`scipy.signal.get_window` for details on acceptable</span>
<span class="sd">            formats</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : complex-valued `~gwpy.frequencyseries.FrequencySeries`</span>
<span class="sd">            the transformed output, with populated frequencies array</span>
<span class="sd">            metadata</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        TimeSeries.fft</span>
<span class="sd">           The FFT method used.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">gwpy.spectrogram</span><span class="w"> </span><span class="kn">import</span> <span class="n">Spectrogram</span>
        <span class="c1"># format lengths</span>
        <span class="k">if</span> <span class="n">fftlength</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fftlength</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">duration</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fftlength</span><span class="p">,</span> <span class="n">units</span><span class="o">.</span><span class="n">Quantity</span><span class="p">):</span>
            <span class="n">fftlength</span> <span class="o">=</span> <span class="n">fftlength</span><span class="o">.</span><span class="n">value</span>
        <span class="n">nfft</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">fftlength</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_rate</span><span class="p">)</span><span class="o">.</span><span class="n">decompose</span><span class="p">()</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="n">noverlap</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">overlap</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_rate</span><span class="p">)</span><span class="o">.</span><span class="n">decompose</span><span class="p">()</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

        <span class="n">navg</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="o">-</span><span class="n">noverlap</span><span class="p">,</span> <span class="p">(</span><span class="n">nfft</span><span class="o">-</span><span class="n">noverlap</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># format window</span>
        <span class="k">if</span> <span class="n">window</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">window</span> <span class="o">=</span> <span class="s1">&#39;boxcar&#39;</span>
        <span class="n">win</span> <span class="o">=</span> <span class="n">get_window</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="n">nfft</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">scaling</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">numpy</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">win</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">nfft</span> <span class="o">%</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">nfreqs</span> <span class="o">=</span> <span class="p">(</span><span class="n">nfft</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nfreqs</span> <span class="o">=</span> <span class="n">nfft</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">ffts</span> <span class="o">=</span> <span class="n">Spectrogram</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">navg</span><span class="p">,</span> <span class="n">nfreqs</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">complex128</span><span class="p">),</span>
                           <span class="n">channel</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">channel</span><span class="p">,</span> <span class="n">epoch</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">epoch</span><span class="p">,</span> <span class="n">f0</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                           <span class="n">df</span><span class="o">=</span><span class="mi">1</span> <span class="o">/</span> <span class="n">fftlength</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># stride through TimeSeries, recording FFTs as columns of Spectrogram</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">navg</span><span class="p">):</span>
            <span class="c1"># find step TimeSeries</span>
            <span class="n">idx_end</span> <span class="o">=</span> <span class="n">idx</span> <span class="o">+</span> <span class="n">nfft</span>
            <span class="k">if</span> <span class="n">idx_end</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">stepseries</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">idx</span><span class="p">:</span><span class="n">idx_end</span><span class="p">]</span><span class="o">.</span><span class="n">detrend</span><span class="p">()</span> <span class="o">*</span> <span class="n">win</span>
            <span class="c1"># calculated FFT, weight, and stack</span>
            <span class="n">fft_</span> <span class="o">=</span> <span class="n">stepseries</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">nfft</span><span class="o">=</span><span class="n">nfft</span><span class="p">)</span> <span class="o">*</span> <span class="n">scaling</span>
            <span class="n">ffts</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">fft_</span><span class="o">.</span><span class="n">value</span>
            <span class="n">idx</span> <span class="o">+=</span> <span class="p">(</span><span class="n">nfft</span> <span class="o">-</span> <span class="n">noverlap</span><span class="p">)</span>
        <span class="n">mean</span> <span class="o">=</span> <span class="n">ffts</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">mean</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="n">mean</span><span class="o">.</span><span class="n">epoch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">epoch</span>
        <span class="n">mean</span><span class="o">.</span><span class="n">channel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel</span>
        <span class="k">return</span> <span class="n">mean</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">psd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fftlength</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">overlap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="s1">&#39;hann&#39;</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="n">DEFAULT_FFT_METHOD</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate the PSD `FrequencySeries` for this `TimeSeries`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fftlength : `float`</span>
<span class="sd">            number of seconds in single FFT, defaults to a single FFT</span>
<span class="sd">            covering the full duration</span>

<span class="sd">        overlap : `float`, optional</span>
<span class="sd">            number of seconds of overlap between FFTs, defaults to the</span>
<span class="sd">            recommended overlap for the given window (if given), or 0</span>

<span class="sd">        window : `str`, `numpy.ndarray`, optional</span>
<span class="sd">            window function to apply to timeseries prior to FFT,</span>
<span class="sd">            see :func:`scipy.signal.get_window` for details on acceptable</span>
<span class="sd">            formats</span>

<span class="sd">        method : `str`, optional</span>
<span class="sd">            FFT-averaging method (default: ``&#39;median&#39;``),</span>
<span class="sd">            see *Notes* for more details</span>

<span class="sd">        **kwargs</span>
<span class="sd">            other keyword arguments are passed to the underlying</span>
<span class="sd">            PSD-generation method</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        psd :  `~gwpy.frequencyseries.FrequencySeries`</span>
<span class="sd">            a data series containing the PSD.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The accepted ``method`` arguments are:</span>

<span class="sd">        - ``&#39;bartlett&#39;`` : a mean average of non-overlapping periodograms</span>
<span class="sd">        - ``&#39;median&#39;`` : a median average of overlapping periodograms</span>
<span class="sd">        - ``&#39;welch&#39;`` : a mean average of overlapping periodograms</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># get method</span>
        <span class="n">method_func</span> <span class="o">=</span> <span class="n">spectral</span><span class="o">.</span><span class="n">get_method</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>

        <span class="c1"># calculate PSD using UI method</span>
        <span class="k">return</span> <span class="n">spectral</span><span class="o">.</span><span class="n">psd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method_func</span><span class="p">,</span> <span class="n">fftlength</span><span class="o">=</span><span class="n">fftlength</span><span class="p">,</span>
                            <span class="n">overlap</span><span class="o">=</span><span class="n">overlap</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">asd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fftlength</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">overlap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="s1">&#39;hann&#39;</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="n">DEFAULT_FFT_METHOD</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate the ASD `FrequencySeries` of this `TimeSeries`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fftlength : `float`</span>
<span class="sd">            number of seconds in single FFT, defaults to a single FFT</span>
<span class="sd">            covering the full duration</span>

<span class="sd">        overlap : `float`, optional</span>
<span class="sd">            number of seconds of overlap between FFTs, defaults to the</span>
<span class="sd">            recommended overlap for the given window (if given), or 0</span>

<span class="sd">        window : `str`, `numpy.ndarray`, optional</span>
<span class="sd">            window function to apply to timeseries prior to FFT,</span>
<span class="sd">            see :func:`scipy.signal.get_window` for details on acceptable</span>
<span class="sd">            formats</span>

<span class="sd">        method : `str`, optional</span>
<span class="sd">            FFT-averaging method (default: ``&#39;median&#39;``),</span>
<span class="sd">            see *Notes* for more details</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        asd :  `~gwpy.frequencyseries.FrequencySeries`</span>
<span class="sd">            a data series containing the ASD</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        TimeSeries.psd</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The accepted ``method`` arguments are:</span>

<span class="sd">        - ``&#39;bartlett&#39;`` : a mean average of non-overlapping periodograms</span>
<span class="sd">        - ``&#39;median&#39;`` : a median average of overlapping periodograms</span>
<span class="sd">        - ``&#39;welch&#39;`` : a mean average of overlapping periodograms</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">psd</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">fftlength</span><span class="o">=</span><span class="n">fftlength</span><span class="p">,</span> <span class="n">overlap</span><span class="o">=</span><span class="n">overlap</span><span class="p">,</span>
                        <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mf">2.</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">csd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">fftlength</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">overlap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="s1">&#39;hann&#39;</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate the CSD `FrequencySeries` for two `TimeSeries`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : `TimeSeries`</span>
<span class="sd">            the second `TimeSeries` in this CSD calculation</span>

<span class="sd">        fftlength : `float`</span>
<span class="sd">            number of seconds in single FFT, defaults to a single FFT</span>
<span class="sd">            covering the full duration</span>

<span class="sd">        overlap : `float`, optional</span>
<span class="sd">            number of seconds of overlap between FFTs, defaults to the</span>
<span class="sd">            recommended overlap for the given window (if given), or 0</span>

<span class="sd">        window : `str`, `numpy.ndarray`, optional</span>
<span class="sd">            window function to apply to timeseries prior to FFT,</span>
<span class="sd">            see :func:`scipy.signal.get_window` for details on acceptable</span>
<span class="sd">            formats</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        csd :  `~gwpy.frequencyseries.FrequencySeries`</span>
<span class="sd">            a data series containing the CSD.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">spectral</span><span class="o">.</span><span class="n">psd</span><span class="p">(</span>
            <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">),</span>
            <span class="n">spectral</span><span class="o">.</span><span class="n">csd</span><span class="p">,</span>
            <span class="n">fftlength</span><span class="o">=</span><span class="n">fftlength</span><span class="p">,</span>
            <span class="n">overlap</span><span class="o">=</span><span class="n">overlap</span><span class="p">,</span>
            <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">spectrogram</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">fftlength</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">overlap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="s1">&#39;hann&#39;</span><span class="p">,</span>
                    <span class="n">method</span><span class="o">=</span><span class="n">DEFAULT_FFT_METHOD</span><span class="p">,</span> <span class="n">nproc</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate the average power spectrogram of this `TimeSeries`</span>
<span class="sd">        using the specified average spectrum method.</span>

<span class="sd">        Each time-bin of the output `Spectrogram` is calculated by taking</span>
<span class="sd">        a chunk of the `TimeSeries` in the segment</span>
<span class="sd">        `[t - overlap/2., t + stride + overlap/2.)` and calculating the</span>
<span class="sd">        :meth:`~gwpy.timeseries.TimeSeries.psd` of those data.</span>

<span class="sd">        As a result, each time-bin is calculated using `stride + overlap`</span>
<span class="sd">        seconds of data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        stride : `float`</span>
<span class="sd">            number of seconds in single PSD (column of spectrogram).</span>

<span class="sd">        fftlength : `float`</span>
<span class="sd">            number of seconds in single FFT.</span>

<span class="sd">        overlap : `float`, optional</span>
<span class="sd">            number of seconds of overlap between FFTs, defaults to the</span>
<span class="sd">            recommended overlap for the given window (if given), or 0</span>

<span class="sd">        window : `str`, `numpy.ndarray`, optional</span>
<span class="sd">            window function to apply to timeseries prior to FFT,</span>
<span class="sd">            see :func:`scipy.signal.get_window` for details on acceptable</span>
<span class="sd">            formats</span>

<span class="sd">        method : `str`, optional</span>
<span class="sd">            FFT-averaging method (default: ``&#39;median&#39;``),</span>
<span class="sd">            see *Notes* for more details</span>

<span class="sd">        nproc : `int`</span>
<span class="sd">            number of CPUs to use in parallel processing of FFTs</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        spectrogram : `~gwpy.spectrogram.Spectrogram`</span>
<span class="sd">            time-frequency power spectrogram as generated from the</span>
<span class="sd">            input time-series.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The accepted ``method`` arguments are:</span>

<span class="sd">        - ``&#39;bartlett&#39;`` : a mean average of non-overlapping periodograms</span>
<span class="sd">        - ``&#39;median&#39;`` : a median average of overlapping periodograms</span>
<span class="sd">        - ``&#39;welch&#39;`` : a mean average of overlapping periodograms</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># get method</span>
        <span class="n">method_func</span> <span class="o">=</span> <span class="n">spectral</span><span class="o">.</span><span class="n">get_method</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>

        <span class="c1"># calculate PSD using UI method</span>
        <span class="k">return</span> <span class="n">spectral</span><span class="o">.</span><span class="n">average_spectrogram</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">method_func</span><span class="p">,</span>
            <span class="n">stride</span><span class="p">,</span>
            <span class="n">fftlength</span><span class="o">=</span><span class="n">fftlength</span><span class="p">,</span>
            <span class="n">overlap</span><span class="o">=</span><span class="n">overlap</span><span class="p">,</span>
            <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">spectrogram2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fftlength</span><span class="p">,</span> <span class="n">overlap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="s1">&#39;hann&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate the non-averaged power `Spectrogram` of this `TimeSeries`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fftlength : `float`</span>
<span class="sd">            number of seconds in single FFT.</span>

<span class="sd">        overlap : `float`, optional</span>
<span class="sd">            number of seconds of overlap between FFTs, defaults to the</span>
<span class="sd">            recommended overlap for the given window (if given), or 0</span>

<span class="sd">        window : `str`, `numpy.ndarray`, optional</span>
<span class="sd">            window function to apply to timeseries prior to FFT,</span>
<span class="sd">            see :func:`scipy.signal.get_window` for details on acceptable</span>
<span class="sd">            formats</span>

<span class="sd">        scaling : [ &#39;density&#39; | &#39;spectrum&#39; ], optional</span>
<span class="sd">            selects between computing the power spectral density (&#39;density&#39;)</span>
<span class="sd">            where the `Spectrogram` has units of V**2/Hz if the input is</span>
<span class="sd">            measured in V and computing the power spectrum (&#39;spectrum&#39;)</span>
<span class="sd">            where the `Spectrogram` has units of V**2 if the input is</span>
<span class="sd">            measured in V. Defaults to &#39;density&#39;.</span>

<span class="sd">        **kwargs</span>
<span class="sd">            other parameters to be passed to `scipy.signal.periodogram` for</span>
<span class="sd">            each column of the `Spectrogram`</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        spectrogram: `~gwpy.spectrogram.Spectrogram`</span>
<span class="sd">            a power `Spectrogram` with `1/fftlength` frequency resolution and</span>
<span class="sd">            (fftlength - overlap) time resolution.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        scipy.signal.periodogram</span>
<span class="sd">            for documentation on the Fourier methods used in this calculation</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method calculates overlapping periodograms for all possible</span>
<span class="sd">        chunks of data entirely containing within the span of the input</span>
<span class="sd">        `TimeSeries`, then normalises the power in overlapping chunks using</span>
<span class="sd">        a triangular window centred on that chunk which most overlaps the</span>
<span class="sd">        given `Spectrogram` time sample.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># set kwargs for periodogram()</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;fs&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_rate</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s1">&#39;Hz&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="c1"># run</span>
        <span class="k">return</span> <span class="n">spectral</span><span class="o">.</span><span class="n">spectrogram</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">fftlength</span><span class="o">=</span><span class="n">fftlength</span><span class="p">,</span>
            <span class="n">overlap</span><span class="o">=</span><span class="n">overlap</span><span class="p">,</span>
            <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>

<div class="viewcode-block" id="TimeSeries.fftgram">
<a class="viewcode-back" href="../../../web/ja/reference/api/timeseries.html#gwexpy.timeseries.TimeSeries.fftgram">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">fftgram</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fftlength</span><span class="p">,</span> <span class="n">overlap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="s1">&#39;hann&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate the Fourier-gram of this `TimeSeries`.</span>

<span class="sd">        At every ``stride``, a single, complex FFT is calculated.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fftlength : `float`</span>
<span class="sd">            number of seconds in single FFT.</span>

<span class="sd">        overlap : `float`, optional</span>
<span class="sd">            number of seconds of overlap between FFTs, defaults to the</span>
<span class="sd">            recommended overlap for the given window (if given), or 0</span>

<span class="sd">        window : `str`, `numpy.ndarray`, optional</span>
<span class="sd">            window function to apply to timeseries prior to FFT,</span>
<span class="sd">            see :func:`scipy.signal.get_window` for details on acceptable</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            a Fourier-gram</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">..spectrogram</span><span class="w"> </span><span class="kn">import</span> <span class="n">Spectrogram</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">scipy.signal</span><span class="w"> </span><span class="kn">import</span> <span class="n">spectrogram</span>

        <span class="c1"># format lengths</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fftlength</span><span class="p">,</span> <span class="n">units</span><span class="o">.</span><span class="n">Quantity</span><span class="p">):</span>
            <span class="n">fftlength</span> <span class="o">=</span> <span class="n">fftlength</span><span class="o">.</span><span class="n">value</span>

        <span class="n">nfft</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">fftlength</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_rate</span><span class="p">)</span><span class="o">.</span><span class="n">decompose</span><span class="p">()</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">overlap</span><span class="p">:</span>
            <span class="c1"># use scipy.signal.spectrogram noverlap default</span>
            <span class="n">noverlap</span> <span class="o">=</span> <span class="n">nfft</span> <span class="o">//</span> <span class="mi">8</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">noverlap</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">overlap</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_rate</span><span class="p">)</span><span class="o">.</span><span class="n">decompose</span><span class="p">()</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

        <span class="c1"># generate output spectrogram</span>
        <span class="p">[</span><span class="n">frequencies</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">sxx</span><span class="p">]</span> <span class="o">=</span> <span class="n">spectrogram</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                                <span class="n">fs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_rate</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
                                                <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span>
                                                <span class="n">nperseg</span><span class="o">=</span><span class="n">nfft</span><span class="p">,</span>
                                                <span class="n">noverlap</span><span class="o">=</span><span class="n">noverlap</span><span class="p">,</span>
                                                <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;complex&#39;</span><span class="p">,</span>
                                                <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Spectrogram</span><span class="p">(</span><span class="n">sxx</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                           <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">,</span>
                           <span class="n">xindex</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">t0</span><span class="o">.</span><span class="n">value</span> <span class="o">+</span> <span class="n">times</span><span class="p">,</span>
                           <span class="n">yindex</span><span class="o">=</span><span class="n">frequencies</span><span class="p">)</span></div>


<div class="viewcode-block" id="TimeSeries.spectral_variance">
<a class="viewcode-back" href="../../../web/ja/reference/api/timeseries.html#gwexpy.timeseries.TimeSeries.spectral_variance">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">spectral_variance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">fftlength</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">overlap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                          <span class="n">method</span><span class="o">=</span><span class="n">DEFAULT_FFT_METHOD</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="s1">&#39;hann&#39;</span><span class="p">,</span> <span class="n">nproc</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                          <span class="nb">filter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">low</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                          <span class="n">nbins</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate the `SpectralVariance` of this `TimeSeries`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        stride : `float`</span>
<span class="sd">            number of seconds in single PSD (column of spectrogram)</span>

<span class="sd">        fftlength : `float`</span>
<span class="sd">            number of seconds in single FFT</span>

<span class="sd">        method : `str`, optional</span>
<span class="sd">            FFT-averaging method (default: ``&#39;median&#39;``),</span>
<span class="sd">            see *Notes* for more details</span>

<span class="sd">        overlap : `float`, optional</span>
<span class="sd">            number of seconds of overlap between FFTs, defaults to the</span>
<span class="sd">            recommended overlap for the given window (if given), or 0</span>

<span class="sd">        window : `str`, `numpy.ndarray`, optional</span>
<span class="sd">            window function to apply to timeseries prior to FFT,</span>
<span class="sd">            see :func:`scipy.signal.get_window` for details on acceptable</span>
<span class="sd">            formats</span>

<span class="sd">        nproc : `int`</span>
<span class="sd">            maximum number of independent frame reading processes, default</span>
<span class="sd">            is set to single-process file reading.</span>

<span class="sd">        bins : `numpy.ndarray`, optional, default `None`</span>
<span class="sd">            array of histogram bin edges, including the rightmost edge</span>

<span class="sd">        low : `float`, optional</span>
<span class="sd">            left edge of lowest amplitude bin, only read</span>
<span class="sd">            if ``bins`` is not given</span>

<span class="sd">        high : `float`, optional</span>
<span class="sd">            right edge of highest amplitude bin, only read</span>
<span class="sd">            if ``bins`` is not given</span>

<span class="sd">        nbins : `int`, optional</span>
<span class="sd">            number of bins to generate, only read if ``bins`` is not</span>
<span class="sd">            given</span>

<span class="sd">        log : `bool`, optional</span>
<span class="sd">            calculate amplitude bins over a logarithmic scale, only</span>
<span class="sd">            read if ``bins`` is not given</span>

<span class="sd">        norm : `bool`, optional</span>
<span class="sd">            normalise bin counts to a unit sum</span>

<span class="sd">        density : `bool`, optional</span>
<span class="sd">            normalise bin counts to a unit integral</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        specvar : `SpectralVariance`</span>
<span class="sd">            2D-array of spectral frequency-amplitude counts</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        numpy.histogram</span>
<span class="sd">            for details on specifying bins and weights</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The accepted ``method`` arguments are:</span>

<span class="sd">        - ``&#39;bartlett&#39;`` : a mean average of non-overlapping periodograms</span>
<span class="sd">        - ``&#39;median&#39;`` : a median average of overlapping periodograms</span>
<span class="sd">        - ``&#39;welch&#39;`` : a mean average of overlapping periodograms</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">specgram</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectrogram</span><span class="p">(</span><span class="n">stride</span><span class="p">,</span> <span class="n">fftlength</span><span class="o">=</span><span class="n">fftlength</span><span class="p">,</span>
                                    <span class="n">overlap</span><span class="o">=</span><span class="n">overlap</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
                                    <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span> <span class="n">nproc</span><span class="o">=</span><span class="n">nproc</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mf">2.</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">filter</span><span class="p">:</span>
            <span class="n">specgram</span> <span class="o">=</span> <span class="n">specgram</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="o">*</span><span class="nb">filter</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">specgram</span><span class="o">.</span><span class="n">variance</span><span class="p">(</span><span class="n">bins</span><span class="o">=</span><span class="n">bins</span><span class="p">,</span> <span class="n">low</span><span class="o">=</span><span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="n">high</span><span class="p">,</span> <span class="n">nbins</span><span class="o">=</span><span class="n">nbins</span><span class="p">,</span>
                                 <span class="n">log</span><span class="o">=</span><span class="n">log</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="n">density</span><span class="p">)</span></div>


<div class="viewcode-block" id="TimeSeries.rayleigh_spectrum">
<a class="viewcode-back" href="../../../web/ja/reference/api/timeseries.html#gwexpy.timeseries.TimeSeries.rayleigh_spectrum">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">rayleigh_spectrum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fftlength</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">overlap</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="s1">&#39;hann&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate the Rayleigh `FrequencySeries` for this `TimeSeries`.</span>

<span class="sd">        The Rayleigh statistic is calculated as the ratio of the standard</span>
<span class="sd">        deviation and the mean of a number of periodograms.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fftlength : `float`</span>
<span class="sd">            number of seconds in single FFT, defaults to a single FFT</span>
<span class="sd">            covering the full duration</span>

<span class="sd">        overlap : `float`, optional</span>
<span class="sd">            number of seconds of overlap between FFTs, passing `None` will</span>
<span class="sd">            choose based on the window method, default: ``0``</span>

<span class="sd">        window : `str`, `numpy.ndarray`, optional</span>
<span class="sd">            window function to apply to timeseries prior to FFT,</span>
<span class="sd">            see :func:`scipy.signal.get_window` for details on acceptable</span>
<span class="sd">            formats</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        psd :  `~gwpy.frequencyseries.FrequencySeries`</span>
<span class="sd">            a data series containing the PSD.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">spectral</span><span class="o">.</span><span class="n">psd</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">spectral</span><span class="o">.</span><span class="n">rayleigh</span><span class="p">,</span>
            <span class="n">fftlength</span><span class="o">=</span><span class="n">fftlength</span><span class="p">,</span>
            <span class="n">overlap</span><span class="o">=</span><span class="n">overlap</span><span class="p">,</span>
            <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="TimeSeries.rayleigh_spectrogram">
<a class="viewcode-back" href="../../../web/ja/reference/api/timeseries.html#gwexpy.timeseries.TimeSeries.rayleigh_spectrogram">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">rayleigh_spectrogram</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">fftlength</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">overlap</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                             <span class="n">window</span><span class="o">=</span><span class="s1">&#39;hann&#39;</span><span class="p">,</span> <span class="n">nproc</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate the Rayleigh statistic spectrogram of this `TimeSeries`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        stride : `float`</span>
<span class="sd">            number of seconds in single PSD (column of spectrogram).</span>

<span class="sd">        fftlength : `float`</span>
<span class="sd">            number of seconds in single FFT.</span>

<span class="sd">        overlap : `float`, optional</span>
<span class="sd">            number of seconds of overlap between FFTs, passing `None` will</span>
<span class="sd">            choose based on the window method, default: ``0``</span>

<span class="sd">        window : `str`, `numpy.ndarray`, optional</span>
<span class="sd">            window function to apply to timeseries prior to FFT,</span>
<span class="sd">            see :func:`scipy.signal.get_window` for details on acceptable</span>
<span class="sd">            formats</span>

<span class="sd">        nproc : `int`, optional</span>
<span class="sd">            maximum number of independent frame reading processes, default</span>
<span class="sd">            default: ``1``</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        spectrogram : `~gwpy.spectrogram.Spectrogram`</span>
<span class="sd">            time-frequency Rayleigh spectrogram as generated from the</span>
<span class="sd">            input time-series.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        TimeSeries.rayleigh</span>
<span class="sd">            for details of the statistic calculation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">specgram</span> <span class="o">=</span> <span class="n">spectral</span><span class="o">.</span><span class="n">average_spectrogram</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">spectral</span><span class="o">.</span><span class="n">rayleigh</span><span class="p">,</span>
            <span class="n">stride</span><span class="p">,</span>
            <span class="n">fftlength</span><span class="o">=</span><span class="n">fftlength</span><span class="p">,</span>
            <span class="n">overlap</span><span class="o">=</span><span class="n">overlap</span><span class="p">,</span>
            <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span>
            <span class="n">nproc</span><span class="o">=</span><span class="n">nproc</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>
        <span class="n">specgram</span><span class="o">.</span><span class="n">override_unit</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">specgram</span></div>


<div class="viewcode-block" id="TimeSeries.csd_spectrogram">
<a class="viewcode-back" href="../../../web/ja/reference/api/timeseries.html#gwexpy.timeseries.TimeSeries.csd_spectrogram">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">csd_spectrogram</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">fftlength</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">overlap</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                        <span class="n">window</span><span class="o">=</span><span class="s1">&#39;hann&#39;</span><span class="p">,</span> <span class="n">nproc</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate the cross spectral density spectrogram of this</span>
<span class="sd">           `TimeSeries` with &#39;other&#39;.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : `~gwpy.timeseries.TimeSeries`</span>
<span class="sd">            second time-series for cross spectral density calculation</span>

<span class="sd">        stride : `float`</span>
<span class="sd">            number of seconds in single PSD (column of spectrogram).</span>

<span class="sd">        fftlength : `float`</span>
<span class="sd">            number of seconds in single FFT.</span>

<span class="sd">        overlap : `float`, optional</span>
<span class="sd">            number of seconds of overlap between FFTs, defaults to the</span>
<span class="sd">            recommended overlap for the given window (if given), or 0</span>

<span class="sd">        window : `str`, `numpy.ndarray`, optional</span>
<span class="sd">            window function to apply to timeseries prior to FFT,</span>
<span class="sd">            see :func:`scipy.signal.get_window` for details on acceptable</span>
<span class="sd">            formats</span>

<span class="sd">        nproc : `int`</span>
<span class="sd">            maximum number of independent frame reading processes, default</span>
<span class="sd">            is set to single-process file reading.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        spectrogram : `~gwpy.spectrogram.Spectrogram`</span>
<span class="sd">            time-frequency cross spectrogram as generated from the</span>
<span class="sd">            two input time-series.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">spectral</span><span class="o">.</span><span class="n">average_spectrogram</span><span class="p">(</span>
            <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">),</span>
            <span class="n">spectral</span><span class="o">.</span><span class="n">csd</span><span class="p">,</span>
            <span class="n">stride</span><span class="p">,</span>
            <span class="n">fftlength</span><span class="o">=</span><span class="n">fftlength</span><span class="p">,</span>
            <span class="n">overlap</span><span class="o">=</span><span class="n">overlap</span><span class="p">,</span>
            <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span>
            <span class="n">nproc</span><span class="o">=</span><span class="n">nproc</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span></div>


    <span class="c1"># -- TimeSeries filtering -------------------</span>

<div class="viewcode-block" id="TimeSeries.highpass">
<a class="viewcode-back" href="../../../web/ja/reference/api/timeseries.html#gwexpy.timeseries.TimeSeries.highpass">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">highpass</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">frequency</span><span class="p">,</span> <span class="n">gpass</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">gstop</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">fstop</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;iir&#39;</span><span class="p">,</span>
                 <span class="n">filtfilt</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Filter this `TimeSeries` with a high-pass filter.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        frequency : `float`</span>
<span class="sd">            high-pass corner frequency</span>

<span class="sd">        gpass : `float`</span>
<span class="sd">            the maximum loss in the passband (dB).</span>

<span class="sd">        gstop : `float`</span>
<span class="sd">            the minimum attenuation in the stopband (dB).</span>

<span class="sd">        fstop : `float`</span>
<span class="sd">            stop-band edge frequency, defaults to `frequency * 1.5`</span>

<span class="sd">        type : `str`</span>
<span class="sd">            the filter type, either ``&#39;iir&#39;`` or ``&#39;fir&#39;``</span>

<span class="sd">        **kwargs</span>
<span class="sd">            other keyword arguments are passed to</span>
<span class="sd">            :func:`gwpy.signal.filter_design.highpass`</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        hpseries : `TimeSeries`</span>
<span class="sd">            a high-passed version of the input `TimeSeries`</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        gwpy.signal.filter_design.highpass</span>
<span class="sd">            for details on the filter design</span>
<span class="sd">        TimeSeries.filter</span>
<span class="sd">            for details on how the filter is applied</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># design filter</span>
        <span class="n">filt</span> <span class="o">=</span> <span class="n">filter_design</span><span class="o">.</span><span class="n">highpass</span><span class="p">(</span><span class="n">frequency</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_rate</span><span class="p">,</span>
                                      <span class="n">fstop</span><span class="o">=</span><span class="n">fstop</span><span class="p">,</span> <span class="n">gpass</span><span class="o">=</span><span class="n">gpass</span><span class="p">,</span> <span class="n">gstop</span><span class="o">=</span><span class="n">gstop</span><span class="p">,</span>
                                      <span class="n">analog</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">type</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># apply filter</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="o">*</span><span class="n">filt</span><span class="p">,</span> <span class="n">filtfilt</span><span class="o">=</span><span class="n">filtfilt</span><span class="p">)</span></div>


<div class="viewcode-block" id="TimeSeries.lowpass">
<a class="viewcode-back" href="../../../web/ja/reference/api/timeseries.html#gwexpy.timeseries.TimeSeries.lowpass">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">lowpass</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">frequency</span><span class="p">,</span> <span class="n">gpass</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">gstop</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">fstop</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;iir&#39;</span><span class="p">,</span>
                <span class="n">filtfilt</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Filter this `TimeSeries` with a Butterworth low-pass filter.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        frequency : `float`</span>
<span class="sd">            low-pass corner frequency</span>

<span class="sd">        gpass : `float`</span>
<span class="sd">            the maximum loss in the passband (dB).</span>

<span class="sd">        gstop : `float`</span>
<span class="sd">            the minimum attenuation in the stopband (dB).</span>

<span class="sd">        fstop : `float`</span>
<span class="sd">            stop-band edge frequency, defaults to `frequency * 1.5`</span>

<span class="sd">        type : `str`</span>
<span class="sd">            the filter type, either ``&#39;iir&#39;`` or ``&#39;fir&#39;``</span>

<span class="sd">        **kwargs</span>
<span class="sd">            other keyword arguments are passed to</span>
<span class="sd">            :func:`gwpy.signal.filter_design.lowpass`</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        lpseries : `TimeSeries`</span>
<span class="sd">            a low-passed version of the input `TimeSeries`</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        gwpy.signal.filter_design.lowpass</span>
<span class="sd">            for details on the filter design</span>
<span class="sd">        TimeSeries.filter</span>
<span class="sd">            for details on how the filter is applied</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># design filter</span>
        <span class="n">filt</span> <span class="o">=</span> <span class="n">filter_design</span><span class="o">.</span><span class="n">lowpass</span><span class="p">(</span><span class="n">frequency</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_rate</span><span class="p">,</span>
                                     <span class="n">fstop</span><span class="o">=</span><span class="n">fstop</span><span class="p">,</span> <span class="n">gpass</span><span class="o">=</span><span class="n">gpass</span><span class="p">,</span> <span class="n">gstop</span><span class="o">=</span><span class="n">gstop</span><span class="p">,</span>
                                     <span class="n">analog</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">type</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># apply filter</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="o">*</span><span class="n">filt</span><span class="p">,</span> <span class="n">filtfilt</span><span class="o">=</span><span class="n">filtfilt</span><span class="p">)</span></div>


<div class="viewcode-block" id="TimeSeries.bandpass">
<a class="viewcode-back" href="../../../web/ja/reference/api/timeseries.html#gwexpy.timeseries.TimeSeries.bandpass">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">bandpass</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flow</span><span class="p">,</span> <span class="n">fhigh</span><span class="p">,</span> <span class="n">gpass</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">gstop</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">fstop</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;iir&#39;</span><span class="p">,</span>
                 <span class="n">filtfilt</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Filter this `TimeSeries` with a band-pass filter.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        flow : `float`</span>
<span class="sd">            lower corner frequency of pass band</span>

<span class="sd">        fhigh : `float`</span>
<span class="sd">            upper corner frequency of pass band</span>

<span class="sd">        gpass : `float`</span>
<span class="sd">            the maximum loss in the passband (dB).</span>

<span class="sd">        gstop : `float`</span>
<span class="sd">            the minimum attenuation in the stopband (dB).</span>

<span class="sd">        fstop : `tuple` of `float`, optional</span>
<span class="sd">            `(low, high)` edge-frequencies of stop band</span>

<span class="sd">        type : `str`</span>
<span class="sd">            the filter type, either ``&#39;iir&#39;`` or ``&#39;fir&#39;``</span>

<span class="sd">        **kwargs</span>
<span class="sd">            other keyword arguments are passed to</span>
<span class="sd">            :func:`gwpy.signal.filter_design.bandpass`</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bpseries : `TimeSeries`</span>
<span class="sd">            a band-passed version of the input `TimeSeries`</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        gwpy.signal.filter_design.bandpass</span>
<span class="sd">            for details on the filter design</span>
<span class="sd">        TimeSeries.filter</span>
<span class="sd">            for details on how the filter is applied</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># design filter</span>
        <span class="n">filt</span> <span class="o">=</span> <span class="n">filter_design</span><span class="o">.</span><span class="n">bandpass</span><span class="p">(</span><span class="n">flow</span><span class="p">,</span> <span class="n">fhigh</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_rate</span><span class="p">,</span>
                                      <span class="n">fstop</span><span class="o">=</span><span class="n">fstop</span><span class="p">,</span> <span class="n">gpass</span><span class="o">=</span><span class="n">gpass</span><span class="p">,</span> <span class="n">gstop</span><span class="o">=</span><span class="n">gstop</span><span class="p">,</span>
                                      <span class="n">analog</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">type</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># apply filter</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="o">*</span><span class="n">filt</span><span class="p">,</span> <span class="n">filtfilt</span><span class="o">=</span><span class="n">filtfilt</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">resample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rate</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="s1">&#39;hamming&#39;</span><span class="p">,</span> <span class="n">ftype</span><span class="o">=</span><span class="s1">&#39;fir&#39;</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Resample this Series to a new rate</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        rate : `float`</span>
<span class="sd">            rate to which to resample this `Series`</span>

<span class="sd">        window : `str`, `numpy.ndarray`, optional</span>
<span class="sd">            window function to apply to signal in the Fourier domain,</span>
<span class="sd">            see :func:`scipy.signal.get_window` for details on acceptable</span>
<span class="sd">            formats, only used for `ftype=&#39;fir&#39;` or irregular downsampling</span>

<span class="sd">        ftype : `str`, optional</span>
<span class="sd">            type of filter, either &#39;fir&#39; or &#39;iir&#39;, defaults to &#39;fir&#39;</span>

<span class="sd">        n : `int`, optional</span>
<span class="sd">            if `ftype=&#39;fir&#39;` the number of taps in the filter, otherwise</span>
<span class="sd">            the order of the Chebyshev type I IIR filter</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series</span>
<span class="sd">            a new Series with the resampling applied, and the same</span>
<span class="sd">            metadata</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">ftype</span> <span class="o">==</span> <span class="s1">&#39;iir&#39;</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="mi">8</span>
        <span class="k">elif</span> <span class="n">n</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="mi">60</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rate</span><span class="p">,</span> <span class="n">units</span><span class="o">.</span><span class="n">Quantity</span><span class="p">):</span>
            <span class="n">rate</span> <span class="o">=</span> <span class="n">rate</span><span class="o">.</span><span class="n">value</span>
        <span class="n">factor</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_rate</span><span class="o">.</span><span class="n">value</span> <span class="o">/</span> <span class="n">rate</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">math</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">factor</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="n">rel_tol</span><span class="o">=</span><span class="mf">1e-09</span><span class="p">,</span> <span class="n">abs_tol</span><span class="o">=</span><span class="mf">0.</span><span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;resample() rate matches current sample_rate (</span><span class="si">{}</span><span class="s2">), returning &quot;</span>
                <span class="s2">&quot;input data unmodified; please double-check your &quot;</span>
                <span class="s2">&quot;parameters&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_rate</span><span class="p">),</span>
                <span class="ne">UserWarning</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="c1"># if integer down-sampling, use decimate</span>
        <span class="k">if</span> <span class="n">factor</span><span class="o">.</span><span class="n">is_integer</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">ftype</span> <span class="o">==</span> <span class="s1">&#39;iir&#39;</span><span class="p">:</span>
                <span class="n">filt</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">cheby1</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.8</span><span class="o">/</span><span class="n">factor</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s1">&#39;zpk&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">filt</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">firwin</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mf">1.</span><span class="o">/</span><span class="n">factor</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">filt</span><span class="p">,</span> <span class="n">filtfilt</span><span class="o">=</span><span class="kc">True</span><span class="p">)[::</span><span class="nb">int</span><span class="p">(</span><span class="n">factor</span><span class="p">)]</span>
        <span class="c1"># otherwise use Fourier filtering</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nsamp</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="o">.</span><span class="n">value</span> <span class="o">*</span> <span class="n">rate</span><span class="p">)</span>
            <span class="n">new</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">nsamp</span><span class="p">,</span>
                                  <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span>
            <span class="n">new</span><span class="o">.</span><span class="n">__metadata_finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="n">new</span><span class="o">.</span><span class="n">_unit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span>
            <span class="n">new</span><span class="o">.</span><span class="n">sample_rate</span> <span class="o">=</span> <span class="n">rate</span>
            <span class="k">return</span> <span class="n">new</span>

<div class="viewcode-block" id="TimeSeries.zpk">
<a class="viewcode-back" href="../../../web/ja/reference/api/timeseries.html#gwexpy.timeseries.TimeSeries.zpk">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">zpk</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">zeros</span><span class="p">,</span> <span class="n">poles</span><span class="p">,</span> <span class="n">gain</span><span class="p">,</span> <span class="n">analog</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Filter this `TimeSeries` by applying a zero-pole-gain filter</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        zeros : `array-like`</span>
<span class="sd">            list of zero frequencies (in Hertz)</span>

<span class="sd">        poles : `array-like`</span>
<span class="sd">            list of pole frequencies (in Hertz)</span>

<span class="sd">        gain : `float`</span>
<span class="sd">            DC gain of filter</span>

<span class="sd">        analog : `bool`, optional</span>
<span class="sd">            type of ZPK being applied, if `analog=True` all parameters</span>
<span class="sd">            will be converted in the Z-domain for digital filtering</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        timeseries : `TimeSeries`</span>
<span class="sd">            the filtered version of the input data</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        TimeSeries.filter</span>
<span class="sd">            for details on how a digital ZPK-format filter is applied</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        To apply a zpk filter with file poles at 100 Hz, and five zeros at</span>
<span class="sd">        1 Hz (giving an overall DC gain of 1e-10)::</span>

<span class="sd">        &gt;&gt;&gt; data2 = data.zpk([100]*5, [1]*5, 1e-10)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">zeros</span><span class="p">,</span> <span class="n">poles</span><span class="p">,</span> <span class="n">gain</span><span class="p">,</span> <span class="n">analog</span><span class="o">=</span><span class="n">analog</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="TimeSeries.filter">
<a class="viewcode-back" href="../../../web/ja/reference/api/timeseries.html#gwexpy.timeseries.TimeSeries.filter">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">filt</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Filter this `TimeSeries` with an IIR or FIR filter</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        *filt : filter arguments</span>
<span class="sd">            1, 2, 3, or 4 arguments defining the filter to be applied,</span>

<span class="sd">                - an ``Nx1`` `~numpy.ndarray` of FIR coefficients</span>
<span class="sd">                - an ``Nx6`` `~numpy.ndarray` of SOS coefficients</span>
<span class="sd">                - ``(numerator, denominator)`` polynomials</span>
<span class="sd">                - ``(zeros, poles, gain)``</span>
<span class="sd">                - ``(A, B, C, D)`` &#39;state-space&#39; representation</span>

<span class="sd">        filtfilt : `bool`, optional</span>
<span class="sd">            filter forward and backwards to preserve phase,</span>
<span class="sd">            default: `False`</span>

<span class="sd">        analog : `bool`, optional</span>
<span class="sd">            if `True`, filter coefficients will be converted from Hz</span>
<span class="sd">            to Z-domain digital representation, default: `False`</span>

<span class="sd">        inplace : `bool`, optional</span>
<span class="sd">            if `True`, this array will be overwritten with the filtered</span>
<span class="sd">            version, default: `False`</span>

<span class="sd">        **kwargs</span>
<span class="sd">            other keyword arguments are passed to the filter method</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        result : `TimeSeries`</span>
<span class="sd">            the filtered version of the input `TimeSeries`</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        IIR filters are converted into cascading second-order sections before</span>
<span class="sd">        being applied to this `TimeSeries`.</span>

<span class="sd">        FIR filters are passed directly to :func:`scipy.signal.lfilter` or</span>
<span class="sd">        :func:`scipy.signal.filtfilt` without any conversions.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        scipy.signal.sosfilt</span>
<span class="sd">            for details on filtering with second-order sections</span>

<span class="sd">        scipy.signal.sosfiltfilt</span>
<span class="sd">            for details on forward-backward filtering with second-order</span>
<span class="sd">            sections</span>

<span class="sd">        scipy.signal.lfilter</span>
<span class="sd">            for details on filtering (without SOS)</span>

<span class="sd">        scipy.signal.filtfilt</span>
<span class="sd">            for details on forward-backward filtering (without SOS)</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            if ``filt`` arguments cannot be interpreted properly</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        We can design an arbitrarily complicated filter using</span>
<span class="sd">        :mod:`gwpy.signal.filter_design`</span>

<span class="sd">        &gt;&gt;&gt; from gwpy.signal import filter_design</span>
<span class="sd">        &gt;&gt;&gt; bp = filter_design.bandpass(50, 250, 4096.)</span>
<span class="sd">        &gt;&gt;&gt; notches = [filter_design.notch(f, 4096.) for f in (60, 120, 180)]</span>
<span class="sd">        &gt;&gt;&gt; zpk = filter_design.concatenate_zpks(bp, *notches)</span>

<span class="sd">        And then can download some data from GWOSC to apply it using</span>
<span class="sd">        `TimeSeries.filter`:</span>

<span class="sd">        &gt;&gt;&gt; from gwpy.timeseries import TimeSeries</span>
<span class="sd">        &gt;&gt;&gt; data = TimeSeries.fetch_open_data(&#39;H1&#39;, 1126259446, 1126259478)</span>
<span class="sd">        &gt;&gt;&gt; filtered = data.filter(zpk, filtfilt=True)</span>

<span class="sd">        We can plot the original signal, and the filtered version, cutting</span>
<span class="sd">        off either end of the filtered data to remove filter-edge artefacts</span>

<span class="sd">        &gt;&gt;&gt; from gwpy.plot import Plot</span>
<span class="sd">        &gt;&gt;&gt; plot = Plot(data, filtered[128:-128], separate=True)</span>
<span class="sd">        &gt;&gt;&gt; plot.show()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># parse keyword arguments</span>
        <span class="n">filtfilt</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;filtfilt&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="c1"># parse filter</span>
        <span class="n">form</span><span class="p">,</span> <span class="n">filt</span> <span class="o">=</span> <span class="n">filter_design</span><span class="o">.</span><span class="n">parse_filter</span><span class="p">(</span>
            <span class="n">filt</span><span class="p">,</span>
            <span class="n">analog</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;analog&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">),</span>
            <span class="n">sample_rate</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_rate</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s1">&#39;Hz&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">form</span> <span class="o">==</span> <span class="s1">&#39;zpk&#39;</span><span class="p">:</span>
            <span class="n">sos</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">zpk2sos</span><span class="p">(</span><span class="o">*</span><span class="n">filt</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sos</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">filt</span>

        <span class="c1"># perform filter</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;axis&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sos</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">filtfilt</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">sosfiltfilt</span><span class="p">(</span><span class="n">sos</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">sos</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">sosfilt</span><span class="p">(</span><span class="n">sos</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">filtfilt</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">filtfilt</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">lfilter</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># format as type(self)</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="n">new</span><span class="o">.</span><span class="n">__metadata_finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">new</span><span class="o">.</span><span class="n">_unit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span>
        <span class="k">return</span> <span class="n">new</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">transfer_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">fftlength</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">overlap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                          <span class="n">window</span><span class="o">=</span><span class="s1">&#39;hann&#39;</span><span class="p">,</span> <span class="n">average</span><span class="o">=</span><span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate the transfer function between this `TimeSeries` and</span>
<span class="sd">        another.</span>

<span class="sd">        This `TimeSeries` is the &#39;A-channel&#39;, serving as the reference</span>
<span class="sd">        (denominator) while the other time series is the test (numerator)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : `TimeSeries`</span>
<span class="sd">            `TimeSeries` signal to calculate the transfer function with</span>

<span class="sd">        fftlength : `float`, optional</span>
<span class="sd">            number of seconds in single FFT, defaults to a single FFT</span>
<span class="sd">            covering the full duration</span>

<span class="sd">        overlap : `float`, optional</span>
<span class="sd">            number of seconds of overlap between FFTs, defaults to the</span>
<span class="sd">            recommended overlap for the given window (if given), or 0</span>

<span class="sd">        window : `str`, `numpy.ndarray`, optional</span>
<span class="sd">            window function to apply to timeseries prior to FFT,</span>
<span class="sd">            see :func:`scipy.signal.get_window` for details on acceptable</span>
<span class="sd">            formats</span>

<span class="sd">        average : `str`, optional</span>
<span class="sd">            FFT-averaging method (default: ``&#39;mean&#39;``) passed to</span>
<span class="sd">            underlying csd() and psd() methods</span>

<span class="sd">        **kwargs</span>
<span class="sd">            any other keyword arguments accepted by</span>
<span class="sd">            :meth:`TimeSeries.csd` or :meth:`TimeSeries.psd`</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        transfer_function : `~gwpy.frequencyseries.FrequencySeries`</span>
<span class="sd">            the transfer function `FrequencySeries` of this `TimeSeries`</span>
<span class="sd">            with the other</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If `self` and `other` have difference</span>
<span class="sd">        :attr:`TimeSeries.sample_rate` values, the higher sampled</span>
<span class="sd">        `TimeSeries` will be down-sampled to match the lower.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">csd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">csd</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">fftlength</span><span class="o">=</span><span class="n">fftlength</span><span class="p">,</span> <span class="n">overlap</span><span class="o">=</span><span class="n">overlap</span><span class="p">,</span>
                       <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span> <span class="n">average</span><span class="o">=</span><span class="n">average</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">psd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">psd</span><span class="p">(</span><span class="n">fftlength</span><span class="o">=</span><span class="n">fftlength</span><span class="p">,</span> <span class="n">overlap</span><span class="o">=</span><span class="n">overlap</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span>
                       <span class="n">average</span><span class="o">=</span><span class="n">average</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Take the minimum of the frequencyseries csd and psd because the</span>
        <span class="c1"># sample rate of different channels might yield different length</span>
        <span class="c1"># objects</span>
        <span class="n">size</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">csd</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">psd</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">csd</span><span class="p">[:</span><span class="n">size</span><span class="p">]</span> <span class="o">/</span> <span class="n">psd</span><span class="p">[:</span><span class="n">size</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">coherence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">fftlength</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">overlap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                  <span class="n">window</span><span class="o">=</span><span class="s1">&#39;hann&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate the frequency-coherence between this `TimeSeries`</span>
<span class="sd">        and another.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : `TimeSeries`</span>
<span class="sd">            `TimeSeries` signal to calculate coherence with</span>

<span class="sd">        fftlength : `float`, optional</span>
<span class="sd">            number of seconds in single FFT, defaults to a single FFT</span>
<span class="sd">            covering the full duration</span>

<span class="sd">        overlap : `float`, optional</span>
<span class="sd">            number of seconds of overlap between FFTs, defaults to the</span>
<span class="sd">            recommended overlap for the given window (if given), or 0</span>

<span class="sd">        window : `str`, `numpy.ndarray`, optional</span>
<span class="sd">            window function to apply to timeseries prior to FFT,</span>
<span class="sd">            see :func:`scipy.signal.get_window` for details on acceptable</span>
<span class="sd">            formats</span>

<span class="sd">        **kwargs</span>
<span class="sd">            any other keyword arguments accepted by</span>
<span class="sd">            :func:`matplotlib.mlab.cohere` except ``NFFT``, ``window``,</span>
<span class="sd">            and ``noverlap`` which are superceded by the above keyword</span>
<span class="sd">            arguments</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        coherence : `~gwpy.frequencyseries.FrequencySeries`</span>
<span class="sd">            the coherence `FrequencySeries` of this `TimeSeries`</span>
<span class="sd">            with the other</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If `self` and `other` have difference</span>
<span class="sd">        :attr:`TimeSeries.sample_rate` values, the higher sampled</span>
<span class="sd">        `TimeSeries` will be down-sampled to match the lower.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        scipy.signal.coherence</span>
<span class="sd">            for details of the coherence calculator</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">spectral</span><span class="o">.</span><span class="n">psd</span><span class="p">(</span>
            <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">),</span>
            <span class="n">spectral</span><span class="o">.</span><span class="n">coherence</span><span class="p">,</span>
            <span class="n">fftlength</span><span class="o">=</span><span class="n">fftlength</span><span class="p">,</span>
            <span class="n">overlap</span><span class="o">=</span><span class="n">overlap</span><span class="p">,</span>
            <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>

<div class="viewcode-block" id="TimeSeries.auto_coherence">
<a class="viewcode-back" href="../../../web/ja/reference/api/timeseries.html#gwexpy.timeseries.TimeSeries.auto_coherence">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">auto_coherence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">fftlength</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">overlap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">window</span><span class="o">=</span><span class="s1">&#39;hann&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate the frequency-coherence between this `TimeSeries`</span>
<span class="sd">        and a time-shifted copy of itself.</span>

<span class="sd">        The standard :meth:`TimeSeries.coherence` is calculated between</span>
<span class="sd">        the input `TimeSeries` and a :meth:`cropped &lt;TimeSeries.crop&gt;`</span>
<span class="sd">        copy of itself. Since the cropped version will be shorter, the</span>
<span class="sd">        input series will be shortened to match.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dt : `float`</span>
<span class="sd">            duration (in seconds) of time-shift</span>

<span class="sd">        fftlength : `float`, optional</span>
<span class="sd">            number of seconds in single FFT, defaults to a single FFT</span>
<span class="sd">            covering the full duration</span>

<span class="sd">        overlap : `float`, optional</span>
<span class="sd">            number of seconds of overlap between FFTs, defaults to the</span>
<span class="sd">            recommended overlap for the given window (if given), or 0</span>

<span class="sd">        window : `str`, `numpy.ndarray`, optional</span>
<span class="sd">            window function to apply to timeseries prior to FFT,</span>
<span class="sd">            see :func:`scipy.signal.get_window` for details on acceptable</span>
<span class="sd">            formats</span>

<span class="sd">        **kwargs</span>
<span class="sd">            any other keyword arguments accepted by</span>
<span class="sd">            :func:`matplotlib.mlab.cohere` except ``NFFT``, ``window``,</span>
<span class="sd">            and ``noverlap`` which are superceded by the above keyword</span>
<span class="sd">            arguments</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        coherence : `~gwpy.frequencyseries.FrequencySeries`</span>
<span class="sd">            the coherence `FrequencySeries` of this `TimeSeries`</span>
<span class="sd">            with the other</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The :meth:`TimeSeries.auto_coherence` will perform best when</span>
<span class="sd">        ``dt`` is approximately ``fftlength / 2``.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        matplotlib.mlab.cohere</span>
<span class="sd">            for details of the coherence calculator</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># shifting self backwards is the same as forwards</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
        <span class="c1"># crop inputs</span>
        <span class="n">self_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">crop</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">span</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">span</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">dt</span><span class="p">)</span>
        <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">crop</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">span</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">dt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">span</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">self_</span><span class="o">.</span><span class="n">coherence</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">fftlength</span><span class="o">=</span><span class="n">fftlength</span><span class="p">,</span>
                               <span class="n">overlap</span><span class="o">=</span><span class="n">overlap</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="TimeSeries.coherence_spectrogram">
<a class="viewcode-back" href="../../../web/ja/reference/api/timeseries.html#gwexpy.timeseries.TimeSeries.coherence_spectrogram">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">coherence_spectrogram</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">fftlength</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                              <span class="n">overlap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="s1">&#39;hann&#39;</span><span class="p">,</span> <span class="n">nproc</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate the coherence spectrogram between this `TimeSeries`</span>
<span class="sd">        and other.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : `TimeSeries`</span>
<span class="sd">            the second `TimeSeries` in this CSD calculation</span>

<span class="sd">        stride : `float`</span>
<span class="sd">            number of seconds in single PSD (column of spectrogram)</span>

<span class="sd">        fftlength : `float`</span>
<span class="sd">            number of seconds in single FFT</span>

<span class="sd">        overlap : `float`, optional</span>
<span class="sd">            number of seconds of overlap between FFTs, defaults to the</span>
<span class="sd">            recommended overlap for the given window (if given), or 0</span>

<span class="sd">        window : `str`, `numpy.ndarray`, optional</span>
<span class="sd">            window function to apply to timeseries prior to FFT,</span>
<span class="sd">            see :func:`scipy.signal.get_window` for details on acceptable</span>
<span class="sd">            formats</span>

<span class="sd">        nproc : `int`</span>
<span class="sd">            number of parallel processes to use when calculating</span>
<span class="sd">            individual coherence spectra.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        spectrogram : `~gwpy.spectrogram.Spectrogram`</span>
<span class="sd">            time-frequency coherence spectrogram as generated from the</span>
<span class="sd">            input time-series.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">..spectrogram.coherence</span><span class="w"> </span><span class="kn">import</span> <span class="n">from_timeseries</span>
        <span class="k">return</span> <span class="n">from_timeseries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">fftlength</span><span class="o">=</span><span class="n">fftlength</span><span class="p">,</span>
                               <span class="n">overlap</span><span class="o">=</span><span class="n">overlap</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span>
                               <span class="n">nproc</span><span class="o">=</span><span class="n">nproc</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">rms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate the root-mean-square value of this `TimeSeries`</span>
<span class="sd">        once per stride.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        stride : `float`</span>
<span class="sd">            stride (seconds) between RMS calculations</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        rms : `TimeSeries`</span>
<span class="sd">            a new `TimeSeries` containing the RMS value with dt=stride</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">stridesamp</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">stride</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_rate</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="n">nsteps</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">//</span> <span class="n">stridesamp</span><span class="p">)</span>
        <span class="c1"># stride through TimeSeries, recording RMS</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nsteps</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nsteps</span><span class="p">):</span>
            <span class="c1"># find step TimeSeries</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">stridesamp</span> <span class="o">*</span> <span class="n">step</span><span class="p">)</span>
            <span class="n">idx_end</span> <span class="o">=</span> <span class="n">idx</span> <span class="o">+</span> <span class="n">stridesamp</span>
            <span class="n">stepseries</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">idx</span><span class="p">:</span><span class="n">idx_end</span><span class="p">]</span>
            <span class="n">rms_</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">stepseries</span><span class="o">.</span><span class="n">value</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
            <span class="n">data</span><span class="p">[</span><span class="n">step</span><span class="p">]</span> <span class="o">=</span> <span class="n">rms_</span>
        <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> </span><span class="si">%.2f</span><span class="s1">-second RMS&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">stride</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">channel</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">channel</span><span class="p">,</span> <span class="n">t0</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">t0</span><span class="p">,</span>
                              <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">sample_rate</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">stride</span><span class="p">)))</span>

<div class="viewcode-block" id="TimeSeries.mask">
<a class="viewcode-back" href="../../../web/ja/reference/api/timeseries.html#gwexpy.timeseries.TimeSeries.mask">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deadtime</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">flag</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">query_open_data</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
             <span class="n">const</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">tpad</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Mask away portions of this `TimeSeries` that fall within a given</span>
<span class="sd">        list of time segments</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        deadtime : `SegmentList`, optional</span>
<span class="sd">            a list of time segments defining the deadtime (i.e., masked</span>
<span class="sd">            portions) of the output, will supersede `flag` if given</span>

<span class="sd">        flag : `str`, optional</span>
<span class="sd">            the name of a data-quality flag for which to query, required if</span>
<span class="sd">            `deadtime` is not given</span>

<span class="sd">        query_open_data : `bool`, optional</span>
<span class="sd">            if `True`, will query for publicly released data-quality segments</span>
<span class="sd">            through the Gravitational-wave Open Science Center (GWOSC),</span>
<span class="sd">            default: `False`</span>

<span class="sd">        const : `float`, optional</span>
<span class="sd">            constant value with which to mask deadtime data,</span>
<span class="sd">            default: `~numpy.nan`</span>

<span class="sd">        tpad : `float`, optional</span>
<span class="sd">            length of time (in seconds) over which to taper off data at</span>
<span class="sd">            mask segment boundaries, default: 0.5 seconds</span>

<span class="sd">        **kwargs : `dict`, optional</span>
<span class="sd">            additional keyword arguments to</span>
<span class="sd">            `~gwpy.segments.DataQualityFlag.query` or</span>
<span class="sd">            `~gwpy.segments.DataQualityFlag.fetch_open_data`,</span>
<span class="sd">            see &quot;Notes&quot; below</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : `TimeSeries`</span>
<span class="sd">            the masked version of this `TimeSeries`</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If `tpad` is nonzero, the Planck-taper window is used to smoothly</span>
<span class="sd">        ramp data down to zero over a timescale `tpad` approaching every</span>
<span class="sd">        segment boundary in `deadtime`. However, this does not apply to</span>
<span class="sd">        the left or right bounds of the original `TimeSeries`.</span>

<span class="sd">        The `deadtime` segment list will always be coalesced and restricted to</span>
<span class="sd">        the limits of `self.span`. In particular, when querying a data-quality</span>
<span class="sd">        flag, this means the `start` and `end` arguments to</span>
<span class="sd">        `~gwpy.segments.DataQualityFlag.query` will effectively be reset and</span>
<span class="sd">        therefore need not be given.</span>

<span class="sd">        If `flag` is interpreted positively, i.e. if `flag` being active</span>
<span class="sd">        corresponds to a &quot;good&quot; state, then its complement in `self.span`</span>
<span class="sd">        will be used to define the deadtime for masking.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        gwpy.segments.DataQualityFlag.query</span>
<span class="sd">            for the method to query segments of a given data-quality flag</span>
<span class="sd">        gwpy.segments.DataQualityFlag.fetch_open_data</span>
<span class="sd">            for the method to query data-quality flags from the GWOSC database</span>
<span class="sd">        gwpy.signal.window.planck</span>
<span class="sd">            for the generic Planck-taper window</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">query_method</span> <span class="o">=</span> <span class="p">(</span><span class="n">DataQualityFlag</span><span class="o">.</span><span class="n">fetch_open_data</span> <span class="k">if</span> <span class="n">query_open_data</span>
                        <span class="k">else</span> <span class="n">DataQualityFlag</span><span class="o">.</span><span class="n">query</span><span class="p">)</span>
        <span class="p">(</span><span class="n">tstart</span><span class="p">,</span> <span class="n">tend</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">span</span>
        <span class="n">span</span> <span class="o">=</span> <span class="n">SegmentList</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">span</span><span class="p">])</span>
        <span class="n">sample</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_rate</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s1">&#39;Hz&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">value</span>
        <span class="n">npad</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tpad</span> <span class="o">*</span> <span class="n">sample</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># query the requested data-quality flag</span>
        <span class="k">if</span> <span class="n">deadtime</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;start&#39;</span><span class="p">,</span> <span class="n">tstart</span><span class="p">)</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;end&#39;</span><span class="p">,</span> <span class="n">tend</span><span class="p">)</span>
            <span class="n">dqflag</span> <span class="o">=</span> <span class="n">query_method</span><span class="p">(</span>
                <span class="n">flag</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">end</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">deadtime</span> <span class="o">=</span> <span class="p">(</span><span class="o">~</span><span class="n">dqflag</span><span class="o">.</span><span class="n">active</span> <span class="k">if</span> <span class="n">dqflag</span><span class="o">.</span><span class="n">isgood</span>
                        <span class="k">else</span> <span class="n">dqflag</span><span class="o">.</span><span class="n">active</span><span class="p">)</span>
        <span class="c1"># identify timestamps and mask out</span>
        <span class="n">deadtime</span> <span class="o">=</span> <span class="p">(</span><span class="n">deadtime</span> <span class="o">&amp;</span> <span class="n">span</span><span class="p">)</span><span class="o">.</span><span class="n">coalesce</span><span class="p">()</span>
        <span class="n">timestamps</span> <span class="o">=</span> <span class="n">tstart</span> <span class="o">+</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="o">/</span> <span class="n">sample</span>
        <span class="p">(</span><span class="n">masked</span><span class="p">,</span> <span class="p">)</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nonzero</span><span class="p">([</span><span class="n">t</span> <span class="ow">in</span> <span class="n">deadtime</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">timestamps</span><span class="p">])</span>
        <span class="n">out</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="n">masked</span><span class="p">]</span> <span class="o">=</span> <span class="n">const</span>
        <span class="c1"># taper off at segment boundaries, being careful not to taper</span>
        <span class="c1"># at either edge of the original TimeSeries, and to cut off</span>
        <span class="c1"># the taper window in segments that are too short</span>
        <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="p">(</span><span class="n">span</span> <span class="o">-</span> <span class="n">deadtime</span><span class="p">):</span>
            <span class="n">k</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">seg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">tstart</span><span class="p">)</span> <span class="o">*</span> <span class="n">sample</span><span class="p">)</span>
            <span class="n">N</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">seg</span><span class="p">)</span> <span class="o">*</span> <span class="n">sample</span><span class="p">)</span>
            <span class="n">nhalf</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">npad</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
            <span class="n">window</span> <span class="o">=</span> <span class="n">planck</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">npad</span><span class="p">,</span> <span class="n">nleft</span><span class="o">=</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">k</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="n">npad</span><span class="p">),</span>
                            <span class="n">nright</span><span class="o">=</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="n">N</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="o">*</span> <span class="n">npad</span><span class="p">))</span>
            <span class="n">out</span><span class="p">[</span><span class="n">k</span><span class="p">:</span><span class="n">k</span><span class="o">+</span><span class="n">nhalf</span><span class="p">]</span> <span class="o">*=</span> <span class="n">window</span><span class="p">[:</span><span class="n">nhalf</span><span class="p">]</span>
            <span class="n">out</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="n">N</span><span class="o">-</span><span class="n">nhalf</span><span class="p">:</span><span class="n">k</span><span class="o">+</span><span class="n">N</span><span class="p">]</span> <span class="o">*=</span> <span class="n">window</span><span class="p">[</span><span class="o">-</span><span class="n">nhalf</span><span class="p">:]</span>
        <span class="k">return</span> <span class="n">out</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">demodulate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">exp</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">deg</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the average magnitude and phase of this `TimeSeries`</span>
<span class="sd">        once per stride at a given frequency</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        f : `float`</span>
<span class="sd">            frequency (Hz) at which to demodulate the signal</span>

<span class="sd">        stride : `float`, optional</span>
<span class="sd">            stride (seconds) between calculations, defaults to 1 second</span>

<span class="sd">        exp : `bool`, optional</span>
<span class="sd">            return the magnitude and phase trends as one `TimeSeries` object</span>
<span class="sd">            representing a complex exponential, default: False</span>

<span class="sd">        deg : `bool`, optional</span>
<span class="sd">            if `exp=False`, calculates the phase in degrees</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mag, phase : `TimeSeries`</span>
<span class="sd">            if `exp=False`, returns a pair of `TimeSeries` objects representing</span>
<span class="sd">            magnitude and phase trends with `dt=stride`</span>

<span class="sd">        out : `TimeSeries`</span>
<span class="sd">            if `exp=True`, returns a single `TimeSeries` with magnitude and</span>
<span class="sd">            phase trends represented as `mag * exp(1j*phase)` with `dt=stride`</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Demodulation is useful when trying to examine steady sinusoidal</span>
<span class="sd">        signals we know to be contained within data. For instance,</span>
<span class="sd">        we can download some data from GWOSC to look at trends of the</span>
<span class="sd">        amplitude and phase of LIGO Livingston&#39;s calibration line at 331.3 Hz:</span>

<span class="sd">        &gt;&gt;&gt; from gwpy.timeseries import TimeSeries</span>
<span class="sd">        &gt;&gt;&gt; data = TimeSeries.fetch_open_data(&#39;L1&#39;, 1131350417, 1131357617)</span>

<span class="sd">        We can demodulate the `TimeSeries` at 331.3 Hz with a stride of one</span>
<span class="sd">        minute:</span>

<span class="sd">        &gt;&gt;&gt; amp, phase = data.demodulate(331.3, stride=60)</span>

<span class="sd">        We can then plot these trends to visualize fluctuations in the</span>
<span class="sd">        amplitude of the calibration line:</span>

<span class="sd">        &gt;&gt;&gt; from gwpy.plot import Plot</span>
<span class="sd">        &gt;&gt;&gt; plot = Plot(amp)</span>
<span class="sd">        &gt;&gt;&gt; ax = plot.gca()</span>
<span class="sd">        &gt;&gt;&gt; ax.set_ylabel(&#39;Strain Amplitude at 331.3 Hz&#39;)</span>
<span class="sd">        &gt;&gt;&gt; plot.show()</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        TimeSeries.heterodyne</span>
<span class="sd">            for the underlying heterodyne detection method</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># stride through the TimeSeries and heterodyne at a single frequency</span>
        <span class="n">phase</span> <span class="o">=</span> <span class="p">(</span>
            <span class="mi">2</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">f</span>
            <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">decompose</span><span class="p">()</span><span class="o">.</span><span class="n">value</span>
            <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">heterodyne</span><span class="p">(</span><span class="n">phase</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="n">stride</span><span class="p">,</span> <span class="n">singlesided</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">exp</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">out</span>
        <span class="n">mag</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">abs</span><span class="p">()</span>
        <span class="n">phase</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">mag</span><span class="p">)(</span><span class="n">numpy</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">deg</span><span class="o">=</span><span class="n">deg</span><span class="p">))</span>
        <span class="n">phase</span><span class="o">.</span><span class="n">__array_finalize__</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
        <span class="n">phase</span><span class="o">.</span><span class="n">override_unit</span><span class="p">(</span><span class="s1">&#39;deg&#39;</span> <span class="k">if</span> <span class="n">deg</span> <span class="k">else</span> <span class="s1">&#39;rad&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">mag</span><span class="p">,</span> <span class="n">phase</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">heterodyne</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">phase</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">singlesided</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the average magnitude and phase of this `TimeSeries`</span>
<span class="sd">        once per stride after heterodyning with a given phase series</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        phase : `array_like`</span>
<span class="sd">            an array of phase measurements (radians) with which to heterodyne</span>
<span class="sd">            the signal</span>

<span class="sd">        stride : `float`, optional</span>
<span class="sd">            stride (seconds) between calculations, defaults to 1 second</span>

<span class="sd">        singlesided : `bool`, optional</span>
<span class="sd">            Boolean switch to return single-sided output (i.e., to multiply by</span>
<span class="sd">            2 so that the signal is distributed across positive frequencies</span>
<span class="sd">            only), default: False</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : `TimeSeries`</span>
<span class="sd">            magnitude and phase trends, represented as</span>
<span class="sd">            `mag * exp(1j*phase)` with `dt=stride`</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This is similar to the :meth:`~gwpy.timeseries.TimeSeries.demodulate`</span>
<span class="sd">        method, but is more general in that it accepts a varying phase</span>
<span class="sd">        evolution, rather than a fixed frequency.</span>

<span class="sd">        Unlike :meth:`~gwpy.timeseries.TimeSeries.demodulate`, the complex</span>
<span class="sd">        output is double-sided by default, so is not multiplied by 2.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Heterodyning can be useful in analysing quasi-monochromatic signals</span>
<span class="sd">        with a known phase evolution, such as continuous-wave signals</span>
<span class="sd">        from rapidly rotating neutron stars. These sources radiate at a</span>
<span class="sd">        frequency that slowly decreases over time, and is Doppler modulated</span>
<span class="sd">        due to the Earth&#39;s rotational and orbital motion.</span>

<span class="sd">        To see an example of heterodyning in action, we can simulate a signal</span>
<span class="sd">        whose phase evolution is described by the frequency and its first</span>
<span class="sd">        derivative with respect to time. We can download some O1 era</span>
<span class="sd">        LIGO-Livingston data from GWOSC, inject the simulated signal, and</span>
<span class="sd">        recover its amplitude.</span>

<span class="sd">        &gt;&gt;&gt; from gwpy.timeseries import TimeSeries</span>
<span class="sd">        &gt;&gt;&gt; data = TimeSeries.fetch_open_data(&#39;L1&#39;, 1131350417, 1131354017)</span>

<span class="sd">        We now need to set the signal parameters, generate the expected</span>
<span class="sd">        phase evolution, and create the signal:</span>

<span class="sd">        &gt;&gt;&gt; import numpy</span>
<span class="sd">        &gt;&gt;&gt; f0 = 123.456789  # signal frequency (Hz)</span>
<span class="sd">        &gt;&gt;&gt; fdot = -9.87654321e-7  # signal frequency derivative (Hz/s)</span>
<span class="sd">        &gt;&gt;&gt; fepoch = 1131350417  # phase epoch</span>
<span class="sd">        &gt;&gt;&gt; amp = 1.5e-22  # signal amplitude</span>
<span class="sd">        &gt;&gt;&gt; phase0 = 0.4  # signal phase at the phase epoch</span>
<span class="sd">        &gt;&gt;&gt; times = data.times.value - fepoch</span>
<span class="sd">        &gt;&gt;&gt; phase = 2 * numpy.pi * (f0 * times + 0.5 * fdot * times**2)</span>
<span class="sd">        &gt;&gt;&gt; signal = TimeSeries(amp * numpy.cos(phase + phase0),</span>
<span class="sd">        &gt;&gt;&gt;                     sample_rate=data.sample_rate, t0=data.t0)</span>
<span class="sd">        &gt;&gt;&gt; data = data.inject(signal)</span>

<span class="sd">        To recover the signal, we can bandpass the injected data around the</span>
<span class="sd">        signal frequency, then heterodyne using our phase model with a stride</span>
<span class="sd">        of 60 seconds:</span>

<span class="sd">        &gt;&gt;&gt; filtdata = data.bandpass(f0 - 0.5, f0 + 0.5)</span>
<span class="sd">        &gt;&gt;&gt; het = filtdata.heterodyne(phase, stride=60, singlesided=True)</span>

<span class="sd">        We can then plot signal amplitude over time (cropping the first two</span>
<span class="sd">        minutes to remove the filter response):</span>

<span class="sd">        &gt;&gt;&gt; plot = het.crop(het.x0.value + 180).abs().plot()</span>
<span class="sd">        &gt;&gt;&gt; ax = plot.gca()</span>
<span class="sd">        &gt;&gt;&gt; ax.set_ylabel(&quot;Strain amplitude&quot;)</span>
<span class="sd">        &gt;&gt;&gt; plot.show()</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        TimeSeries.demodulate</span>
<span class="sd">            for a method to heterodyne at a fixed frequency</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">phaselen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">phase</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Phase is not array_like: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">exc</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">phaselen</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Phase array must be the same length as the TimeSeries&quot;</span>
            <span class="p">)</span>
        <span class="n">stridesamp</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">stride</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_rate</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="n">nsteps</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">//</span> <span class="n">stridesamp</span><span class="p">)</span>
        <span class="c1"># stride through the TimeSeries and heterodyne</span>
        <span class="n">out</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nsteps</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">))</span>
        <span class="n">out</span><span class="o">.</span><span class="n">__array_finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">out</span><span class="o">.</span><span class="n">sample_rate</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">stride</span><span class="p">)</span>
        <span class="n">phasearray</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">phase</span><span class="p">)</span>  <span class="c1"># make sure phase is a numpy array</span>
        <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nsteps</span><span class="p">):</span>
            <span class="n">istart</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">stridesamp</span> <span class="o">*</span> <span class="n">step</span><span class="p">)</span>
            <span class="n">iend</span> <span class="o">=</span> <span class="n">istart</span> <span class="o">+</span> <span class="n">stridesamp</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">istart</span><span class="p">,</span> <span class="n">iend</span><span class="p">)</span>
            <span class="n">mixed</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">phasearray</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="n">out</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="n">step</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">mixed</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span> <span class="k">if</span> <span class="n">singlesided</span> <span class="k">else</span> <span class="n">mixed</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">out</span>

<div class="viewcode-block" id="TimeSeries.taper">
<a class="viewcode-back" href="../../../web/ja/reference/api/timeseries.html#gwexpy.timeseries.TimeSeries.taper">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">taper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s1">&#39;leftright&#39;</span><span class="p">,</span> <span class="n">duration</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Taper the ends of this `TimeSeries` smoothly to zero.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        side : `str`, optional</span>
<span class="sd">            the side of the `TimeSeries` to taper, must be one of `&#39;left&#39;`,</span>
<span class="sd">            `&#39;right&#39;`, or `&#39;leftright&#39;`</span>

<span class="sd">        duration : `float`, optional</span>
<span class="sd">            the duration of time to taper, will override `nsamples`</span>
<span class="sd">            if both are provided as arguments</span>

<span class="sd">        nsamples : `int`, optional</span>
<span class="sd">            the number of samples to taper, will be overridden by `duration`</span>
<span class="sd">            if both are provided as arguments</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : `TimeSeries`</span>
<span class="sd">            a copy of `self` tapered at one or both ends</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            if `side` is not one of `(&#39;left&#39;, &#39;right&#39;, &#39;leftright&#39;)`</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        To see the effect of the Planck-taper window, we can taper a</span>
<span class="sd">        sinusoidal `TimeSeries` at both ends:</span>

<span class="sd">        &gt;&gt;&gt; import numpy</span>
<span class="sd">        &gt;&gt;&gt; from gwpy.timeseries import TimeSeries</span>
<span class="sd">        &gt;&gt;&gt; t = numpy.linspace(0, 1, 2048)</span>
<span class="sd">        &gt;&gt;&gt; series = TimeSeries(numpy.cos(10.5*numpy.pi*t), times=t)</span>
<span class="sd">        &gt;&gt;&gt; tapered = series.taper()</span>

<span class="sd">        We can plot it to see how the ends now vary smoothly from 0 to 1:</span>

<span class="sd">        &gt;&gt;&gt; from gwpy.plot import Plot</span>
<span class="sd">        &gt;&gt;&gt; plot = Plot(series, tapered, separate=True, sharex=True)</span>
<span class="sd">        &gt;&gt;&gt; plot.show()</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The :meth:`TimeSeries.taper` automatically tapers from the second</span>
<span class="sd">        stationary point (local maximum or minimum) on the specified side</span>
<span class="sd">        of the input. However, the method will never taper more than half</span>
<span class="sd">        the full width of the `TimeSeries`, and will fail if there are no</span>
<span class="sd">        stationary points.</span>

<span class="sd">        See :func:`~gwpy.signal.window.planck` for the generic Planck taper</span>
<span class="sd">        window, and see :func:`scipy.signal.get_window` for other common</span>
<span class="sd">        window formats.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># check window properties</span>
        <span class="k">if</span> <span class="n">side</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;left&#39;</span><span class="p">,</span> <span class="s1">&#39;right&#39;</span><span class="p">,</span> <span class="s1">&#39;leftright&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;side must be one of &#39;left&#39;, &#39;right&#39;, &quot;</span>
                             <span class="s2">&quot;or &#39;leftright&#39;&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">duration</span><span class="p">:</span>
            <span class="n">nsamples</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">duration</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_rate</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s2">&quot;Hz&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># if a duration or number of samples is not specified, automatically</span>
        <span class="c1"># identify the second stationary point away from each boundary,</span>
        <span class="c1"># else default to half the TimeSeries width</span>
        <span class="n">nleft</span><span class="p">,</span> <span class="n">nright</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">nsamples</span><span class="p">:</span>
            <span class="n">mini</span><span class="p">,</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">argrelmin</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
            <span class="n">maxi</span><span class="p">,</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">argrelmax</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;left&#39;</span> <span class="ow">in</span> <span class="n">side</span><span class="p">:</span>
            <span class="n">nleft</span> <span class="o">=</span> <span class="n">nsamples</span> <span class="ow">or</span> <span class="nb">max</span><span class="p">(</span><span class="n">mini</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">maxi</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">nleft</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">nleft</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>
        <span class="k">if</span> <span class="s1">&#39;right&#39;</span> <span class="ow">in</span> <span class="n">side</span><span class="p">:</span>
            <span class="n">nright</span> <span class="o">=</span> <span class="n">nsamples</span> <span class="ow">or</span> <span class="n">out</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="nb">min</span><span class="p">(</span><span class="n">mini</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">maxi</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">nright</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">nright</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>
        <span class="n">out</span> <span class="o">*=</span> <span class="n">planck</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">nleft</span><span class="o">=</span><span class="n">nleft</span><span class="p">,</span> <span class="n">nright</span><span class="o">=</span><span class="n">nright</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="TimeSeries.whiten">
<a class="viewcode-back" href="../../../web/ja/reference/api/timeseries.html#gwexpy.timeseries.TimeSeries.whiten">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">whiten</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fftlength</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">overlap</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">DEFAULT_FFT_METHOD</span><span class="p">,</span>
               <span class="n">window</span><span class="o">=</span><span class="s1">&#39;hann&#39;</span><span class="p">,</span> <span class="n">detrend</span><span class="o">=</span><span class="s1">&#39;constant&#39;</span><span class="p">,</span> <span class="n">asd</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">fduration</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">highpass</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Whiten this `TimeSeries` using inverse spectrum truncation</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fftlength : `float`, optional</span>
<span class="sd">            FFT integration length (in seconds) for ASD estimation,</span>
<span class="sd">            default: choose based on sample rate</span>

<span class="sd">        overlap : `float`, optional</span>
<span class="sd">            number of seconds of overlap between FFTs, defaults to the</span>
<span class="sd">            recommended overlap for the given window (if given), or 0</span>

<span class="sd">        method : `str`, optional</span>
<span class="sd">            FFT-averaging method (default: ``&#39;median&#39;``)</span>

<span class="sd">        window : `str`, `numpy.ndarray`, optional</span>
<span class="sd">            window function to apply to timeseries prior to FFT,</span>
<span class="sd">            default: ``&#39;hann&#39;``</span>
<span class="sd">            see :func:`scipy.signal.get_window` for details on acceptable</span>
<span class="sd">            formats</span>

<span class="sd">        detrend : `str`, optional</span>
<span class="sd">            type of detrending to do before FFT (see `~TimeSeries.detrend`</span>
<span class="sd">            for more details), default: ``&#39;constant&#39;``</span>

<span class="sd">        asd : `~gwpy.frequencyseries.FrequencySeries`, optional</span>
<span class="sd">            the amplitude spectral density using which to whiten the data,</span>
<span class="sd">            overrides other ASD arguments, default: `None`</span>

<span class="sd">        fduration : `float`, optional</span>
<span class="sd">            duration (in seconds) of the time-domain FIR whitening filter,</span>
<span class="sd">            must be no longer than `fftlength`, default: 2 seconds</span>

<span class="sd">        highpass : `float`, optional</span>
<span class="sd">            highpass corner frequency (in Hz) of the FIR whitening filter,</span>
<span class="sd">            default: `None`</span>

<span class="sd">        **kwargs</span>
<span class="sd">            other keyword arguments are passed to the `TimeSeries.asd`</span>
<span class="sd">            method to estimate the amplitude spectral density</span>
<span class="sd">            `FrequencySeries` of this `TimeSeries`</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : `TimeSeries`</span>
<span class="sd">            a whitened version of the input data with zero mean and unit</span>
<span class="sd">            variance</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        TimeSeries.asd</span>
<span class="sd">            for details on the ASD calculation</span>
<span class="sd">        TimeSeries.convolve</span>
<span class="sd">            for details on convolution with the overlap-save method</span>
<span class="sd">        gwpy.signal.filter_design.fir_from_transfer</span>
<span class="sd">            for FIR filter design through spectrum truncation</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The accepted ``method`` arguments are:</span>

<span class="sd">        - ``&#39;bartlett&#39;`` : a mean average of non-overlapping periodograms</span>
<span class="sd">        - ``&#39;median&#39;`` : a median average of overlapping periodograms</span>
<span class="sd">        - ``&#39;welch&#39;`` : a mean average of overlapping periodograms</span>

<span class="sd">        The ``window`` argument is used in ASD estimation, FIR filter design,</span>
<span class="sd">        and in preventing spectral leakage in the output.</span>

<span class="sd">        Due to filter settle-in, a segment of length ``0.5*fduration`` will be</span>
<span class="sd">        corrupted at the beginning and end of the output. See</span>
<span class="sd">        `~TimeSeries.convolve` for more details.</span>

<span class="sd">        The input is detrended and the output normalised such that, if the</span>
<span class="sd">        input is stationary and Gaussian, then the output will have zero mean</span>
<span class="sd">        and unit variance.</span>

<span class="sd">        For more on inverse spectrum truncation, see arXiv:gr-qc/0509116.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># compute the ASD</span>
        <span class="n">fftlength</span> <span class="o">=</span> <span class="n">fftlength</span> <span class="k">if</span> <span class="n">fftlength</span> <span class="k">else</span> <span class="n">_fft_length_default</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">asd</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">asd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">asd</span><span class="p">(</span><span class="n">fftlength</span><span class="p">,</span> <span class="n">overlap</span><span class="o">=</span><span class="n">overlap</span><span class="p">,</span>
                           <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">asd</span> <span class="o">=</span> <span class="n">asd</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">duration</span><span class="o">.</span><span class="n">decompose</span><span class="p">()</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="c1"># design whitening filter, with highpass if requested</span>
        <span class="n">ncorner</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">highpass</span> <span class="o">/</span> <span class="n">asd</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">decompose</span><span class="p">()</span><span class="o">.</span><span class="n">value</span><span class="p">)</span> <span class="k">if</span> <span class="n">highpass</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="n">ntaps</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">fduration</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_rate</span><span class="p">)</span><span class="o">.</span><span class="n">decompose</span><span class="p">()</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">window</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">window</span><span class="p">)</span>
            <span class="n">ntaps</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">window</span><span class="p">)</span>
        <span class="n">tdw</span> <span class="o">=</span> <span class="n">filter_design</span><span class="o">.</span><span class="n">fir_from_transfer</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">asd</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">ntaps</span><span class="o">=</span><span class="n">ntaps</span><span class="p">,</span>
                                              <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span> <span class="n">ncorner</span><span class="o">=</span><span class="n">ncorner</span><span class="p">)</span>
        <span class="c1"># condition the input data and apply the whitening filter</span>
        <span class="n">in_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">detrend</span><span class="p">(</span><span class="n">detrend</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">in_</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">tdw</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">in_</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">decompose</span><span class="p">()</span><span class="o">.</span><span class="n">value</span><span class="p">)</span></div>


<div class="viewcode-block" id="TimeSeries.find_gates">
<a class="viewcode-back" href="../../../web/ja/reference/api/timeseries.html#gwexpy.timeseries.TimeSeries.find_gates">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">find_gates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tzero</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">whiten</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                   <span class="n">threshold</span><span class="o">=</span><span class="mf">50.</span><span class="p">,</span> <span class="n">cluster_window</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="o">**</span><span class="n">whiten_kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Identify points that should be gates using a provided threshold</span>
<span class="sd">        and clustered within a provided time window.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tzero : `int`, optional</span>
<span class="sd">            half-width time duration (seconds) in which the timeseries is</span>
<span class="sd">            set to zero</span>

<span class="sd">        whiten : `bool`, optional</span>
<span class="sd">            if True, data will be whitened before gating points are discovered,</span>
<span class="sd">            use of this option is highly recommended</span>

<span class="sd">        threshold : `float`, optional</span>
<span class="sd">            amplitude threshold, if the data exceeds this value a gating window</span>
<span class="sd">            will be placed</span>

<span class="sd">        cluster_window : `float`, optional</span>
<span class="sd">            time duration (seconds) over which gating points will be clustered</span>

<span class="sd">        **whiten_kwargs</span>
<span class="sd">            other keyword arguments that will be passed to the</span>
<span class="sd">            `TimeSeries.whiten` method if it is being used when discovering</span>
<span class="sd">            gating points</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : `~gwpy.segments.SegmentList`</span>
<span class="sd">            a list of segments that should be gated based on the</span>
<span class="sd">            provided parameters</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        TimeSeries.gate</span>
<span class="sd">            for a method that applies the identified gates</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Find points to gate based on a threshold</span>
        <span class="n">sample</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_rate</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s1">&#39;Hz&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">value</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">whiten</span><span class="p">(</span><span class="o">**</span><span class="n">whiten_kwargs</span><span class="p">)</span> <span class="k">if</span> <span class="n">whiten</span> <span class="k">else</span> <span class="bp">self</span>
        <span class="n">window_samples</span> <span class="o">=</span> <span class="n">cluster_window</span> <span class="o">*</span> <span class="n">sample</span>
        <span class="n">gates</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">find_peaks</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">value</span><span class="p">),</span> <span class="n">height</span><span class="o">=</span><span class="n">threshold</span><span class="p">,</span>
                                  <span class="n">distance</span><span class="o">=</span><span class="n">window_samples</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># represent gates as time segments</span>
        <span class="k">return</span> <span class="n">SegmentList</span><span class="p">([</span><span class="n">Segment</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">t0</span><span class="o">.</span><span class="n">value</span> <span class="o">+</span> <span class="p">(</span><span class="n">k</span> <span class="o">/</span> <span class="n">sample</span><span class="p">)</span> <span class="o">-</span> <span class="n">tzero</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">t0</span><span class="o">.</span><span class="n">value</span> <span class="o">+</span> <span class="p">(</span><span class="n">k</span> <span class="o">/</span> <span class="n">sample</span><span class="p">)</span> <span class="o">+</span> <span class="n">tzero</span><span class="p">,</span>
        <span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">gates</span><span class="p">])</span><span class="o">.</span><span class="n">coalesce</span><span class="p">()</span></div>


<div class="viewcode-block" id="TimeSeries.gate">
<a class="viewcode-back" href="../../../web/ja/reference/api/timeseries.html#gwexpy.timeseries.TimeSeries.gate">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">gate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tzero</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">tpad</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">whiten</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
             <span class="n">threshold</span><span class="o">=</span><span class="mf">50.</span><span class="p">,</span> <span class="n">cluster_window</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="o">**</span><span class="n">whiten_kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Removes high amplitude peaks from data using inverse Planck window.</span>

<span class="sd">        Points will be discovered automatically using a provided threshold</span>
<span class="sd">        and clustered within a provided time window.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tzero : `int`, optional</span>
<span class="sd">            half-width time duration (seconds) in which the timeseries is</span>
<span class="sd">            set to zero</span>

<span class="sd">        tpad : `int`, optional</span>
<span class="sd">            half-width time duration (seconds) in which the Planck window</span>
<span class="sd">            is tapered</span>

<span class="sd">        whiten : `bool`, optional</span>
<span class="sd">            if True, data will be whitened before gating points are discovered,</span>
<span class="sd">            use of this option is highly recommended</span>

<span class="sd">        threshold : `float`, optional</span>
<span class="sd">            amplitude threshold, if the data exceeds this value a gating window</span>
<span class="sd">            will be placed</span>

<span class="sd">        cluster_window : `float`, optional</span>
<span class="sd">            time duration (seconds) over which gating points will be clustered</span>

<span class="sd">        **whiten_kwargs</span>
<span class="sd">            other keyword arguments that will be passed to the</span>
<span class="sd">            `TimeSeries.whiten` method if it is being used when discovering</span>
<span class="sd">            gating points</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : `~gwpy.timeseries.TimeSeries`</span>
<span class="sd">            a copy of the original `TimeSeries` that has had gating windows</span>
<span class="sd">            applied</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Read data into a `TimeSeries`</span>

<span class="sd">        &gt;&gt;&gt; from gwpy.timeseries import TimeSeries</span>
<span class="sd">        &gt;&gt;&gt; data = TimeSeries.fetch_open_data(&#39;H1&#39;, 1135148571, 1135148771)</span>

<span class="sd">        Apply gating using custom arguments</span>

<span class="sd">        &gt;&gt;&gt; gated = data.gate(tzero=1.0, tpad=1.0, threshold=10.0,</span>
<span class="sd">                              fftlength=4, overlap=2, method=&#39;median&#39;)</span>

<span class="sd">        Plot the original data and the gated data, whiten both for</span>
<span class="sd">        visualization purposes</span>

<span class="sd">        &gt;&gt;&gt; overlay = data.whiten(4,2,method=&#39;median&#39;).plot(dpi=150,</span>
<span class="sd">                                  label=&#39;Ungated&#39;, color=&#39;dodgerblue&#39;,</span>
<span class="sd">                                  zorder=2)</span>
<span class="sd">        &gt;&gt;&gt; ax = overlay.gca()</span>
<span class="sd">        &gt;&gt;&gt; ax.plot(gated.whiten(4,2,method=&#39;median&#39;), label=&#39;Gated&#39;,</span>
<span class="sd">                    color=&#39;orange&#39;, zorder=3)</span>
<span class="sd">        &gt;&gt;&gt; ax.set_xlim(1135148661, 1135148681)</span>
<span class="sd">        &gt;&gt;&gt; ax.legend()</span>
<span class="sd">        &gt;&gt;&gt; overlay.show()</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        TimeSeries.mask</span>
<span class="sd">            for the method that masks out unwanted data</span>
<span class="sd">        TimeSeries.find_gates</span>
<span class="sd">            for the method that identifies gating points</span>
<span class="sd">        TimeSeries.whiten</span>
<span class="sd">            for the whitening filter used to identify gating points</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">gates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_gates</span><span class="p">(</span><span class="n">tzero</span><span class="o">=</span><span class="n">tzero</span><span class="p">,</span> <span class="n">whiten</span><span class="o">=</span><span class="n">whiten</span><span class="p">,</span>
                                <span class="n">threshold</span><span class="o">=</span><span class="n">threshold</span><span class="p">,</span>
                                <span class="n">cluster_window</span><span class="o">=</span><span class="n">cluster_window</span><span class="p">,</span>
                                <span class="o">**</span><span class="n">whiten_kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">(</span><span class="n">deadtime</span><span class="o">=</span><span class="n">gates</span><span class="p">,</span> <span class="n">const</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">tpad</span><span class="o">=</span><span class="n">tpad</span><span class="p">)</span></div>


<div class="viewcode-block" id="TimeSeries.convolve">
<a class="viewcode-back" href="../../../web/ja/reference/api/timeseries.html#gwexpy.timeseries.TimeSeries.convolve">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">convolve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fir</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="s1">&#39;hann&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convolve this `TimeSeries` with an FIR filter using the</span>
<span class="sd">           overlap-save method</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fir : `numpy.ndarray`</span>
<span class="sd">            the time domain filter to convolve with</span>

<span class="sd">        window : `str`, optional</span>
<span class="sd">            window function to apply to boundaries, default: ``&#39;hann&#39;``</span>
<span class="sd">            see :func:`scipy.signal.get_window` for details on acceptable</span>
<span class="sd">            formats</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : `TimeSeries`</span>
<span class="sd">            the result of the convolution</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        scipy.signal.fftconvolve</span>
<span class="sd">            for details on the convolution scheme used here</span>
<span class="sd">        TimeSeries.filter</span>
<span class="sd">            for an alternative method designed for short filters</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The output `TimeSeries` is the same length and has the same timestamps</span>
<span class="sd">        as the input.</span>

<span class="sd">        Due to filter settle-in, a segment half the length of `fir` will be</span>
<span class="sd">        corrupted at the left and right boundaries. To prevent spectral leakage</span>
<span class="sd">        these segments will be windowed before convolving.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pad</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">fir</span><span class="o">.</span><span class="n">size</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>
        <span class="n">nfft</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mi">8</span><span class="o">*</span><span class="n">fir</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="c1"># condition the input data</span>
        <span class="n">in_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">window</span> <span class="o">=</span> <span class="n">get_window</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="n">fir</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="n">in_</span><span class="o">.</span><span class="n">value</span><span class="p">[:</span><span class="n">pad</span><span class="p">]</span> <span class="o">*=</span> <span class="n">window</span><span class="p">[:</span><span class="n">pad</span><span class="p">]</span>
        <span class="n">in_</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="o">-</span><span class="n">pad</span><span class="p">:]</span> <span class="o">*=</span> <span class="n">window</span><span class="p">[</span><span class="o">-</span><span class="n">pad</span><span class="p">:]</span>
        <span class="c1"># if FFT length is long enough, perform only one convolution</span>
        <span class="k">if</span> <span class="n">nfft</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="o">/</span><span class="mi">2</span><span class="p">:</span>
            <span class="n">conv</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">fftconvolve</span><span class="p">(</span><span class="n">in_</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">fir</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;same&#39;</span><span class="p">)</span>
        <span class="c1"># else use the overlap-save algorithm</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nstep</span> <span class="o">=</span> <span class="n">nfft</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">pad</span>
            <span class="n">conv</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
            <span class="c1"># handle first chunk separately</span>
            <span class="n">conv</span><span class="p">[:</span><span class="n">nfft</span><span class="o">-</span><span class="n">pad</span><span class="p">]</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">fftconvolve</span><span class="p">(</span><span class="n">in_</span><span class="o">.</span><span class="n">value</span><span class="p">[:</span><span class="n">nfft</span><span class="p">],</span> <span class="n">fir</span><span class="p">,</span>
                                                 <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;same&#39;</span><span class="p">)[:</span><span class="n">nfft</span><span class="o">-</span><span class="n">pad</span><span class="p">]</span>
            <span class="c1"># process chunks of length nstep</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">nfft</span> <span class="o">-</span> <span class="n">pad</span>
            <span class="k">while</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="n">nfft</span> <span class="o">+</span> <span class="n">pad</span><span class="p">:</span>
                <span class="n">yk</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">fftconvolve</span><span class="p">(</span><span class="n">in_</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="n">pad</span><span class="p">:</span><span class="n">k</span><span class="o">+</span><span class="n">nstep</span><span class="o">+</span><span class="n">pad</span><span class="p">],</span> <span class="n">fir</span><span class="p">,</span>
                                        <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;same&#39;</span><span class="p">)</span>
                <span class="n">conv</span><span class="p">[</span><span class="n">k</span><span class="p">:</span><span class="n">k</span><span class="o">+</span><span class="n">yk</span><span class="o">.</span><span class="n">size</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">pad</span><span class="p">]</span> <span class="o">=</span> <span class="n">yk</span><span class="p">[</span><span class="n">pad</span><span class="p">:</span><span class="o">-</span><span class="n">pad</span><span class="p">]</span>
                <span class="n">k</span> <span class="o">+=</span> <span class="n">nstep</span>
            <span class="c1"># handle last chunk separately</span>
            <span class="n">conv</span><span class="p">[</span><span class="o">-</span><span class="n">nfft</span><span class="o">+</span><span class="n">pad</span><span class="p">:]</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">fftconvolve</span><span class="p">(</span><span class="n">in_</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="o">-</span><span class="n">nfft</span><span class="p">:],</span> <span class="n">fir</span><span class="p">,</span>
                                                  <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;same&#39;</span><span class="p">)[</span><span class="o">-</span><span class="n">nfft</span><span class="o">+</span><span class="n">pad</span><span class="p">:]</span>
        <span class="n">out</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="n">conv</span><span class="p">)</span>
        <span class="n">out</span><span class="o">.</span><span class="n">__array_finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="TimeSeries.correlate">
<a class="viewcode-back" href="../../../web/ja/reference/api/timeseries.html#gwexpy.timeseries.TimeSeries.correlate">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">correlate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mfilter</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="s1">&#39;hann&#39;</span><span class="p">,</span> <span class="n">detrend</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span>
                  <span class="n">whiten</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">wduration</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">highpass</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">asd_kw</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Cross-correlate this `TimeSeries` with another signal</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mfilter : `TimeSeries`</span>
<span class="sd">            the time domain signal to correlate with</span>

<span class="sd">        window : `str`, optional</span>
<span class="sd">            window function to apply to timeseries prior to FFT,</span>
<span class="sd">            default: ``&#39;hann&#39;``</span>
<span class="sd">            see :func:`scipy.signal.get_window` for details on acceptable</span>
<span class="sd">            formats</span>

<span class="sd">        detrend : `str`, optional</span>
<span class="sd">            type of detrending to do before FFT (see `~TimeSeries.detrend`</span>
<span class="sd">            for more details), default: ``&#39;linear&#39;``</span>

<span class="sd">        whiten : `bool`, optional</span>
<span class="sd">            boolean switch to enable (`True`) or disable (`False`) data</span>
<span class="sd">            whitening, default: `False`</span>

<span class="sd">        wduration : `float`, optional</span>
<span class="sd">            duration (in seconds) of the time-domain FIR whitening filter,</span>
<span class="sd">            only used if `whiten=True`, defaults to 2 seconds</span>

<span class="sd">        highpass : `float`, optional</span>
<span class="sd">            highpass corner frequency (in Hz) of the FIR whitening filter,</span>
<span class="sd">            only used if `whiten=True`, default: `None`</span>

<span class="sd">        **asd_kw</span>
<span class="sd">            keyword arguments to pass to `TimeSeries.asd` to generate</span>
<span class="sd">            an ASD, only used if `whiten=True`</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        snr : `TimeSeries`</span>
<span class="sd">            the correlated signal-to-noise ratio (SNR) timeseries</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        TimeSeries.asd</span>
<span class="sd">            for details on the ASD calculation</span>
<span class="sd">        TimeSeries.convolve</span>
<span class="sd">            for details on convolution with the overlap-save method</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The `window` argument is used in ASD estimation, whitening, and</span>
<span class="sd">        preventing spectral leakage in the output. It is not used to condition</span>
<span class="sd">        the matched-filter, which should be windowed before passing to this</span>
<span class="sd">        method.</span>

<span class="sd">        Due to filter settle-in, a segment half the length of `mfilter` will be</span>
<span class="sd">        corrupted at the beginning and end of the output. See</span>
<span class="sd">        `~TimeSeries.convolve` for more details.</span>

<span class="sd">        The input and matched-filter will be detrended, and the output will be</span>
<span class="sd">        normalised so that the SNR measures number of standard deviations from</span>
<span class="sd">        the expected mean.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_compatible</span><span class="p">(</span><span class="n">mfilter</span><span class="p">)</span>
        <span class="c1"># condition data</span>
        <span class="k">if</span> <span class="n">whiten</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">fftlength</span> <span class="o">=</span> <span class="n">asd_kw</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;fftlength&#39;</span><span class="p">,</span>
                                   <span class="n">_fft_length_default</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">))</span>
            <span class="n">overlap</span> <span class="o">=</span> <span class="n">asd_kw</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;overlap&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">overlap</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">overlap</span> <span class="o">=</span> <span class="n">recommended_overlap</span><span class="p">(</span><span class="n">window</span><span class="p">)</span> <span class="o">*</span> <span class="n">fftlength</span>
            <span class="n">asd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">asd</span><span class="p">(</span><span class="n">fftlength</span><span class="p">,</span> <span class="n">overlap</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span> <span class="o">**</span><span class="n">asd_kw</span><span class="p">)</span>
            <span class="c1"># pad the matched-filter to prevent corruption</span>
            <span class="n">npad</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">wduration</span> <span class="o">*</span> <span class="n">mfilter</span><span class="o">.</span><span class="n">sample_rate</span><span class="o">.</span><span class="n">decompose</span><span class="p">()</span><span class="o">.</span><span class="n">value</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">mfilter</span> <span class="o">=</span> <span class="n">mfilter</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">npad</span><span class="p">)</span>
            <span class="c1"># whiten (with errors on division by zero)</span>
            <span class="k">with</span> <span class="n">numpy</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="nb">all</span><span class="o">=</span><span class="s1">&#39;raise&#39;</span><span class="p">):</span>
                <span class="n">in_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">whiten</span><span class="p">(</span><span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span> <span class="n">fduration</span><span class="o">=</span><span class="n">wduration</span><span class="p">,</span> <span class="n">asd</span><span class="o">=</span><span class="n">asd</span><span class="p">,</span>
                                  <span class="n">highpass</span><span class="o">=</span><span class="n">highpass</span><span class="p">,</span> <span class="n">detrend</span><span class="o">=</span><span class="n">detrend</span><span class="p">)</span>
                <span class="n">mfilter</span> <span class="o">=</span> <span class="n">mfilter</span><span class="o">.</span><span class="n">whiten</span><span class="p">(</span><span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span> <span class="n">fduration</span><span class="o">=</span><span class="n">wduration</span><span class="p">,</span>
                                         <span class="n">asd</span><span class="o">=</span><span class="n">asd</span><span class="p">,</span> <span class="n">highpass</span><span class="o">=</span><span class="n">highpass</span><span class="p">,</span>
                                         <span class="n">detrend</span><span class="o">=</span><span class="n">detrend</span><span class="p">)[</span><span class="n">npad</span><span class="p">:</span><span class="o">-</span><span class="n">npad</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">in_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">detrend</span><span class="p">(</span><span class="n">detrend</span><span class="p">)</span>
            <span class="n">mfilter</span> <span class="o">=</span> <span class="n">mfilter</span><span class="o">.</span><span class="n">detrend</span><span class="p">(</span><span class="n">detrend</span><span class="p">)</span>
        <span class="c1"># compute matched-filter SNR and normalise</span>
        <span class="n">stdev</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">mfilter</span><span class="o">.</span><span class="n">value</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
        <span class="n">snr</span> <span class="o">=</span> <span class="n">in_</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">mfilter</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">)</span> <span class="o">/</span> <span class="n">stdev</span>
        <span class="n">snr</span><span class="o">.</span><span class="n">__array_finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">snr</span></div>


<div class="viewcode-block" id="TimeSeries.detrend">
<a class="viewcode-back" href="../../../web/ja/reference/api/timeseries.html#gwexpy.timeseries.TimeSeries.detrend">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">detrend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">detrend</span><span class="o">=</span><span class="s1">&#39;constant&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Remove the trend from this `TimeSeries`</span>

<span class="sd">        This method just wraps :func:`scipy.signal.detrend` to return</span>
<span class="sd">        an object of the same type as the input.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        detrend : `str`, optional</span>
<span class="sd">            the type of detrending.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        detrended : `TimeSeries`</span>
<span class="sd">            the detrended input series</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        scipy.signal.detrend</span>
<span class="sd">            for details on the options for the `detrend` argument, and</span>
<span class="sd">            how the operation is done</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">detrend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="n">detrend</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="n">data</span><span class="o">.</span><span class="n">__metadata_finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">data</span><span class="o">.</span><span class="n">_unit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span>
        <span class="k">return</span> <span class="n">data</span></div>


<div class="viewcode-block" id="TimeSeries.notch">
<a class="viewcode-back" href="../../../web/ja/reference/api/timeseries.html#gwexpy.timeseries.TimeSeries.notch">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">notch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">frequency</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;iir&#39;</span><span class="p">,</span> <span class="n">filtfilt</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Notch out a frequency in this `TimeSeries`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        frequency : `float`, `~astropy.units.Quantity`</span>
<span class="sd">            frequency (default in Hertz) at which to apply the notch</span>

<span class="sd">        type : `str`, optional</span>
<span class="sd">            type of filter to apply, currently only &#39;iir&#39; is supported</span>

<span class="sd">        **kwargs</span>
<span class="sd">            other keyword arguments to pass to `scipy.signal.iirdesign`</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        notched : `TimeSeries`</span>
<span class="sd">           a notch-filtered copy of the input `TimeSeries`</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        TimeSeries.filter</span>
<span class="sd">           for details on the filtering method</span>
<span class="sd">        scipy.signal.iirdesign</span>
<span class="sd">            for details on the IIR filter design method</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">zpk</span> <span class="o">=</span> <span class="n">filter_design</span><span class="o">.</span><span class="n">notch</span><span class="p">(</span><span class="n">frequency</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_rate</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
                                  <span class="nb">type</span><span class="o">=</span><span class="nb">type</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="o">*</span><span class="n">zpk</span><span class="p">,</span> <span class="n">filtfilt</span><span class="o">=</span><span class="n">filtfilt</span><span class="p">)</span></div>


<div class="viewcode-block" id="TimeSeries.q_gram">
<a class="viewcode-back" href="../../../web/ja/reference/api/timeseries.html#gwexpy.timeseries.TimeSeries.q_gram">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">q_gram</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
               <span class="n">qrange</span><span class="o">=</span><span class="n">qtransform</span><span class="o">.</span><span class="n">DEFAULT_QRANGE</span><span class="p">,</span>
               <span class="n">frange</span><span class="o">=</span><span class="n">qtransform</span><span class="o">.</span><span class="n">DEFAULT_FRANGE</span><span class="p">,</span>
               <span class="n">mismatch</span><span class="o">=</span><span class="n">qtransform</span><span class="o">.</span><span class="n">DEFAULT_MISMATCH</span><span class="p">,</span>
               <span class="n">snrthresh</span><span class="o">=</span><span class="mf">5.5</span><span class="p">,</span>
               <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Scan a `TimeSeries` using the multi-Q transform and return an</span>
<span class="sd">        `EventTable` of the most significant tiles</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        qrange : `tuple` of `float`, optional</span>
<span class="sd">            `(low, high)` range of Qs to scan</span>

<span class="sd">        frange : `tuple` of `float`, optional</span>
<span class="sd">            `(low, high)` range of frequencies to scan</span>

<span class="sd">        mismatch : `float`, optional</span>
<span class="sd">            maximum allowed fractional mismatch between neighbouring tiles</span>

<span class="sd">        snrthresh : `float`, optional</span>
<span class="sd">            lower inclusive threshold on individual tile SNR to keep in the</span>
<span class="sd">            table</span>

<span class="sd">        **kwargs</span>
<span class="sd">            other keyword arguments to be passed to :meth:`QTiling.transform`,</span>
<span class="sd">            including ``&#39;epoch&#39;`` and ``&#39;search&#39;``</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        qgram : `EventTable`</span>
<span class="sd">            a table of time-frequency tiles on the most significant `QPlane`</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        TimeSeries.q_transform</span>
<span class="sd">            for a method to interpolate the raw Q-transform over a regularly</span>
<span class="sd">            gridded spectrogram</span>
<span class="sd">        gwpy.signal.qtransform</span>
<span class="sd">            for code and documentation on how the Q-transform is implemented</span>
<span class="sd">        gwpy.table.EventTable.tile</span>
<span class="sd">            to render this `EventTable` as a collection of polygons</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Only tiles with signal energy greater than or equal to</span>
<span class="sd">        `snrthresh ** 2 / 2` will be stored in the output `EventTable`. The</span>
<span class="sd">        table columns are ``&#39;time&#39;``, ``&#39;duration&#39;``, ``&#39;frequency&#39;``,</span>
<span class="sd">        ``&#39;bandwidth&#39;``, and ``&#39;energy&#39;``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">qscan</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">qtransform</span><span class="o">.</span><span class="n">q_scan</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mismatch</span><span class="o">=</span><span class="n">mismatch</span><span class="p">,</span> <span class="n">qrange</span><span class="o">=</span><span class="n">qrange</span><span class="p">,</span>
                                     <span class="n">frange</span><span class="o">=</span><span class="n">frange</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">qgram</span> <span class="o">=</span> <span class="n">qscan</span><span class="o">.</span><span class="n">table</span><span class="p">(</span><span class="n">snrthresh</span><span class="o">=</span><span class="n">snrthresh</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">qgram</span></div>


<div class="viewcode-block" id="TimeSeries.q_transform">
<a class="viewcode-back" href="../../../web/ja/reference/api/timeseries.html#gwexpy.timeseries.TimeSeries.q_transform">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">q_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                    <span class="n">qrange</span><span class="o">=</span><span class="n">qtransform</span><span class="o">.</span><span class="n">DEFAULT_QRANGE</span><span class="p">,</span>
                    <span class="n">frange</span><span class="o">=</span><span class="n">qtransform</span><span class="o">.</span><span class="n">DEFAULT_FRANGE</span><span class="p">,</span>
                    <span class="n">gps</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">search</span><span class="o">=</span><span class="mf">.5</span><span class="p">,</span>
                    <span class="n">tres</span><span class="o">=</span><span class="s2">&quot;&lt;default&gt;&quot;</span><span class="p">,</span>
                    <span class="n">fres</span><span class="o">=</span><span class="s2">&quot;&lt;default&gt;&quot;</span><span class="p">,</span>
                    <span class="n">logf</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">norm</span><span class="o">=</span><span class="s1">&#39;median&#39;</span><span class="p">,</span>
                    <span class="n">mismatch</span><span class="o">=</span><span class="n">qtransform</span><span class="o">.</span><span class="n">DEFAULT_MISMATCH</span><span class="p">,</span>
                    <span class="n">outseg</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">whiten</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">fduration</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                    <span class="n">highpass</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="o">**</span><span class="n">asd_kw</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Scan a `TimeSeries` using the multi-Q transform and return an</span>
<span class="sd">        interpolated high-resolution spectrogram</span>

<span class="sd">        By default, this method returns a high-resolution spectrogram in</span>
<span class="sd">        both time and frequency, which can result in a large memory</span>
<span class="sd">        footprint. If you know that you only need a subset of the output</span>
<span class="sd">        for, say, a figure, consider using ``outseg`` and the other</span>
<span class="sd">        keyword arguments to restrict the size of the returned data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        qrange : `tuple` of `float`, optional</span>
<span class="sd">            `(low, high)` range of Qs to scan</span>

<span class="sd">        frange : `tuple` of `float`, optional</span>
<span class="sd">            `(log, high)` range of frequencies to scan</span>

<span class="sd">        gps : `float`, optional</span>
<span class="sd">            central time of interest for determine loudest Q-plane</span>

<span class="sd">        search : `float`, optional</span>
<span class="sd">            window around `gps` in which to find peak energies, only</span>
<span class="sd">            used if `gps` is given</span>

<span class="sd">        tres : `float`, optional</span>
<span class="sd">            desired time resolution (seconds) of output `Spectrogram`,</span>
<span class="sd">            default is `abs(outseg) / 1000.`</span>

<span class="sd">        fres : `float`, `int`, `None`, optional</span>
<span class="sd">            desired frequency resolution (Hertz) of output `Spectrogram`,</span>
<span class="sd">            or, if ``logf=True``, the number of frequency samples;</span>
<span class="sd">            give `None` to skip this step and return the original resolution,</span>
<span class="sd">            default is 0.5 Hz or 500 frequency samples</span>

<span class="sd">        logf : `bool`, optional</span>
<span class="sd">            boolean switch to enable (`True`) or disable (`False`) use of</span>
<span class="sd">            log-sampled frequencies in the output `Spectrogram`,</span>
<span class="sd">            if `True` then `fres` is interpreted as a number of frequency</span>
<span class="sd">            samples, default: `False`</span>

<span class="sd">        norm : `bool`, `str`, optional</span>
<span class="sd">            whether to normalize the returned Q-transform output, or how,</span>
<span class="sd">            default: `True` (``&#39;median&#39;``), other options: `False`,</span>
<span class="sd">            ``&#39;mean&#39;``</span>

<span class="sd">        mismatch : `float`</span>
<span class="sd">            maximum allowed fractional mismatch between neighbouring tiles</span>

<span class="sd">        outseg : `~gwpy.segments.Segment`, optional</span>
<span class="sd">            GPS `[start, stop)` segment for output `Spectrogram`,</span>
<span class="sd">            default is the full duration of the input</span>

<span class="sd">        whiten : `bool`, `~gwpy.frequencyseries.FrequencySeries`, optional</span>
<span class="sd">            boolean switch to enable (`True`) or disable (`False`) data</span>
<span class="sd">            whitening, or an ASD `~gwpy.freqencyseries.FrequencySeries`</span>
<span class="sd">            with which to whiten the data</span>

<span class="sd">        fduration : `float`, optional</span>
<span class="sd">            duration (in seconds) of the time-domain FIR whitening filter,</span>
<span class="sd">            only used if `whiten` is not `False`, defaults to 2 seconds</span>

<span class="sd">        highpass : `float`, optional</span>
<span class="sd">            highpass corner frequency (in Hz) of the FIR whitening filter,</span>
<span class="sd">            used only if `whiten` is not `False`, default: `None`</span>

<span class="sd">        **asd_kw</span>
<span class="sd">            keyword arguments to pass to `TimeSeries.asd` to generate</span>
<span class="sd">            an ASD to use when whitening the data</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : `~gwpy.spectrogram.Spectrogram`</span>
<span class="sd">            output `Spectrogram` of normalised Q energy</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        TimeSeries.asd</span>
<span class="sd">            for documentation on acceptable `**asd_kw`</span>
<span class="sd">        TimeSeries.whiten</span>
<span class="sd">            for documentation on how the whitening is done</span>
<span class="sd">        gwpy.signal.qtransform</span>
<span class="sd">            for code and documentation on how the Q-transform is implemented</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method will return a `Spectrogram` of dtype ``float32`` if</span>
<span class="sd">        ``norm`` is given, and ``float64`` otherwise.</span>

<span class="sd">        To optimize plot rendering with `~matplotlib.axes.Axes.pcolormesh`,</span>
<span class="sd">        the output `~gwpy.spectrogram.Spectrogram` can be given a log-sampled</span>
<span class="sd">        frequency axis by passing `logf=True` at runtime. The `fres` argument</span>
<span class="sd">        is then the number of points on the frequency axis. Note, this is</span>
<span class="sd">        incompatible with `~matplotlib.axes.Axes.imshow`.</span>

<span class="sd">        It is also highly recommended to use the `outseg` keyword argument</span>
<span class="sd">        when only a small window around a given GPS time is of interest. This</span>
<span class="sd">        will speed up this method a little, but can greatly speed up</span>
<span class="sd">        rendering the resulting `Spectrogram` using `pcolormesh`.</span>

<span class="sd">        If you aren&#39;t going to use `pcolormesh` in the end, don&#39;t worry.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from numpy.random import normal</span>
<span class="sd">        &gt;&gt;&gt; from scipy.signal import gausspulse</span>
<span class="sd">        &gt;&gt;&gt; from gwpy.timeseries import TimeSeries</span>

<span class="sd">        Generate a `TimeSeries` containing Gaussian noise sampled at 4096 Hz,</span>
<span class="sd">        centred on GPS time 0, with a sine-Gaussian pulse (&#39;glitch&#39;) at</span>
<span class="sd">        500 Hz:</span>

<span class="sd">        &gt;&gt;&gt; noise = TimeSeries(normal(loc=1, size=4096*4), sample_rate=4096, epoch=-2)</span>
<span class="sd">        &gt;&gt;&gt; glitch = TimeSeries(gausspulse(noise.times.value, fc=500) * 4, sample_rate=4096)</span>
<span class="sd">        &gt;&gt;&gt; data = noise + glitch</span>

<span class="sd">        Compute and plot the Q-transform of these data:</span>

<span class="sd">        &gt;&gt;&gt; q = data.q_transform()</span>
<span class="sd">        &gt;&gt;&gt; plot = q.plot()</span>
<span class="sd">        &gt;&gt;&gt; ax = plot.gca()</span>
<span class="sd">        &gt;&gt;&gt; ax.set_xlim(-.2, .2)</span>
<span class="sd">        &gt;&gt;&gt; ax.set_epoch(0)</span>
<span class="sd">        &gt;&gt;&gt; plot.show()</span>
<span class="sd">        &quot;&quot;&quot;</span>  <span class="c1"># noqa: E501</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">..frequencyseries</span><span class="w"> </span><span class="kn">import</span> <span class="n">FrequencySeries</span>
        <span class="c1"># condition data</span>
        <span class="k">if</span> <span class="n">whiten</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>  <span class="c1"># generate ASD dynamically</span>
            <span class="n">window</span> <span class="o">=</span> <span class="n">asd_kw</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;window&#39;</span><span class="p">,</span> <span class="s1">&#39;hann&#39;</span><span class="p">)</span>
            <span class="n">fftlength</span> <span class="o">=</span> <span class="n">asd_kw</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;fftlength&#39;</span><span class="p">,</span>
                                   <span class="n">_fft_length_default</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">))</span>
            <span class="n">overlap</span> <span class="o">=</span> <span class="n">asd_kw</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;overlap&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">overlap</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">fftlength</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">duration</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
                <span class="n">asd_kw</span><span class="p">[</span><span class="s1">&#39;method&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">DEFAULT_FFT_METHOD</span>
                <span class="n">overlap</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">elif</span> <span class="n">overlap</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">overlap</span> <span class="o">=</span> <span class="n">recommended_overlap</span><span class="p">(</span><span class="n">window</span><span class="p">)</span> <span class="o">*</span> <span class="n">fftlength</span>
            <span class="n">whiten</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">asd</span><span class="p">(</span><span class="n">fftlength</span><span class="p">,</span> <span class="n">overlap</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span> <span class="o">**</span><span class="n">asd_kw</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">whiten</span><span class="p">,</span> <span class="n">FrequencySeries</span><span class="p">):</span>
            <span class="c1"># apply whitening (with error on division by zero)</span>
            <span class="k">with</span> <span class="n">numpy</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="nb">all</span><span class="o">=</span><span class="s1">&#39;raise&#39;</span><span class="p">):</span>
                <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">whiten</span><span class="p">(</span><span class="n">asd</span><span class="o">=</span><span class="n">whiten</span><span class="p">,</span> <span class="n">fduration</span><span class="o">=</span><span class="n">fduration</span><span class="p">,</span>
                                   <span class="n">highpass</span><span class="o">=</span><span class="n">highpass</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="c1"># determine search window</span>
        <span class="k">if</span> <span class="n">gps</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">search</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="n">search</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">search</span> <span class="o">=</span> <span class="n">Segment</span><span class="p">(</span><span class="n">gps</span><span class="o">-</span><span class="n">search</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">gps</span><span class="o">+</span><span class="n">search</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="bp">self</span><span class="o">.</span><span class="n">span</span>
        <span class="n">qgram</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">qtransform</span><span class="o">.</span><span class="n">q_scan</span><span class="p">(</span>
            <span class="n">data</span><span class="p">,</span> <span class="n">frange</span><span class="o">=</span><span class="n">frange</span><span class="p">,</span> <span class="n">qrange</span><span class="o">=</span><span class="n">qrange</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">,</span>
            <span class="n">mismatch</span><span class="o">=</span><span class="n">mismatch</span><span class="p">,</span> <span class="n">search</span><span class="o">=</span><span class="n">search</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">qgram</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span>
            <span class="n">tres</span><span class="o">=</span><span class="n">tres</span><span class="p">,</span> <span class="n">fres</span><span class="o">=</span><span class="n">fres</span><span class="p">,</span> <span class="n">logf</span><span class="o">=</span><span class="n">logf</span><span class="p">,</span> <span class="n">outseg</span><span class="o">=</span><span class="n">outseg</span><span class="p">)</span></div>



<span class="nd">@as_series_dict_class</span><span class="p">(</span><span class="n">TimeSeries</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">TimeSeriesDict</span><span class="p">(</span><span class="n">TimeSeriesBaseDict</span><span class="p">):</span>  <span class="c1"># pylint: disable=missing-docstring</span>
    <span class="vm">__doc__</span> <span class="o">=</span> <span class="n">TimeSeriesBaseDict</span><span class="o">.</span><span class="vm">__doc__</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;TimeSeriesBase&#39;</span><span class="p">,</span>
                                                 <span class="s1">&#39;TimeSeries&#39;</span><span class="p">)</span>
    <span class="n">EntryClass</span> <span class="o">=</span> <span class="n">TimeSeries</span>


<span class="k">class</span><span class="w"> </span><span class="nc">TimeSeriesList</span><span class="p">(</span><span class="n">TimeSeriesBaseList</span><span class="p">):</span>  <span class="c1"># pylint: disable=missing-docstring</span>
    <span class="vm">__doc__</span> <span class="o">=</span> <span class="n">TimeSeriesBaseList</span><span class="o">.</span><span class="vm">__doc__</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;TimeSeriesBase&#39;</span><span class="p">,</span>
                                                 <span class="s1">&#39;TimeSeries&#39;</span><span class="p">)</span>
    <span class="n">EntryClass</span> <span class="o">=</span> <span class="n">TimeSeries</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2026, GWexpy contributors.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>