

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>gwexpy.analysis.bruco &mdash; gwexpy  documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=9edc463e" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=5929fcd5"></script>
      <script src="../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            gwexpy
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../web/en/index.html">GWExPy Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../web/ja/index.html">GWExPy ドキュメントへようこそ</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">gwexpy</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">gwexpy.analysis.bruco</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for gwexpy.analysis.bruco</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span><span class="w"> </span><span class="nn">__future__</span><span class="w"> </span><span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">html</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">logging</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">os</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">collections.abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">,</span> <span class="n">Sequence</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">concurrent.futures</span><span class="w"> </span><span class="kn">import</span> <span class="n">ProcessPoolExecutor</span><span class="p">,</span> <span class="n">as_completed</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">TypedDict</span><span class="p">,</span> <span class="n">Union</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">TypeAlias</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">typing_extensions</span><span class="w"> </span><span class="kn">import</span> <span class="n">TypeAlias</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">astropy</span><span class="w"> </span><span class="kn">import</span> <span class="n">units</span> <span class="k">as</span> <span class="n">u</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">gwpy.timeseries</span><span class="w"> </span><span class="kn">import</span> <span class="n">TimeSeries</span><span class="p">,</span> <span class="n">TimeSeriesDict</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.interpolate</span><span class="w"> </span><span class="kn">import</span> <span class="n">interp1d</span>

<span class="c1"># ロガーの設定</span>
<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>
<span class="n">_BRUCO_BLOCK_SIZE_DEFAULT</span> <span class="o">=</span> <span class="mi">256</span>
<span class="n">_BRUCO_BLOCK_BYTES_DEFAULT</span> <span class="o">=</span> <span class="mi">64</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span>
<span class="n">_BRUCO_BLOCK_SIZE_MIN</span> <span class="o">=</span> <span class="mi">16</span>
<span class="n">_BRUCO_BLOCK_SIZE_MAX</span> <span class="o">=</span> <span class="mi">1024</span>

<span class="n">BrucoMetadataValue</span><span class="p">:</span> <span class="n">TypeAlias</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]</span>
<span class="n">BrucoMetadata</span><span class="p">:</span> <span class="n">TypeAlias</span> <span class="o">=</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">BrucoMetadataValue</span><span class="p">]</span>


<span class="k">class</span><span class="w"> </span><span class="nc">BrucoPairSummary</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">):</span>
    <span class="n">channel</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">max_coherence</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">freq_at_max</span><span class="p">:</span> <span class="nb">float</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_auto_block_size</span><span class="p">(</span><span class="n">n_bins</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">top_n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">n_bins</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_BRUCO_BLOCK_SIZE_DEFAULT</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">budget</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getenv</span><span class="p">(</span><span class="s2">&quot;GWEXPY_BRUCO_BLOCK_BYTES&quot;</span><span class="p">,</span> <span class="n">_BRUCO_BLOCK_BYTES_DEFAULT</span><span class="p">))</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="n">budget</span> <span class="o">=</span> <span class="n">_BRUCO_BLOCK_BYTES_DEFAULT</span>
    <span class="k">if</span> <span class="n">budget</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">budget</span> <span class="o">=</span> <span class="n">_BRUCO_BLOCK_BYTES_DEFAULT</span>
    <span class="n">max_cols</span> <span class="o">=</span> <span class="p">(</span><span class="n">budget</span> <span class="o">//</span> <span class="p">(</span><span class="n">n_bins</span> <span class="o">*</span> <span class="mi">8</span><span class="p">))</span> <span class="o">-</span> <span class="n">top_n</span>
    <span class="k">if</span> <span class="n">max_cols</span> <span class="o">&lt;</span> <span class="n">_BRUCO_BLOCK_SIZE_MIN</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_BRUCO_BLOCK_SIZE_MIN</span>
    <span class="k">if</span> <span class="n">max_cols</span> <span class="o">&gt;</span> <span class="n">_BRUCO_BLOCK_SIZE_MAX</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_BRUCO_BLOCK_SIZE_MAX</span>
    <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">max_cols</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_resolve_block_size</span><span class="p">(</span><span class="n">block_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span> <span class="n">n_bins</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">top_n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">block_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">block_size</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getenv</span><span class="p">(</span><span class="s2">&quot;GWEXPY_BRUCO_BLOCK_SIZE&quot;</span><span class="p">,</span> <span class="n">_BRUCO_BLOCK_SIZE_DEFAULT</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">block_size</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">block_size</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;auto&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_auto_block_size</span><span class="p">(</span><span class="n">n_bins</span><span class="p">,</span> <span class="n">top_n</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">block_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">block_size</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;block_size must be an int or &#39;auto&#39;&quot;</span><span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">exc</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">block_size</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;block_size must be an int or &#39;auto&#39;&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">block_size</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;block_size must be &gt;= 1&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">block_size</span>


<span class="k">class</span><span class="w"> </span><span class="nc">FastCoherenceEngine</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Welch coherence engine that caches target FFT/PSD for reuse.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">target_data</span><span class="p">:</span> <span class="n">TimeSeries</span><span class="p">,</span> <span class="n">fftlength</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">overlap</span><span class="p">:</span> <span class="nb">float</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fftlength</span> <span class="o">=</span> <span class="n">fftlength</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">overlap</span> <span class="o">=</span> <span class="n">overlap</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sample_rate</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">target_data</span><span class="o">.</span><span class="n">sample_rate</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nperseg</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fftlength</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_rate</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nperseg</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;fftlength too small for sample rate&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">noverlap</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">overlap</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_rate</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">noverlap</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nperseg</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;overlap must be smaller than fftlength&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_window</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hanning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nperseg</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="c1"># Scaling factor to match scipy.signal.welch (scaling=&#39;density&#39;)</span>
        <span class="c1"># - 1/_window_power: Normalizae for window energy loss</span>
        <span class="c1"># - 2.0: Compensate for one-sided RFFT energy (excluding DC/Nyquist ideally,</span>
        <span class="c1">#        but 2.0 is the standard approximation for density scaling)</span>
        <span class="c1"># - 1/sample_rate: Convert to V^2/Hz (Power Spectral Density)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_window_power</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_window</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span> <span class="o">=</span> <span class="p">(</span>
            <span class="mf">2.0</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_rate</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_window_power</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_rate</span> <span class="o">&gt;</span> <span class="mi">0</span>
            <span class="k">else</span> <span class="mf">1.0</span>
        <span class="p">)</span>

        <span class="n">target_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">target_data</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_target_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_array</span><span class="p">)</span>
        <span class="n">segments</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_segment_array</span><span class="p">(</span><span class="n">target_array</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nperseg</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">noverlap</span><span class="p">)</span>
        <span class="n">windowed</span> <span class="o">=</span> <span class="n">segments</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_window</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_target_fft</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfft</span><span class="p">(</span><span class="n">windowed</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_target_psd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_target_fft</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">frequencies</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfftfreq</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nperseg</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mf">1.0</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_rate</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_segment_array</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">nperseg</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">noverlap</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="n">step</span> <span class="o">=</span> <span class="n">nperseg</span> <span class="o">-</span> <span class="n">noverlap</span>
        <span class="k">if</span> <span class="n">step</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;noverlap must be smaller than nperseg&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">nperseg</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;data length shorter than fftlength&quot;</span><span class="p">)</span>
        <span class="c1"># Ensure contiguous array to prevent undefined behavior with as_strided</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">nseg</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">-</span> <span class="n">nperseg</span><span class="p">)</span> <span class="o">//</span> <span class="n">step</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">nseg</span><span class="p">,</span> <span class="n">nperseg</span><span class="p">)</span>
        <span class="n">strides</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">strides</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">step</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">strides</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">lib</span><span class="o">.</span><span class="n">stride_tricks</span><span class="o">.</span><span class="n">as_strided</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">strides</span><span class="o">=</span><span class="n">strides</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">compute_coherence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">aux_data</span><span class="p">:</span> <span class="n">TimeSeries</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">aux_data</span><span class="o">.</span><span class="n">sample_rate</span><span class="o">.</span><span class="n">value</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_rate</span><span class="p">):</span>
            <span class="n">aux_data</span> <span class="o">=</span> <span class="n">aux_data</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_rate</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">Hz</span><span class="p">)</span>
        <span class="n">aux_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">aux_data</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">aux_array</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_target_len</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;aux data shorter than cached target length&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">aux_array</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_target_len</span><span class="p">:</span>
            <span class="n">aux_array</span> <span class="o">=</span> <span class="n">aux_array</span><span class="p">[:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_target_len</span><span class="p">]</span>

        <span class="n">segments</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_segment_array</span><span class="p">(</span><span class="n">aux_array</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nperseg</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">noverlap</span><span class="p">)</span>
        <span class="n">windowed</span> <span class="o">=</span> <span class="n">segments</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_window</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">aux_fft</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfft</span><span class="p">(</span><span class="n">windowed</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">aux_psd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">aux_fft</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span>

        <span class="n">csd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_target_fft</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">aux_fft</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span>
        <span class="n">denom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_target_psd</span> <span class="o">*</span> <span class="n">aux_psd</span>
        <span class="n">coherence</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">denom</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">valid</span> <span class="o">=</span> <span class="n">denom</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="n">coherence</span><span class="p">[</span><span class="n">valid</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">csd</span><span class="p">[</span><span class="n">valid</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">denom</span><span class="p">[</span><span class="n">valid</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">coherence</span>


<div class="viewcode-block" id="BrucoResult">
<a class="viewcode-back" href="../../../web/ja/reference/api/analysis.html#gwexpy.analysis.BrucoResult">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">BrucoResult</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Hold and analyze Bruco results with Top-N coherence per frequency bin.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">frequencies</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">target_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">target_spectrum</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">top_n</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
        <span class="n">metadata</span><span class="p">:</span> <span class="n">BrucoMetadata</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">block_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            frequencies: Frequency vector (Hz).</span>
<span class="sd">            target_name: Name of the target channel.</span>
<span class="sd">            target_spectrum: PSD of the target channel (same length as frequencies).</span>
<span class="sd">            top_n: Number of top channels to keep per frequency bin.</span>
<span class="sd">            metadata: Optional metadata dict for reporting.</span>
<span class="sd">            block_size: Channels per block in Top-N updates (int or &#39;auto&#39;).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">top_n</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;top_n must be &gt;= 1&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">frequencies</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_spectrum</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;frequencies and target_spectrum must have the same length&quot;</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">frequencies</span> <span class="o">=</span> <span class="n">frequencies</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target_name</span> <span class="o">=</span> <span class="n">target_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target_spectrum</span> <span class="o">=</span> <span class="n">target_spectrum</span>
        <span class="c1"># Internal calculations use PSD; ASD is derived only for display.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">top_n</span> <span class="o">=</span> <span class="n">top_n</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">BrucoMetadataValue</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="nb">dict</span><span class="p">(</span><span class="n">metadata</span><span class="p">)</span> <span class="k">if</span> <span class="n">metadata</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">{}</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_bins</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">frequencies</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">block_size</span> <span class="o">=</span> <span class="n">_resolve_block_size</span><span class="p">(</span><span class="n">block_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_bins</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">top_n</span><span class="p">)</span>

        <span class="c1"># Top-N storage: [n_bins, top_n]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">top_coherence</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n_bins</span><span class="p">,</span> <span class="n">top_n</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">top_channels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n_bins</span><span class="p">,</span> <span class="n">top_n</span><span class="p">),</span> <span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>

<div class="viewcode-block" id="BrucoResult.update_batch">
<a class="viewcode-back" href="../../../web/ja/reference/api/analysis.html#gwexpy.analysis.BrucoResult.update_batch">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">update_batch</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">channel_names</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">coherences</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update the Top-N records with a new batch of results.</span>

<span class="sd">        Args:</span>
<span class="sd">            channel_names: List of channel names in this batch.</span>
<span class="sd">            coherences: Coherence matrix of shape (n_channels, n_bins).</span>
<span class="sd">                        Must align to self.frequencies.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">channel_names</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="n">coherences</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;coherences must be a 2D array&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">coherences</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">channel_names</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;coherences rows must match channel_names length&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">coherences</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_bins</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;coherences columns must match number of frequency bins&quot;</span><span class="p">)</span>

        <span class="n">coh_clean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">coherences</span><span class="p">,</span> <span class="n">nan</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">posinf</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">neginf</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
        <span class="n">batch_names</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">channel_names</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>

        <span class="c1"># Blocked top-k update to cap memory while keeping vectorized selection.</span>
        <span class="n">block_size</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">batch_names</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_size</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">start</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">batch_names</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">block_size</span><span class="p">):</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">block_size</span>
            <span class="n">block_names</span> <span class="o">=</span> <span class="n">batch_names</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span>
            <span class="n">block_coh</span> <span class="o">=</span> <span class="n">coh_clean</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span>
            <span class="n">block_coh_t</span> <span class="o">=</span> <span class="n">block_coh</span><span class="o">.</span><span class="n">T</span>  <span class="c1"># (bins, n_block)</span>
            <span class="k">if</span> <span class="n">block_coh_t</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">open_slots</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">top_channels</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">block_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">block_coh_t</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">needs_update</span> <span class="o">=</span> <span class="n">open_slots</span> <span class="o">|</span> <span class="p">(</span><span class="n">block_max</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">top_coherence</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">needs_update</span><span class="p">):</span>
                <span class="k">continue</span>

            <span class="n">combined_coh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">top_coherence</span><span class="p">[</span><span class="n">needs_update</span><span class="p">],</span> <span class="n">block_coh_t</span><span class="p">[</span><span class="n">needs_update</span><span class="p">]],</span>
                <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">name_block</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span>
                <span class="n">block_names</span><span class="p">,</span> <span class="p">(</span><span class="n">combined_coh</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">block_names</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">combined_names</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">top_channels</span><span class="p">[</span><span class="n">needs_update</span><span class="p">],</span> <span class="n">name_block</span><span class="p">],</span>
                <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="n">row_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">combined_coh</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])[:,</span> <span class="kc">None</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">combined_coh</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">top_n</span><span class="p">:</span>
                <span class="n">sorted_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="o">-</span><span class="n">combined_coh</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">top_indices</span> <span class="o">=</span> <span class="n">sorted_indices</span><span class="p">[:,</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">top_n</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">partition_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argpartition</span><span class="p">(</span>
                    <span class="o">-</span><span class="n">combined_coh</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">top_n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
                <span class="p">)[:,</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">top_n</span><span class="p">]</span>
                <span class="n">partition_coh</span> <span class="o">=</span> <span class="n">combined_coh</span><span class="p">[</span><span class="n">row_indices</span><span class="p">,</span> <span class="n">partition_indices</span><span class="p">]</span>
                <span class="n">order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="o">-</span><span class="n">partition_coh</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">top_indices</span> <span class="o">=</span> <span class="n">partition_indices</span><span class="p">[</span><span class="n">row_indices</span><span class="p">,</span> <span class="n">order</span><span class="p">]</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">top_coherence</span><span class="p">[</span><span class="n">needs_update</span><span class="p">]</span> <span class="o">=</span> <span class="n">combined_coh</span><span class="p">[</span><span class="n">row_indices</span><span class="p">,</span> <span class="n">top_indices</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">top_channels</span><span class="p">[</span><span class="n">needs_update</span><span class="p">]</span> <span class="o">=</span> <span class="n">combined_names</span><span class="p">[</span><span class="n">row_indices</span><span class="p">,</span> <span class="n">top_indices</span><span class="p">]</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_apply_projection</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">spectrum</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">coherence</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">asd</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply coherence to PSD and optionally return ASD for display.&quot;&quot;&quot;</span>
        <span class="n">coh_safe</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">coherence</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">threshold</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">comparison_thresh</span> <span class="o">=</span> <span class="n">threshold</span><span class="o">**</span><span class="mi">2</span> <span class="k">if</span> <span class="n">asd</span> <span class="k">else</span> <span class="n">threshold</span>
            <span class="n">coh_safe</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">coh_safe</span> <span class="o">&lt;</span> <span class="n">comparison_thresh</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">coh_safe</span><span class="p">)</span>

        <span class="n">proj_psd</span> <span class="o">=</span> <span class="n">spectrum</span> <span class="o">*</span> <span class="n">coh_safe</span>
        <span class="k">if</span> <span class="n">asd</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">proj_psd</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">proj_psd</span>

<div class="viewcode-block" id="BrucoResult.get_noise_projection">
<a class="viewcode-back" href="../../../web/ja/reference/api/analysis.html#gwexpy.analysis.BrucoResult.get_noise_projection">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_noise_projection</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">rank</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">asd</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">coherence_threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate noise projection for the channel at a specific rank (0 = highest coherence).</span>

<span class="sd">        Args:</span>
<span class="sd">            asd: If True (default), return ASD projection. If False, return PSD projection.</span>
<span class="sd">            coherence_threshold: Frequencies with coherence below this value contribute zero noise.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (projection, coherence)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">rank</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">top_n</span> <span class="ow">or</span> <span class="n">rank</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Rank </span><span class="si">{</span><span class="n">rank</span><span class="si">}</span><span class="s2"> is out of range for top_n=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">top_n</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">coh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">top_coherence</span><span class="p">[:,</span> <span class="n">rank</span><span class="p">]</span>
        <span class="n">proj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_projection</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">target_spectrum</span><span class="p">,</span> <span class="n">coh</span><span class="p">,</span> <span class="n">asd</span><span class="o">=</span><span class="n">asd</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="n">coherence_threshold</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">proj</span><span class="p">,</span> <span class="n">coh</span></div>


<div class="viewcode-block" id="BrucoResult.projection_for_channel">
<a class="viewcode-back" href="../../../web/ja/reference/api/analysis.html#gwexpy.analysis.BrucoResult.projection_for_channel">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">projection_for_channel</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">channel</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">asd</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">coherence_threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate projection spectrum for a specific channel where it appears in Top-N.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">projection</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_bins</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">rank</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">top_n</span><span class="p">):</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">top_channels</span><span class="p">[:,</span> <span class="n">rank</span><span class="p">]</span> <span class="o">==</span> <span class="n">channel</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">mask</span><span class="p">):</span>
                <span class="n">projection</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_projection</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">target_spectrum</span><span class="p">[</span><span class="n">mask</span><span class="p">],</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">top_coherence</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span> <span class="n">rank</span><span class="p">],</span>
                    <span class="n">asd</span><span class="o">=</span><span class="n">asd</span><span class="p">,</span>
                    <span class="n">threshold</span><span class="o">=</span><span class="n">coherence_threshold</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="k">return</span> <span class="n">projection</span></div>


<div class="viewcode-block" id="BrucoResult.dominant_channel">
<a class="viewcode-back" href="../../../web/ja/reference/api/analysis.html#gwexpy.analysis.BrucoResult.dominant_channel">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">dominant_channel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rank</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the most frequent channel name at a given rank.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">rank</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">top_n</span> <span class="ow">or</span> <span class="n">rank</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Rank </span><span class="si">{</span><span class="n">rank</span><span class="si">}</span><span class="s2"> is out of range for top_n=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">top_n</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">channels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">top_channels</span><span class="p">[:,</span> <span class="n">rank</span><span class="p">]</span>
        <span class="n">channels</span> <span class="o">=</span> <span class="n">channels</span><span class="p">[</span><span class="n">channels</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">]</span>  <span class="c1"># noqa: E711</span>
        <span class="k">if</span> <span class="n">channels</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">values</span><span class="p">,</span> <span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">channels</span><span class="p">,</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">values</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">counts</span><span class="p">)]</span></div>


<div class="viewcode-block" id="BrucoResult.get_ranked_channels">
<a class="viewcode-back" href="../../../web/ja/reference/api/analysis.html#gwexpy.analysis.BrucoResult.get_ranked_channels">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_ranked_channels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">limit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get a list of channels ranked by their total coherence contribution.</span>

<span class="sd">        Args:</span>
<span class="sd">            limit: Maximum number of channels to return.</span>

<span class="sd">        Returns:</span>
<span class="sd">            List of channel names sorted by importance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">channel_scores</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">rank</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">top_n</span><span class="p">):</span>
            <span class="n">names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">top_channels</span><span class="p">[:,</span> <span class="n">rank</span><span class="p">]</span>
            <span class="n">cohs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">top_coherence</span><span class="p">[:,</span> <span class="n">rank</span><span class="p">]</span>
            <span class="c1"># Vectorized summation for this rank?</span>
            <span class="c1"># Channels are mixed in the column.</span>
            <span class="c1"># Iteration might be slow if bins are huge, but numpy unique is fast.</span>
            <span class="c1"># Let&#39;s iterate over unique names in this rank.</span>
            <span class="n">unique_names</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">names</span><span class="p">[</span><span class="n">names</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">])</span>  <span class="c1"># noqa: E711</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">unique_names</span><span class="p">:</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">names</span> <span class="o">==</span> <span class="n">name</span>
                <span class="n">score</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">cohs</span><span class="p">[</span><span class="n">mask</span><span class="p">])</span>
                <span class="n">channel_scores</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">channel_scores</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span> <span class="n">score</span><span class="p">)</span>

        <span class="n">sorted_channels</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span>
            <span class="n">channel_scores</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">name</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">score</span> <span class="ow">in</span> <span class="n">sorted_channels</span><span class="p">[:</span><span class="n">limit</span><span class="p">]]</span></div>


<div class="viewcode-block" id="BrucoResult.coherence_for_channel">
<a class="viewcode-back" href="../../../web/ja/reference/api/analysis.html#gwexpy.analysis.BrucoResult.coherence_for_channel">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">coherence_for_channel</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">channel</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">asd</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the coherence spectrum for a specific channel.</span>
<span class="sd">        Values are NaN where the channel is not in the Top-N.</span>

<span class="sd">        Args:</span>
<span class="sd">            channel: Channel name.</span>
<span class="sd">            asd: If True, return Amplitude Coherence. If False, Squared Coherence.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Coherence spectrum (same length as frequencies).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">coherence</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_bins</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">rank</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">top_n</span><span class="p">):</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">top_channels</span><span class="p">[:,</span> <span class="n">rank</span><span class="p">]</span> <span class="o">==</span> <span class="n">channel</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">mask</span><span class="p">):</span>
                <span class="n">coherence</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">top_coherence</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span> <span class="n">rank</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">asd</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">coherence</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">coherence</span></div>


<div class="viewcode-block" id="BrucoResult.to_dataframe">
<a class="viewcode-back" href="../../../web/ja/reference/api/analysis.html#gwexpy.analysis.BrucoResult.to_dataframe">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">to_dataframe</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">ranks</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">stride</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">asd</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">coherence_threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert results to a long-form DataFrame.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ranks</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ranks</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">top_n</span><span class="p">))</span>
        <span class="n">ranks</span> <span class="o">=</span> <span class="p">[</span><span class="n">r</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">ranks</span> <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">top_n</span><span class="p">]</span>
        <span class="n">stride</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">stride</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">frames</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">freqs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">frequencies</span><span class="p">[::</span><span class="n">stride</span><span class="p">]</span>

        <span class="n">spectrum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_spectrum</span><span class="p">[::</span><span class="n">stride</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">rank</span> <span class="ow">in</span> <span class="n">ranks</span><span class="p">:</span>
            <span class="n">coh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">top_coherence</span><span class="p">[::</span><span class="n">stride</span><span class="p">,</span> <span class="n">rank</span><span class="p">]</span>
            <span class="n">proj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_projection</span><span class="p">(</span>
                <span class="n">spectrum</span><span class="p">,</span> <span class="n">coh</span><span class="p">,</span> <span class="n">asd</span><span class="o">=</span><span class="n">asd</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="n">coherence_threshold</span>
            <span class="p">)</span>
            <span class="n">ch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">top_channels</span><span class="p">[::</span><span class="n">stride</span><span class="p">,</span> <span class="n">rank</span><span class="p">]</span>
            <span class="n">coh_display</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">coh</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span> <span class="k">if</span> <span class="n">asd</span> <span class="k">else</span> <span class="n">coh</span>
            <span class="n">frames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
                    <span class="p">{</span>
                        <span class="s2">&quot;frequency&quot;</span><span class="p">:</span> <span class="n">freqs</span><span class="p">,</span>
                        <span class="s2">&quot;rank&quot;</span><span class="p">:</span> <span class="n">rank</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                        <span class="s2">&quot;channel&quot;</span><span class="p">:</span> <span class="n">ch</span><span class="p">,</span>
                        <span class="s2">&quot;coherence&quot;</span><span class="p">:</span> <span class="n">coh_display</span><span class="p">,</span>
                        <span class="s2">&quot;projection&quot;</span><span class="p">:</span> <span class="n">proj</span><span class="p">,</span>
                    <span class="p">}</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">frames</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
                <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;frequency&quot;</span><span class="p">,</span> <span class="s2">&quot;rank&quot;</span><span class="p">,</span> <span class="s2">&quot;channel&quot;</span><span class="p">,</span> <span class="s2">&quot;coherence&quot;</span><span class="p">,</span> <span class="s2">&quot;projection&quot;</span><span class="p">]</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">frames</span><span class="p">,</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>


<div class="viewcode-block" id="BrucoResult.plot_projection">
<a class="viewcode-back" href="../../../web/ja/reference/api/analysis.html#gwexpy.analysis.BrucoResult.plot_projection">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">plot_projection</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">ranks</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">channels</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">max_channels</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
        <span class="n">asd</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">coherence_threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
        <span class="n">save_path</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">plt</span><span class="o">.</span><span class="n">Figure</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot target spectrum and noise projections for selected ranks or channels.</span>

<span class="sd">        Default behavior (ranks=None, channels=None):</span>
<span class="sd">            Plots the Top-K contributors (per-channel mode).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ranks</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">channels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">channels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_ranked_channels</span><span class="p">(</span><span class="n">max_channels</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">ranks</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ranks</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">ranks</span> <span class="o">=</span> <span class="p">[</span><span class="n">ranks</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">channels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">channels</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">channels</span> <span class="o">=</span> <span class="p">[</span><span class="n">channels</span><span class="p">]</span>

        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>

        <span class="n">target</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_spectrum</span>
        <span class="k">if</span> <span class="n">asd</span><span class="p">:</span>
            <span class="n">target</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">loglog</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">frequencies</span><span class="p">,</span>
            <span class="n">target</span><span class="p">,</span>
            <span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;Target: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">target_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="n">color</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">,</span>
            <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">ranks</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">rank</span> <span class="ow">in</span> <span class="n">ranks</span><span class="p">:</span>
                <span class="n">proj</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_noise_projection</span><span class="p">(</span>
                    <span class="n">rank</span><span class="p">,</span> <span class="n">asd</span><span class="o">=</span><span class="n">asd</span><span class="p">,</span> <span class="n">coherence_threshold</span><span class="o">=</span><span class="n">coherence_threshold</span>
                <span class="p">)</span>
                <span class="n">dominant</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dominant_channel</span><span class="p">(</span><span class="n">rank</span><span class="p">)</span>
                <span class="n">label</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Projection (Rank </span><span class="si">{</span><span class="n">rank</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">)&quot;</span>
                <span class="k">if</span> <span class="n">dominant</span><span class="p">:</span>
                    <span class="n">label</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">label</span><span class="si">}</span><span class="s2"> [Dom: </span><span class="si">{</span><span class="n">dominant</span><span class="si">}</span><span class="s2">]&quot;</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">loglog</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">frequencies</span><span class="p">,</span>
                    <span class="n">proj</span><span class="p">,</span>
                    <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">,</span>
                    <span class="n">alpha</span><span class="o">=</span><span class="mf">0.9</span><span class="p">,</span>
                    <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                    <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;.&quot;</span><span class="p">,</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="n">channels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="n">channels</span><span class="p">[:</span><span class="n">max_channels</span><span class="p">]:</span>
                <span class="n">proj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">projection_for_channel</span><span class="p">(</span>
                    <span class="n">channel</span><span class="p">,</span> <span class="n">asd</span><span class="o">=</span><span class="n">asd</span><span class="p">,</span> <span class="n">coherence_threshold</span><span class="o">=</span><span class="n">coherence_threshold</span>
                <span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">loglog</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">frequencies</span><span class="p">,</span>
                    <span class="n">proj</span><span class="p">,</span>
                    <span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;Projection: </span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="n">alpha</span><span class="o">=</span><span class="mf">0.9</span><span class="p">,</span>
                    <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                    <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;.&quot;</span><span class="p">,</span>
                <span class="p">)</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Frequency [Hz]&quot;</span><span class="p">)</span>
        <span class="n">ylabel</span> <span class="o">=</span> <span class="s2">&quot;ASD&quot;</span> <span class="k">if</span> <span class="n">asd</span> <span class="k">else</span> <span class="s2">&quot;PSD&quot;</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="n">ylabel</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Noise Projection: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">target_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s2">&quot;both&quot;</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s2">&quot;-&quot;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.4</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frequencies</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frequencies</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">frequencies</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">save_path</span><span class="p">:</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">save_path</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">fig</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fig</span></div>


<div class="viewcode-block" id="BrucoResult.plot_coherence">
<a class="viewcode-back" href="../../../web/ja/reference/api/analysis.html#gwexpy.analysis.BrucoResult.plot_coherence">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">plot_coherence</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">ranks</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">channels</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">max_channels</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
        <span class="n">asd</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">coherence_threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
        <span class="n">save_path</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">plt</span><span class="o">.</span><span class="n">Figure</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot coherence spectrum for selected ranks or channels.</span>

<span class="sd">        Default behavior (ranks=None, channels=None):</span>
<span class="sd">            Plots the Top-K contributors (per-channel mode).</span>

<span class="sd">        Args:</span>
<span class="sd">            asd: If True (default), plot Amplitude Coherence (sqrt(Coh^2)).</span>
<span class="sd">                 If False, plot Squared Coherence (Coh^2).</span>
<span class="sd">            coherence_threshold: Draw a horizontal line at this value (default 0.0=off).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ranks</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">channels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">channels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_ranked_channels</span><span class="p">(</span><span class="n">max_channels</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">ranks</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ranks</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">ranks</span> <span class="o">=</span> <span class="p">[</span><span class="n">ranks</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">channels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">channels</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">channels</span> <span class="o">=</span> <span class="p">[</span><span class="n">channels</span><span class="p">]</span>

        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">ranks</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">rank</span> <span class="ow">in</span> <span class="n">ranks</span><span class="p">:</span>
                <span class="n">coh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">top_coherence</span><span class="p">[:,</span> <span class="n">rank</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">asd</span><span class="p">:</span>
                    <span class="n">coh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">coh</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
                <span class="n">label</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Rank </span><span class="si">{</span><span class="n">rank</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">semilogx</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frequencies</span><span class="p">,</span> <span class="n">coh</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">channels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="n">channels</span><span class="p">:</span>
                <span class="n">coh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coherence_for_channel</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">asd</span><span class="o">=</span><span class="n">asd</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">semilogx</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">frequencies</span><span class="p">,</span> <span class="n">coh</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;Coherence: </span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.9</span>
                <span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Frequency [Hz]&quot;</span><span class="p">)</span>
        <span class="n">ylabel</span> <span class="o">=</span> <span class="s2">&quot;Coherence (Amplitude)&quot;</span> <span class="k">if</span> <span class="n">asd</span> <span class="k">else</span> <span class="s2">&quot;Coherence (Power)&quot;</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="n">ylabel</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.05</span><span class="p">)</span>

        <span class="c1"># Plot threshold line</span>
        <span class="k">if</span> <span class="n">coherence_threshold</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">axhline</span><span class="p">(</span>
                <span class="n">coherence_threshold</span><span class="p">,</span>
                <span class="n">color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span>
                <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;--&quot;</span><span class="p">,</span>
                <span class="n">linewidth</span><span class="o">=</span><span class="mf">1.5</span><span class="p">,</span>
                <span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;Threshold (</span><span class="si">{</span><span class="n">coherence_threshold</span><span class="si">:</span><span class="s2">.2g</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s2">&quot;both&quot;</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s2">&quot;-&quot;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.4</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frequencies</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frequencies</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">frequencies</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">save_path</span><span class="p">:</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">save_path</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">fig</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fig</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_coherence_color</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">value</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">))</span>
        <span class="n">red</span> <span class="o">=</span> <span class="mi">255</span>
        <span class="n">green</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mi">255</span> <span class="o">-</span> <span class="mi">160</span> <span class="o">*</span> <span class="n">value</span><span class="p">)</span>
        <span class="n">blue</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mi">255</span> <span class="o">-</span> <span class="mi">160</span> <span class="o">*</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;rgb(</span><span class="si">{</span><span class="n">red</span><span class="si">}</span><span class="s2">,</span><span class="si">{</span><span class="n">green</span><span class="si">}</span><span class="s2">,</span><span class="si">{</span><span class="n">blue</span><span class="si">}</span><span class="s2">)&quot;</span>

<div class="viewcode-block" id="BrucoResult.generate_report">
<a class="viewcode-back" href="../../../web/ja/reference/api/analysis.html#gwexpy.analysis.BrucoResult.generate_report">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">generate_report</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">output_dir</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">max_rows</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2000</span><span class="p">,</span>
        <span class="n">coherence_threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>
        <span class="n">plot_ranks</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
        <span class="n">asd</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate an HTML report with plots and data summary.</span>

<span class="sd">        Args:</span>
<span class="sd">            asd: If True (default), report and plots use ASD units.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Path to the generated HTML file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">proj_plot_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span> <span class="s2">&quot;projection.png&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plot_projection</span><span class="p">(</span>
            <span class="n">ranks</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">plot_ranks</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">top_n</span><span class="p">))),</span>
            <span class="n">asd</span><span class="o">=</span><span class="n">asd</span><span class="p">,</span>
            <span class="n">coherence_threshold</span><span class="o">=</span><span class="n">coherence_threshold</span><span class="p">,</span>
            <span class="n">save_path</span><span class="o">=</span><span class="n">proj_plot_path</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">coh_plot_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span> <span class="s2">&quot;coherence.png&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plot_coherence</span><span class="p">(</span>
            <span class="n">ranks</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">plot_ranks</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">top_n</span><span class="p">))),</span>
            <span class="n">asd</span><span class="o">=</span><span class="n">asd</span><span class="p">,</span>
            <span class="n">coherence_threshold</span><span class="o">=</span><span class="n">coherence_threshold</span><span class="p">,</span>
            <span class="n">save_path</span><span class="o">=</span><span class="n">coh_plot_path</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">stride</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_bins</span> <span class="o">/</span> <span class="n">max_rows</span><span class="p">)))</span> <span class="k">if</span> <span class="n">max_rows</span> <span class="k">else</span> <span class="mi">1</span>
        <span class="n">table_freqs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">frequencies</span><span class="p">[::</span><span class="n">stride</span><span class="p">]</span>
        <span class="n">table_channels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">top_channels</span><span class="p">[::</span><span class="n">stride</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">table_coherent_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">top_coherence</span><span class="p">[::</span><span class="n">stride</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

        <span class="n">table_proj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_projection</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">target_spectrum</span><span class="p">[::</span><span class="n">stride</span><span class="p">],</span>
            <span class="n">table_coherent_values</span><span class="p">,</span>
            <span class="n">asd</span><span class="o">=</span><span class="n">asd</span><span class="p">,</span>
            <span class="n">threshold</span><span class="o">=</span><span class="n">coherence_threshold</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">rows</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">freq</span><span class="p">,</span> <span class="n">ch</span><span class="p">,</span> <span class="n">coh</span><span class="p">,</span> <span class="n">proj</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
            <span class="n">table_freqs</span><span class="p">,</span> <span class="n">table_channels</span><span class="p">,</span> <span class="n">table_coherent_values</span><span class="p">,</span> <span class="n">table_proj</span>
        <span class="p">):</span>
            <span class="c1"># Display coherence value (amplitude or squared)</span>
            <span class="n">display_coh</span> <span class="o">=</span> <span class="n">coh</span>
            <span class="k">if</span> <span class="n">asd</span><span class="p">:</span>
                <span class="n">display_coh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">coh</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>

            <span class="n">color</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coherence_color</span><span class="p">(</span><span class="n">coh</span><span class="p">)</span>  <span class="c1"># Color logic uses Squared [0-1]</span>
            <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="s2">&quot;&lt;tr&gt;&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;&lt;td&gt;</span><span class="si">{</span><span class="n">freq</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">&lt;/td&gt;&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;&lt;td&gt;</span><span class="si">{</span><span class="n">html</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">ch</span><span class="p">))</span><span class="si">}</span><span class="s2">&lt;/td&gt;&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;&lt;td style=&#39;background-color:</span><span class="si">{</span><span class="n">color</span><span class="si">}</span><span class="s2">&#39;&gt;</span><span class="si">{</span><span class="n">display_coh</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">&lt;/td&gt;&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;&lt;td&gt;</span><span class="si">{</span><span class="n">proj</span><span class="si">:</span><span class="s2">.3e</span><span class="si">}</span><span class="s2">&lt;/td&gt;&quot;</span>
                <span class="s2">&quot;&lt;/tr&gt;&quot;</span>
            <span class="p">)</span>
        <span class="n">top_table_html</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;&lt;h3&gt;Top Channel per Frequency Bin (Rank 1)&lt;/h3&gt;&quot;</span>
            <span class="s2">&quot;&lt;table class=&#39;table&#39;&gt;&quot;</span>
            <span class="s2">&quot;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Frequency [Hz]&lt;/th&gt;&lt;th&gt;Channel&lt;/th&gt;&lt;th&gt;Coherence&lt;/th&gt;&lt;th&gt;Projection&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&quot;</span>
            <span class="s2">&quot;&lt;tbody&gt;&quot;</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;&lt;/tbody&gt;&lt;/table&gt;&quot;</span>
        <span class="p">)</span>

        <span class="n">thresh_coh</span> <span class="o">=</span> <span class="n">coherence_threshold</span><span class="o">**</span><span class="mi">2</span> <span class="k">if</span> <span class="n">asd</span> <span class="k">else</span> <span class="n">coherence_threshold</span>
        <span class="n">peak_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">top_coherence</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">thresh_coh</span>
        <span class="n">peak_freqs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">frequencies</span><span class="p">[</span><span class="n">peak_mask</span><span class="p">]</span>
        <span class="n">peak_ch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">top_channels</span><span class="p">[</span><span class="n">peak_mask</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">peak_coh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">top_coherence</span><span class="p">[</span><span class="n">peak_mask</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

        <span class="n">peak_coh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">top_coherence</span><span class="p">[</span><span class="n">peak_mask</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

        <span class="n">peak_proj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_projection</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">target_spectrum</span><span class="p">[</span><span class="n">peak_mask</span><span class="p">],</span>
            <span class="n">peak_coh</span><span class="p">,</span>
            <span class="n">asd</span><span class="o">=</span><span class="n">asd</span><span class="p">,</span>
            <span class="n">threshold</span><span class="o">=</span><span class="n">coherence_threshold</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">display_peak_coh</span> <span class="o">=</span> <span class="n">peak_coh</span>
        <span class="n">col_coh_name</span> <span class="o">=</span> <span class="s2">&quot;Coherence (Amplitude)&quot;</span> <span class="k">if</span> <span class="n">asd</span> <span class="k">else</span> <span class="s2">&quot;Coherence (Squared)&quot;</span>
        <span class="k">if</span> <span class="n">asd</span><span class="p">:</span>
            <span class="n">display_peak_coh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">peak_coh</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>

        <span class="n">peaks_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="p">{</span>
                <span class="s2">&quot;Frequency [Hz]&quot;</span><span class="p">:</span> <span class="n">peak_freqs</span><span class="p">,</span>
                <span class="s2">&quot;Channel&quot;</span><span class="p">:</span> <span class="n">peak_ch</span><span class="p">,</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">col_coh_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">:</span> <span class="n">display_peak_coh</span><span class="p">,</span>
                <span class="s2">&quot;Projection&quot;</span><span class="p">:</span> <span class="n">peak_proj</span><span class="p">,</span>
            <span class="p">}</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">peaks_df</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">200</span><span class="p">:</span>
            <span class="n">peaks_df</span> <span class="o">=</span> <span class="n">peaks_df</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">col_coh_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">head</span><span class="p">(</span>
                <span class="mi">200</span>
            <span class="p">)</span>
        <span class="n">peaks_html</span> <span class="o">=</span> <span class="s2">&quot;&lt;h3&gt;Significant Coherence Peaks&lt;/h3&gt;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">peaks_df</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">peaks_html</span> <span class="o">+=</span> <span class="n">peaks_df</span><span class="o">.</span><span class="n">to_html</span><span class="p">(</span><span class="n">classes</span><span class="o">=</span><span class="s2">&quot;table&quot;</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">peaks_html</span> <span class="o">+=</span> <span class="s2">&quot;&lt;p&gt;No peaks above threshold.&lt;/p&gt;&quot;</span>

        <span class="n">meta_rows</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">meta_rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;&lt;tr&gt;&lt;th&gt;</span><span class="si">{</span><span class="n">html</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">key</span><span class="p">))</span><span class="si">}</span><span class="s2">&lt;/th&gt;&lt;td&gt;</span><span class="si">{</span><span class="n">html</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">))</span><span class="si">}</span><span class="s2">&lt;/td&gt;&lt;/tr&gt;&quot;</span>
            <span class="p">)</span>
        <span class="n">meta_html</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">if</span> <span class="n">meta_rows</span><span class="p">:</span>
            <span class="n">meta_html</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;&lt;h3&gt;Run Summary&lt;/h3&gt;&quot;</span>
                <span class="s2">&quot;&lt;table class=&#39;table&#39;&gt;&quot;</span> <span class="o">+</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">meta_rows</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;&lt;/table&gt;&quot;</span>
            <span class="p">)</span>

        <span class="n">html_content</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;&lt;!DOCTYPE html&gt;</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;&lt;html&gt;</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;&lt;head&gt;</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;    &lt;title&gt;Bruco Report: </span><span class="si">{</span><span class="n">html</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">target_name</span><span class="p">)</span><span class="si">}</span><span class="s2">&lt;/title&gt;</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;    &lt;style&gt;</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;        body { font-family: sans-serif; margin: 20px; }</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;        img { max-width: 100%; border: 1px solid #ddd; margin-bottom: 20px; }</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;        .table { border-collapse: collapse; width: 100%; margin-bottom: 20px; }</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;        .table th, .table td { border: 1px solid #ddd; padding: 6px 8px; text-align: left; }</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;        .table th { background-color: #f2f2f2; }</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;    &lt;/style&gt;</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;&lt;/head&gt;</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;&lt;body&gt;</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;    &lt;h1&gt;Bruco Analysis Report&lt;/h1&gt;</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;    &lt;h2&gt;Target: </span><span class="si">{</span><span class="n">html</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">target_name</span><span class="p">)</span><span class="si">}</span><span class="s2">&lt;/h2&gt;</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;    </span><span class="si">{</span><span class="n">meta_html</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;    &lt;h3&gt;Noise Projection&lt;/h3&gt;</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s1">&#39;    &lt;img src=&quot;projection.png&quot; alt=&quot;Noise Projection Plot&quot;&gt;</span><span class="se">\n</span><span class="s1">&#39;</span>
            <span class="s2">&quot;    &lt;h3&gt;Coherence Spectra&lt;/h3&gt;</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s1">&#39;    &lt;img src=&quot;coherence.png&quot; alt=&quot;Coherence Plot&quot;&gt;</span><span class="se">\n</span><span class="s1">&#39;</span>
            <span class="sa">f</span><span class="s2">&quot;    </span><span class="si">{</span><span class="n">top_table_html</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;    </span><span class="si">{</span><span class="n">peaks_html</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;&lt;/body&gt;</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;&lt;/html&gt;&quot;</span>
        <span class="p">)</span>

        <span class="n">report_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span> <span class="s2">&quot;index.html&quot;</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">report_path</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">html_content</span><span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Report generated at </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">report_path</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">report_path</span></div>
</div>



<div class="viewcode-block" id="Bruco">
<a class="viewcode-back" href="../../../web/ja/reference/api/analysis.html#gwexpy.analysis.Bruco">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Bruco</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Brute force Coherence (Bruco) scanner.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        target (str): The name of the target channel (e.g., DARM).</span>
<span class="sd">        aux_channels (List[str]): List of auxiliary channels to scan.</span>
<span class="sd">        excluded (List[str]): List of channels to exclude from analysis.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">target_channel</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">aux_channels</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="n">excluded_channels</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the Bruco scanner.</span>

<span class="sd">        Args:</span>
<span class="sd">            target_channel (str): The main channel to analyze.</span>
<span class="sd">            aux_channels (List[str]): A list of all available auxiliary channels.</span>
<span class="sd">            excluded_channels (List[str], optional): Channels to ignore (e.g., calibration lines).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">target_channel</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">aux_channels</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">aux_channels</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">excluded</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">{</span><span class="nb">str</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">excluded_channels</span><span class="p">}</span> <span class="k">if</span> <span class="n">excluded_channels</span> <span class="k">else</span> <span class="nb">set</span><span class="p">()</span>
        <span class="p">)</span>

        <span class="c1"># Exclude target and excluded channels</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">channels_to_scan</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span>
            <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">aux_channels</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">excluded</span> <span class="o">-</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">})</span>
        <span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Bruco initialized. Target: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="si">}</span><span class="s2">, &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;Auxiliary channels: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channels_to_scan</span><span class="p">)</span><span class="si">}</span><span class="s2"> (after exclusions)&quot;</span>
        <span class="p">)</span>

<div class="viewcode-block" id="Bruco.compute">
<a class="viewcode-back" href="../../../web/ja/reference/api/analysis.html#gwexpy.analysis.Bruco.compute">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">start</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">duration</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">fftlength</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">2.0</span><span class="p">,</span>
        <span class="n">overlap</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="n">nproc</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
        <span class="n">batch_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
        <span class="n">top_n</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
        <span class="n">block_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">target_data</span><span class="p">:</span> <span class="n">TimeSeries</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">aux_data</span><span class="p">:</span> <span class="n">TimeSeriesDict</span> <span class="o">|</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">preprocess_batch</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">TimeSeriesDict</span><span class="p">],</span> <span class="n">TimeSeriesDict</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BrucoResult</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Execute the coherence scan.</span>

<span class="sd">        Args:</span>
<span class="sd">            start (int or float, optional): GPS start time. Required if not inferable from data.</span>
<span class="sd">            duration (int, optional): Duration of data in seconds. Required if not inferable.</span>
<span class="sd">            fftlength (float): FFT length in seconds.</span>
<span class="sd">            overlap (float): Overlap in seconds.</span>
<span class="sd">            nproc (int): Number of parallel processes.</span>
<span class="sd">            batch_size (int): Channels per batch.</span>
<span class="sd">            top_n (int): Number of top channels to keep per frequency bin.</span>
<span class="sd">            block_size (int or &#39;auto&#39;, optional): Channels per block in Top-N updates.</span>
<span class="sd">            target_data (TimeSeries, optional): Pre-loaded target channel data.</span>
<span class="sd">            aux_data (TimeSeriesDict or Iterable[TimeSeries], optional): Pre-loaded auxiliary channels data.</span>
<span class="sd">                         Can be a dictionary-like object or an iterable/generator yielding TimeSeries.</span>
<span class="sd">            preprocess_batch (Callable, optional): Batch preprocessing callback.</span>

<span class="sd">        Returns:</span>
<span class="sd">            BrucoResult: Object containing frequency-wise analysis results.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># --- 0. Infer start/duration if missing ---</span>
        <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">duration</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># 1. Infer from target_data</span>
            <span class="k">if</span> <span class="n">target_data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">start</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">target_data</span><span class="o">.</span><span class="n">t0</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">duration</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">duration</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">target_data</span><span class="o">.</span><span class="n">duration</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>
            <span class="c1"># 2. Infer from aux_data (only if dict-like)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">aux_data</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">):</span>
                <span class="c1"># Check if empty (keys/len)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">aux_data</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="c1"># Peek at first item</span>
                        <span class="c1"># TimeSeriesDict / Dict</span>
                        <span class="n">first_ts</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">aux_data</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>

                        <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">start</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">first_ts</span><span class="o">.</span><span class="n">t0</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">duration</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">duration</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">first_ts</span><span class="o">.</span><span class="n">duration</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>
                    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;Failed to infer start/duration from aux_data: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span>
                        <span class="p">)</span>
                        <span class="k">pass</span>  <span class="c1"># infer failed</span>

            <span class="c1"># Final check</span>
            <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">duration</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Arguments &#39;start&#39; and &#39;duration&#39; must be provided if they cannot be inferred from &#39;target_data&#39; or &#39;aux_data&#39; (Dict).&quot;</span>
                <span class="p">)</span>

        <span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">duration</span>
        <span class="k">if</span> <span class="n">fftlength</span> <span class="o">&gt;</span> <span class="n">duration</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;fftlength (</span><span class="si">{</span><span class="n">fftlength</span><span class="si">}</span><span class="s2">) cannot be longer than duration (</span><span class="si">{</span><span class="n">duration</span><span class="si">}</span><span class="s2">).&quot;</span>
            <span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Starting Bruco scan at </span><span class="si">{</span><span class="n">start</span><span class="si">}</span><span class="s2"> for </span><span class="si">{</span><span class="n">duration</span><span class="si">}</span><span class="s2">s. Batch size: </span><span class="si">{</span><span class="n">batch_size</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

        <span class="c1"># 1. Prepare Target Data &amp; Calculate Reference Spectrum</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">target_data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Using provided target data.&quot;</span><span class="p">)</span>
                <span class="n">target_ts</span> <span class="o">=</span> <span class="n">target_data</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Fetching target data: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">target_ts</span> <span class="o">=</span> <span class="n">TimeSeries</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>

            <span class="c1"># Calculate Target PSD reference (Internal storage is PSD)</span>
            <span class="n">target_spectrum</span> <span class="o">=</span> <span class="n">target_ts</span><span class="o">.</span><span class="n">psd</span><span class="p">(</span><span class="n">fftlength</span><span class="o">=</span><span class="n">fftlength</span><span class="p">,</span> <span class="n">overlap</span><span class="o">=</span><span class="n">overlap</span><span class="p">)</span>

            <span class="n">target_frequencies</span> <span class="o">=</span> <span class="n">target_spectrum</span><span class="o">.</span><span class="n">frequencies</span><span class="o">.</span><span class="n">value</span>
            <span class="n">target_spectrum_values</span> <span class="o">=</span> <span class="n">target_spectrum</span><span class="o">.</span><span class="n">value</span>

            <span class="c1"># Store Frequency resolution for alignment checks</span>
            <span class="n">df</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">fftlength</span>
            <span class="c1"># Verify df matches</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_frequencies</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">actual_df</span> <span class="o">=</span> <span class="n">target_frequencies</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">target_frequencies</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">actual_df</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">):</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Calculated df </span><span class="si">{</span><span class="n">df</span><span class="si">}</span><span class="s2"> does not match spectrum df </span><span class="si">{</span><span class="n">actual_df</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>

        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Failed to fetch or process target channel </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="k">raise</span> <span class="n">e</span>

        <span class="c1"># Initialize Result container</span>
        <span class="n">metadata</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;start&quot;</span><span class="p">:</span> <span class="n">start</span><span class="p">,</span>
            <span class="s2">&quot;end&quot;</span><span class="p">:</span> <span class="n">end</span><span class="p">,</span>
            <span class="s2">&quot;duration&quot;</span><span class="p">:</span> <span class="n">duration</span><span class="p">,</span>
            <span class="s2">&quot;fftlength&quot;</span><span class="p">:</span> <span class="n">fftlength</span><span class="p">,</span>
            <span class="s2">&quot;overlap&quot;</span><span class="p">:</span> <span class="n">overlap</span><span class="p">,</span>
            <span class="s2">&quot;top_n&quot;</span><span class="p">:</span> <span class="n">top_n</span><span class="p">,</span>
            <span class="s2">&quot;batch_size&quot;</span><span class="p">:</span> <span class="n">batch_size</span><span class="p">,</span>
            <span class="s2">&quot;nproc&quot;</span><span class="p">:</span> <span class="n">nproc</span><span class="p">,</span>
            <span class="s2">&quot;target&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">,</span>
            <span class="s2">&quot;target_sample_rate&quot;</span><span class="p">:</span> <span class="n">target_ts</span><span class="o">.</span><span class="n">sample_rate</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">BrucoResult</span><span class="p">(</span>
            <span class="n">target_frequencies</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">,</span>
            <span class="n">target_spectrum_values</span><span class="p">,</span>
            <span class="n">top_n</span><span class="o">=</span><span class="n">top_n</span><span class="p">,</span>
            <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">,</span>
            <span class="n">block_size</span><span class="o">=</span><span class="n">block_size</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># 2. Processing</span>

        <span class="c1"># Case A: Aux data provided</span>
        <span class="k">if</span> <span class="n">aux_data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Case A-1: Dictionary-like (Everything in memory)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">aux_data</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">):</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Using provided auxiliary data dict (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">aux_data</span><span class="p">)</span><span class="si">}</span><span class="s2"> channels).&quot;</span>
                <span class="p">)</span>
                <span class="n">all_aux_channels</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">aux_data</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
                <span class="n">total_channels</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_aux_channels</span><span class="p">)</span>

                <span class="c1"># Validation: check span overlap</span>
                <span class="c1"># Only check the first channel for performance? Or checks per batch?</span>
                <span class="c1"># User asked to error if span contradicts.</span>
                <span class="c1"># Let&#39;s check the first one if possible.</span>
                <span class="k">if</span> <span class="n">total_channels</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">first_ts</span> <span class="o">=</span> <span class="n">aux_data</span><span class="p">[</span><span class="n">all_aux_channels</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                    <span class="c1"># Simple check: does it cover start ~ end?</span>
                    <span class="c1"># allow small tolerance</span>
                    <span class="k">if</span> <span class="p">(</span>
                        <span class="n">first_ts</span><span class="o">.</span><span class="n">t0</span><span class="o">.</span><span class="n">value</span> <span class="o">&gt;</span> <span class="n">start</span> <span class="o">+</span> <span class="mf">0.1</span>
                        <span class="ow">or</span> <span class="p">(</span><span class="n">first_ts</span><span class="o">.</span><span class="n">t0</span><span class="o">.</span><span class="n">value</span> <span class="o">+</span> <span class="n">first_ts</span><span class="o">.</span><span class="n">duration</span><span class="o">.</span><span class="n">value</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">end</span> <span class="o">-</span> <span class="mf">0.1</span>
                    <span class="p">):</span>
                        <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;Aux data TimeSeries (t0=</span><span class="si">{</span><span class="n">first_ts</span><span class="o">.</span><span class="n">t0</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2">, dur=</span><span class="si">{</span><span class="n">first_ts</span><span class="o">.</span><span class="n">duration</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2">) &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;does not cover requested analysis span (start=</span><span class="si">{</span><span class="n">start</span><span class="si">}</span><span class="s2">, end=</span><span class="si">{</span><span class="n">end</span><span class="si">}</span><span class="s2">).&quot;</span>
                        <span class="p">)</span>
                        <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">total_channels</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">):</span>
                    <span class="n">batch_keys</span> <span class="o">=</span> <span class="n">all_aux_channels</span><span class="p">[</span><span class="n">i</span> <span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="n">batch_size</span><span class="p">]</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Processing data batch </span><span class="si">{</span><span class="n">i</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">batch_size</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="p">(</span><span class="n">total_channels</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">batch_size</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2"> &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">batch_keys</span><span class="p">)</span><span class="si">}</span><span class="s2"> channels)&quot;</span>
                    <span class="p">)</span>

                    <span class="c1"># Slice the dict</span>
                    <span class="n">batch_dict</span> <span class="o">=</span> <span class="n">TimeSeriesDict</span><span class="p">()</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">batch_keys</span><span class="p">:</span>
                        <span class="n">batch_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">aux_data</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>

                    <span class="c1"># Apply preprocessing if callback provided</span>
                    <span class="k">if</span> <span class="n">preprocess_batch</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">batch_dict</span> <span class="o">=</span> <span class="n">preprocess_batch</span><span class="p">(</span><span class="n">batch_dict</span><span class="p">)</span>
                        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                            <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Preprocessing failed for batch: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                            <span class="k">raise</span> <span class="n">e</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">_run_and_update_batch</span><span class="p">(</span>
                        <span class="n">result</span><span class="p">,</span>
                        <span class="n">target_ts</span><span class="p">,</span>
                        <span class="n">batch_dict</span><span class="p">,</span>
                        <span class="n">fftlength</span><span class="p">,</span>
                        <span class="n">overlap</span><span class="p">,</span>
                        <span class="n">nproc</span><span class="p">,</span>
                        <span class="n">target_frequencies</span><span class="p">,</span>
                    <span class="p">)</span>

            <span class="c1"># Case A-2: Iterable/Generator (Memory efficient streaming)</span>
            <span class="k">elif</span> <span class="n">aux_data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Using provided auxiliary data generator/iterable.&quot;</span><span class="p">)</span>
                <span class="n">batch_dict</span> <span class="o">=</span> <span class="n">TimeSeriesDict</span><span class="p">()</span>
                <span class="n">batch_count</span> <span class="o">=</span> <span class="mi">0</span>

                <span class="k">for</span> <span class="n">ts</span> <span class="ow">in</span> <span class="n">aux_data</span><span class="p">:</span>
                    <span class="c1"># Ensure it has a name, handle potential missing name if not TimeSeries</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">ts</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
                        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                            <span class="s2">&quot;Skipping unnamed TimeSeries in aux_data iterator.&quot;</span>
                        <span class="p">)</span>
                        <span class="k">continue</span>

                    <span class="c1"># Optional: Check span for streamed data?</span>
                    <span class="c1"># Might be computationally expensive to check every single one strictly,</span>
                    <span class="c1"># but valuable for safety.</span>
                    <span class="k">if</span> <span class="p">(</span>
                        <span class="n">ts</span><span class="o">.</span><span class="n">t0</span><span class="o">.</span><span class="n">value</span> <span class="o">&gt;</span> <span class="n">start</span> <span class="o">+</span> <span class="mf">0.1</span>
                        <span class="ow">or</span> <span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">t0</span><span class="o">.</span><span class="n">value</span> <span class="o">+</span> <span class="n">ts</span><span class="o">.</span><span class="n">duration</span><span class="o">.</span><span class="n">value</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">end</span> <span class="o">-</span> <span class="mf">0.1</span>
                    <span class="p">):</span>
                        <span class="c1"># We can skip or raise. User requested error/strictness.</span>
                        <span class="c1"># But for generator, maybe just skipping invalid ones is better?</span>
                        <span class="c1"># &quot;spanが矛盾する場合はエラー&quot; -&gt; Raise.</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;Streamed TimeSeries </span><span class="si">{</span><span class="n">ts</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> does not cover requested span.&quot;</span>
                        <span class="p">)</span>

                    <span class="n">batch_dict</span><span class="p">[</span><span class="n">ts</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">ts</span>

                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">batch_dict</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">batch_size</span><span class="p">:</span>
                        <span class="n">batch_count</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;Processing generator batch </span><span class="si">{</span><span class="n">batch_count</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">batch_dict</span><span class="p">)</span><span class="si">}</span><span class="s2"> channels)&quot;</span>
                        <span class="p">)</span>

                        <span class="bp">self</span><span class="o">.</span><span class="n">_run_and_update_batch</span><span class="p">(</span>
                            <span class="n">result</span><span class="p">,</span>
                            <span class="n">target_ts</span><span class="p">,</span>
                            <span class="n">batch_dict</span><span class="p">,</span>
                            <span class="n">fftlength</span><span class="p">,</span>
                            <span class="n">overlap</span><span class="p">,</span>
                            <span class="n">nproc</span><span class="p">,</span>
                            <span class="n">target_frequencies</span><span class="p">,</span>
                        <span class="p">)</span>
                        <span class="n">batch_dict</span> <span class="o">=</span> <span class="n">TimeSeriesDict</span><span class="p">()</span>  <span class="c1"># Clear memory</span>

                <span class="c1"># Process remaining</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">batch_dict</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">batch_count</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Processing generator batch </span><span class="si">{</span><span class="n">batch_count</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">batch_dict</span><span class="p">)</span><span class="si">}</span><span class="s2"> channels)&quot;</span>
                    <span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_run_and_update_batch</span><span class="p">(</span>
                        <span class="n">result</span><span class="p">,</span>
                        <span class="n">target_ts</span><span class="p">,</span>
                        <span class="n">batch_dict</span><span class="p">,</span>
                        <span class="n">fftlength</span><span class="p">,</span>
                        <span class="n">overlap</span><span class="p">,</span>
                        <span class="n">nproc</span><span class="p">,</span>
                        <span class="n">target_frequencies</span><span class="p">,</span>
                    <span class="p">)</span>

        <span class="c1"># Case B: Fetching Loop (Execute if channels_to_scan is not empty)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels_to_scan</span><span class="p">:</span>
            <span class="n">total_channels</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channels_to_scan</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Starting auto-fetch for </span><span class="si">{</span><span class="n">total_channels</span><span class="si">}</span><span class="s2"> channels configured in Bruco.&quot;</span>
            <span class="p">)</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">total_channels</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">):</span>
                <span class="n">batch_channels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels_to_scan</span><span class="p">[</span><span class="n">i</span> <span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="n">batch_size</span><span class="p">]</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Processing auto-fetch batch </span><span class="si">{</span><span class="n">i</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">batch_size</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="p">(</span><span class="n">total_channels</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">batch_size</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2"> &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">batch_channels</span><span class="p">)</span><span class="si">}</span><span class="s2"> channels)&quot;</span>
                <span class="p">)</span>

                <span class="c1"># Fetch batch data</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">batch_dict</span> <span class="o">=</span> <span class="n">TimeSeriesDict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                        <span class="n">batch_channels</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">allow_tape</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">nproc</span><span class="o">=</span><span class="n">nproc</span>
                    <span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Batch fetch failed: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">. Falling back to individual fetch.&quot;</span>
                    <span class="p">)</span>
                    <span class="n">batch_dict</span> <span class="o">=</span> <span class="n">TimeSeriesDict</span><span class="p">()</span>
                    <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">batch_channels</span><span class="p">:</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="c1"># Fetch individually</span>
                            <span class="n">batch_dict</span><span class="p">[</span><span class="n">ch</span><span class="p">]</span> <span class="o">=</span> <span class="n">TimeSeries</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                                <span class="n">ch</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">allow_tape</span><span class="o">=</span><span class="kc">True</span>
                            <span class="p">)</span>
                        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">ch_err</span><span class="p">:</span>
                            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                                <span class="sa">f</span><span class="s2">&quot;Failed to fetch individual channel </span><span class="si">{</span><span class="n">ch</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">ch_err</span><span class="si">}</span><span class="s2">&quot;</span>
                            <span class="p">)</span>

                    <span class="k">if</span> <span class="ow">not</span> <span class="n">batch_dict</span><span class="p">:</span>
                        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                            <span class="s2">&quot;No valid channels in this batch after fallback. Skipping.&quot;</span>
                        <span class="p">)</span>
                        <span class="k">continue</span>

                <span class="c1"># Apply preprocessing if callback provided</span>
                <span class="k">if</span> <span class="n">preprocess_batch</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">batch_dict</span> <span class="o">=</span> <span class="n">preprocess_batch</span><span class="p">(</span><span class="n">batch_dict</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                        <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Preprocessing failed for batch: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="k">raise</span> <span class="n">e</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">_run_and_update_batch</span><span class="p">(</span>
                    <span class="n">result</span><span class="p">,</span>
                    <span class="n">target_ts</span><span class="p">,</span>
                    <span class="n">batch_dict</span><span class="p">,</span>
                    <span class="n">fftlength</span><span class="p">,</span>
                    <span class="n">overlap</span><span class="p">,</span>
                    <span class="n">nproc</span><span class="p">,</span>
                    <span class="n">target_frequencies</span><span class="p">,</span>
                <span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Scan complete.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_run_and_update_batch</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">result</span><span class="p">:</span> <span class="n">BrucoResult</span><span class="p">,</span>
        <span class="n">target_ts</span><span class="p">:</span> <span class="n">TimeSeries</span><span class="p">,</span>
        <span class="n">aux_dict</span><span class="p">:</span> <span class="n">TimeSeriesDict</span><span class="p">,</span>
        <span class="n">fftlength</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">overlap</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">nproc</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">target_frequencies</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Calculate Coherence for batch</span>
        <span class="c1"># Returns list of (name, coherence_array)</span>
        <span class="n">batch_results_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_batch</span><span class="p">(</span>
            <span class="n">target_ts</span><span class="p">,</span>
            <span class="n">aux_dict</span><span class="p">,</span>
            <span class="n">fftlength</span><span class="p">,</span>
            <span class="n">overlap</span><span class="p">,</span>
            <span class="n">nproc</span><span class="p">,</span>
            <span class="n">target_frequencies</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Unpack results</span>
        <span class="n">valid_names</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">valid_coherences</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">res</span> <span class="ow">in</span> <span class="n">batch_results_list</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">res</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">name</span><span class="p">,</span> <span class="n">coh</span> <span class="o">=</span> <span class="n">res</span>
                <span class="n">valid_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                <span class="n">valid_coherences</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coh</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">valid_names</span><span class="p">:</span>
            <span class="c1"># Stack coherences -&gt; (n_channels, n_bins)</span>
            <span class="n">batch_coh_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">valid_coherences</span><span class="p">)</span>
            <span class="n">result</span><span class="o">.</span><span class="n">update_batch</span><span class="p">(</span><span class="n">valid_names</span><span class="p">,</span> <span class="n">batch_coh_matrix</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_process_batch</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">target_ts</span><span class="p">:</span> <span class="n">TimeSeries</span><span class="p">,</span>
        <span class="n">aux_dict</span><span class="p">:</span> <span class="n">TimeSeriesDict</span><span class="p">,</span>
        <span class="n">fftlength</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">overlap</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">nproc</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">target_frequencies</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper method to process a single batch.</span>
<span class="sd">        Passes target_frequencies to worker to ensure alignment.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">aux_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">aux_dict</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">aux_list</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">nproc</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_batch_coherence_fast</span><span class="p">(</span>
                <span class="n">target_ts</span><span class="p">,</span>
                <span class="n">aux_list</span><span class="p">,</span>
                <span class="n">fftlength</span><span class="p">,</span>
                <span class="n">overlap</span><span class="p">,</span>
                <span class="n">target_frequencies</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="n">chunk_size</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">aux_list</span><span class="p">)</span> <span class="o">/</span> <span class="n">nproc</span><span class="p">)))</span>
        <span class="n">results</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">with</span> <span class="n">ProcessPoolExecutor</span><span class="p">(</span><span class="n">max_workers</span><span class="o">=</span><span class="n">nproc</span><span class="p">)</span> <span class="k">as</span> <span class="n">executor</span><span class="p">:</span>
            <span class="n">futures</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">executor</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_batch_coherence_fast</span><span class="p">,</span>
                    <span class="n">target_ts</span><span class="p">,</span>
                    <span class="n">chunk</span><span class="p">,</span>
                    <span class="n">fftlength</span><span class="p">,</span>
                    <span class="n">overlap</span><span class="p">,</span>
                    <span class="n">target_frequencies</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">chunk</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_chunk_aux_list</span><span class="p">(</span><span class="n">aux_list</span><span class="p">,</span> <span class="n">chunk_size</span><span class="p">)</span>
            <span class="p">]</span>
            <span class="k">for</span> <span class="n">future</span> <span class="ow">in</span> <span class="n">as_completed</span><span class="p">(</span><span class="n">futures</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">results</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">future</span><span class="o">.</span><span class="n">result</span><span class="p">())</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Batch coherence failed: </span><span class="si">{</span><span class="n">exc</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">results</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_calculate_aligned_coherence</span><span class="p">(</span>
        <span class="n">target</span><span class="p">:</span> <span class="n">TimeSeries</span><span class="p">,</span>
        <span class="n">aux</span><span class="p">:</span> <span class="n">TimeSeries</span><span class="p">,</span>
        <span class="n">fftlength</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">overlap</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">target_frequencies</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Worker: Calculate coherence and align to target frequencies.</span>
<span class="sd">        Returns (channel_name, coherence_values_aligned).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Resampling logic</span>
            <span class="k">if</span> <span class="n">target</span><span class="o">.</span><span class="n">sample_rate</span> <span class="o">!=</span> <span class="n">aux</span><span class="o">.</span><span class="n">sample_rate</span><span class="p">:</span>
                <span class="n">sr_target</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">sample_rate</span><span class="o">.</span><span class="n">value</span>
                <span class="n">sr_aux</span> <span class="o">=</span> <span class="n">aux</span><span class="o">.</span><span class="n">sample_rate</span><span class="o">.</span><span class="n">value</span>
                <span class="n">common_rate</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">sr_target</span><span class="p">,</span> <span class="n">sr_aux</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">sr_target</span> <span class="o">&gt;</span> <span class="n">common_rate</span><span class="p">:</span>
                    <span class="n">target</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="n">common_rate</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">Hz</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">sr_aux</span> <span class="o">&gt;</span> <span class="n">common_rate</span><span class="p">:</span>
                    <span class="n">aux</span> <span class="o">=</span> <span class="n">aux</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="n">common_rate</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">Hz</span><span class="p">)</span>

            <span class="c1"># Crop length</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">target</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">aux</span><span class="p">):</span>
                <span class="n">min_len</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">target</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">aux</span><span class="p">))</span>
                <span class="n">target</span> <span class="o">=</span> <span class="n">target</span><span class="p">[:</span><span class="n">min_len</span><span class="p">]</span>
                <span class="n">aux</span> <span class="o">=</span> <span class="n">aux</span><span class="p">[:</span><span class="n">min_len</span><span class="p">]</span>

            <span class="c1"># Calculate Coherence</span>
            <span class="c1"># gwpy coherence returns a FrequencySeries</span>
            <span class="n">coh</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">coherence</span><span class="p">(</span><span class="n">aux</span><span class="p">,</span> <span class="n">fftlength</span><span class="o">=</span><span class="n">fftlength</span><span class="p">,</span> <span class="n">overlap</span><span class="o">=</span><span class="n">overlap</span><span class="p">)</span>
            <span class="n">coh_val</span> <span class="o">=</span> <span class="n">coh</span><span class="o">.</span><span class="n">value</span>
            <span class="n">coh_freqs</span> <span class="o">=</span> <span class="n">coh</span><span class="o">.</span><span class="n">frequencies</span><span class="o">.</span><span class="n">value</span>

            <span class="c1"># Align to target_frequencies</span>
            <span class="c1"># If sampling rates were identical, and params identical, they should match.</span>
            <span class="c1"># But if aux was downsampled, coh is shorter.</span>

            <span class="n">final_coh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">target_frequencies</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

            <span class="c1"># Case 1: Identical match (most common if same SR)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">coh_val</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_frequencies</span><span class="p">):</span>
                <span class="n">final_coh</span> <span class="o">=</span> <span class="n">coh_val</span>

            <span class="c1"># Case 2: Aux range is smaller (lower sampling rate)</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">coh_val</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_frequencies</span><span class="p">):</span>
                <span class="c1"># Assume starting at 0Hz and same df</span>
                <span class="c1"># Copy what we have</span>
                <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">coh_val</span><span class="p">)</span>
                <span class="n">final_coh</span><span class="p">[:</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">coh_val</span>
                <span class="c1"># Leave rest as 0</span>

            <span class="c1"># Case 3: Aux range is larger (higher sampling rate? Should not happen due to resample logic)</span>
            <span class="c1"># or frequency bins slightly off.</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Interpolate just to be safe, or slice if df matches</span>
                <span class="c1"># If df is same, slice.</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="nb">len</span><span class="p">(</span><span class="n">coh_freqs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span>
                    <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_frequencies</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span>
                    <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span>
                        <span class="n">coh_freqs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">coh_freqs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                        <span class="n">target_frequencies</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">target_frequencies</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                    <span class="p">)</span>
                <span class="p">):</span>
                    <span class="n">final_coh</span> <span class="o">=</span> <span class="n">coh_val</span><span class="p">[:</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_frequencies</span><span class="p">)]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Interpolate</span>
                    <span class="n">f</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">coh_freqs</span><span class="p">,</span> <span class="n">coh_val</span><span class="p">,</span> <span class="n">bounds_error</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
                    <span class="n">final_coh</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">target_frequencies</span><span class="p">)</span>

            <span class="k">return</span> <span class="p">(</span><span class="n">aux</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">final_coh</span><span class="p">)</span>

        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Coherence calculation failed for channel </span><span class="si">{</span><span class="nb">getattr</span><span class="p">(</span><span class="n">aux</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;name&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;unknown&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_chunk_aux_list</span><span class="p">(</span>
        <span class="n">aux_list</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">],</span>
        <span class="n">chunk_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">]]:</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">aux_list</span><span class="p">),</span> <span class="n">chunk_size</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">aux_list</span><span class="p">[</span><span class="n">idx</span> <span class="p">:</span> <span class="n">idx</span> <span class="o">+</span> <span class="n">chunk_size</span><span class="p">]</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_calculate_batch_coherence_fast</span><span class="p">(</span>
        <span class="n">target</span><span class="p">:</span> <span class="n">TimeSeries</span><span class="p">,</span>
        <span class="n">aux_list</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">TimeSeries</span><span class="p">],</span>
        <span class="n">fftlength</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">overlap</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">target_frequencies</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">]:</span>
        <span class="n">results</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">engine_cache</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">FastCoherenceEngine</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">target_cache</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">TimeSeries</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">aux</span> <span class="ow">in</span> <span class="n">aux_list</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">Bruco</span><span class="o">.</span><span class="n">_calculate_fast_coherence</span><span class="p">(</span>
                    <span class="n">target</span><span class="p">,</span>
                    <span class="n">aux</span><span class="p">,</span>
                    <span class="n">fftlength</span><span class="p">,</span>
                    <span class="n">overlap</span><span class="p">,</span>
                    <span class="n">target_frequencies</span><span class="p">,</span>
                    <span class="n">engine_cache</span><span class="p">,</span>
                    <span class="n">target_cache</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Calculation failed for </span><span class="si">{</span><span class="n">aux</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">exc</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">results</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_calculate_fast_coherence</span><span class="p">(</span>
        <span class="n">target</span><span class="p">:</span> <span class="n">TimeSeries</span><span class="p">,</span>
        <span class="n">aux</span><span class="p">:</span> <span class="n">TimeSeries</span><span class="p">,</span>
        <span class="n">fftlength</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">overlap</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">target_frequencies</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">engine_cache</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">FastCoherenceEngine</span><span class="p">],</span>
        <span class="n">target_cache</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">TimeSeries</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">sr_target</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="n">sample_rate</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
            <span class="n">sr_aux</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">aux</span><span class="o">.</span><span class="n">sample_rate</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">sr_target</span><span class="p">,</span> <span class="n">sr_aux</span><span class="p">):</span>
                <span class="n">common_rate</span> <span class="o">=</span> <span class="n">sr_target</span>
                <span class="n">target_rs</span> <span class="o">=</span> <span class="n">target</span>
                <span class="n">aux_rs</span> <span class="o">=</span> <span class="n">aux</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">common_rate</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">sr_target</span><span class="p">,</span> <span class="n">sr_aux</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">sr_target</span> <span class="o">&gt;</span> <span class="n">common_rate</span><span class="p">:</span>
                    <span class="n">target_rs</span> <span class="o">=</span> <span class="n">target_cache</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">common_rate</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">target_rs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">target_rs</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="n">common_rate</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">Hz</span><span class="p">)</span>
                        <span class="n">target_cache</span><span class="p">[</span><span class="n">common_rate</span><span class="p">]</span> <span class="o">=</span> <span class="n">target_rs</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">target_rs</span> <span class="o">=</span> <span class="n">target</span>

                <span class="k">if</span> <span class="n">sr_aux</span> <span class="o">&gt;</span> <span class="n">common_rate</span><span class="p">:</span>
                    <span class="n">aux_rs</span> <span class="o">=</span> <span class="n">aux</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="n">common_rate</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">Hz</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">aux_rs</span> <span class="o">=</span> <span class="n">aux</span>

            <span class="n">min_len</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">target_rs</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">aux_rs</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">min_len</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_rs</span><span class="p">)</span> <span class="o">!=</span> <span class="n">min_len</span><span class="p">:</span>
                <span class="n">target_rs</span> <span class="o">=</span> <span class="n">target_rs</span><span class="p">[:</span><span class="n">min_len</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">aux_rs</span><span class="p">)</span> <span class="o">!=</span> <span class="n">min_len</span><span class="p">:</span>
                <span class="n">aux_rs</span> <span class="o">=</span> <span class="n">aux_rs</span><span class="p">[:</span><span class="n">min_len</span><span class="p">]</span>

            <span class="n">cache_key</span> <span class="o">=</span> <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">common_rate</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">min_len</span><span class="p">))</span>
            <span class="n">engine</span> <span class="o">=</span> <span class="n">engine_cache</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">cache_key</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">engine</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">engine</span> <span class="o">=</span> <span class="n">FastCoherenceEngine</span><span class="p">(</span><span class="n">target_rs</span><span class="p">,</span> <span class="n">fftlength</span><span class="p">,</span> <span class="n">overlap</span><span class="p">)</span>
                <span class="n">engine_cache</span><span class="p">[</span><span class="n">cache_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">engine</span>

            <span class="n">coh_val</span> <span class="o">=</span> <span class="n">engine</span><span class="o">.</span><span class="n">compute_coherence</span><span class="p">(</span><span class="n">aux_rs</span><span class="p">)</span>
            <span class="n">final_coh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">target_frequencies</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">coh_val</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_frequencies</span><span class="p">):</span>
                <span class="n">final_coh</span> <span class="o">=</span> <span class="n">coh_val</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">coh_val</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_frequencies</span><span class="p">):</span>
                <span class="n">final_coh</span><span class="p">[:</span> <span class="nb">len</span><span class="p">(</span><span class="n">coh_val</span><span class="p">)]</span> <span class="o">=</span> <span class="n">coh_val</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">engine_freqs</span> <span class="o">=</span> <span class="n">engine</span><span class="o">.</span><span class="n">frequencies</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="nb">len</span><span class="p">(</span><span class="n">engine_freqs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span>
                    <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_frequencies</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span>
                    <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span>
                        <span class="n">engine_freqs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">engine_freqs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                        <span class="n">target_frequencies</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">target_frequencies</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                    <span class="p">)</span>
                <span class="p">):</span>
                    <span class="n">final_coh</span> <span class="o">=</span> <span class="n">coh_val</span><span class="p">[:</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_frequencies</span><span class="p">)]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">interp</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span>
                        <span class="n">engine_freqs</span><span class="p">,</span> <span class="n">coh_val</span><span class="p">,</span> <span class="n">bounds_error</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mf">0.0</span>
                    <span class="p">)</span>
                    <span class="n">final_coh</span> <span class="o">=</span> <span class="n">interp</span><span class="p">(</span><span class="n">target_frequencies</span><span class="p">)</span>

            <span class="k">return</span> <span class="p">(</span><span class="n">aux</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">final_coh</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Coherence calculation (fast engine) failed for channel </span><span class="si">{</span><span class="nb">getattr</span><span class="p">(</span><span class="n">aux</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;name&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;unknown&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_calculate_pair_coherence</span><span class="p">(</span>
        <span class="n">target</span><span class="p">:</span> <span class="n">TimeSeries</span><span class="p">,</span>
        <span class="n">aux</span><span class="p">:</span> <span class="n">TimeSeries</span><span class="p">,</span>
        <span class="n">fftlength</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">overlap</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BrucoPairSummary</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convenience helper to summarize coherence for a single pair.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">coh</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">coherence</span><span class="p">(</span><span class="n">aux</span><span class="p">,</span> <span class="n">fftlength</span><span class="o">=</span><span class="n">fftlength</span><span class="p">,</span> <span class="n">overlap</span><span class="o">=</span><span class="n">overlap</span><span class="p">)</span>
        <span class="n">coh_val</span> <span class="o">=</span> <span class="n">coh</span><span class="o">.</span><span class="n">value</span>
        <span class="n">coh_freqs</span> <span class="o">=</span> <span class="n">coh</span><span class="o">.</span><span class="n">frequencies</span><span class="o">.</span><span class="n">value</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">coh_val</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;channel&quot;</span><span class="p">:</span> <span class="n">aux</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="s2">&quot;max_coherence&quot;</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span> <span class="s2">&quot;freq_at_max&quot;</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">}</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">coh_val</span><span class="p">))</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;channel&quot;</span><span class="p">:</span> <span class="n">aux</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
            <span class="s2">&quot;max_coherence&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">coh_val</span><span class="p">[</span><span class="n">idx</span><span class="p">]),</span>
            <span class="s2">&quot;freq_at_max&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">coh_freqs</span><span class="p">[</span><span class="n">idx</span><span class="p">]),</span>
        <span class="p">}</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2026, gwexpy contributors.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>