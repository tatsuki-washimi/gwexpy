

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>gwexpy.frequencyseries.bifrequencymap &mdash; GWexpy Documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=9edc463e" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=5929fcd5"></script>
      <script src="../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            GWexpy
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../web/en/index.html">GWexpy Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../web/ja/index.html">GWexpy ドキュメントへようこそ</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">GWexpy</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">gwexpy.frequencyseries.bifrequencymap</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for gwexpy.frequencyseries.bifrequencymap</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span><span class="w"> </span><span class="nn">__future__</span><span class="w"> </span><span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Any</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">astropy</span><span class="w"> </span><span class="kn">import</span> <span class="n">units</span> <span class="k">as</span> <span class="n">u</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">gwpy.frequencyseries</span><span class="w"> </span><span class="kn">import</span> <span class="n">FrequencySeries</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">gwpy.types</span><span class="w"> </span><span class="kn">import</span> <span class="n">Array2D</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.interpolate</span><span class="w"> </span><span class="kn">import</span> <span class="n">interp1d</span>


<div class="viewcode-block" id="BifrequencyMap">
<a class="viewcode-back" href="../../../web/ja/reference/api/frequencyseries.html#gwexpy.frequencyseries.BifrequencyMap">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">BifrequencyMap</span><span class="p">(</span><span class="n">Array2D</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;2つの異なる周波数軸を持つマップ（応答関数や相関行列）クラス。</span>

<span class="sd">    (行, 列) = (周波数2, 周波数1) としてデータを保持します。</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">frequency1</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;周波数軸 1 (X軸/Columns)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">xindex</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">frequency2</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;周波数軸 2 (Y軸/Rows)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">yindex</span>

<div class="viewcode-block" id="BifrequencyMap.from_points">
<a class="viewcode-back" href="../../../web/ja/reference/api/frequencyseries.html#gwexpy.frequencyseries.BifrequencyMap.from_points">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_points</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">f2</span><span class="p">,</span> <span class="n">f1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        データと2つの周波数軸からインスタンスを生成します。</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : array-like</span>
<span class="sd">            形状が (len(f2), len(f1)) の2次元配列</span>
<span class="sd">        f2 : array-like</span>
<span class="sd">            周波数軸 2（Y軸/行）</span>
<span class="sd">        f1 : array-like</span>
<span class="sd">            周波数軸 1（X軸/列）</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># 単位が付いていない場合はHzとみなす</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">f1</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">Quantity</span><span class="p">):</span>
            <span class="n">f1</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">Quantity</span><span class="p">(</span><span class="n">f1</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s2">&quot;Hz&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">f2</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">Quantity</span><span class="p">):</span>
            <span class="n">f2</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">Quantity</span><span class="p">(</span><span class="n">f2</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s2">&quot;Hz&quot;</span><span class="p">)</span>

        <span class="c1"># Array2Dは (y, x) の順で初期化されるため、それに合わせる</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">yindex</span><span class="o">=</span><span class="n">f2</span><span class="p">,</span> <span class="n">xindex</span><span class="o">=</span><span class="n">f1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="BifrequencyMap.propagate">
<a class="viewcode-back" href="../../../web/ja/reference/api/frequencyseries.html#gwexpy.frequencyseries.BifrequencyMap.propagate">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">propagate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_spectrum</span><span class="p">,</span> <span class="n">interpolate</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        入力スペクトルに応答関数を適用し、出力スペクトルを計算します。</span>

<span class="sd">        入力スペクトルの周波数軸がこのマップの軸1(xindex)と異なる場合、</span>
<span class="sd">        自動的に線形補間を行って合わせることができます。</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        input_spectrum : FrequencySeries</span>
<span class="sd">            入力となるノイズスペクトル。</span>
<span class="sd">        interpolate : bool, optional</span>
<span class="sd">            Trueの場合、入力スペクトルの周波数軸をマップの軸1に合わせて補間します。</span>
<span class="sd">            Falseの場合、サイズが一致していないとエラーになります。デフォルトは True。</span>
<span class="sd">        fill_value : float, optional</span>
<span class="sd">            補間時に範囲外となった場合の埋め込み値。デフォルトは 0。</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        FrequencySeries</span>
<span class="sd">            軸2(frequency2)を持つ計算結果。</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># 入力データの検証</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">input_spectrum</span><span class="p">,</span> <span class="n">FrequencySeries</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;input_spectrum must be a gwpy.frequencyseries.FrequencySeries&quot;</span>
            <span class="p">)</span>

        <span class="c1"># 演算用の入力データ配列</span>
        <span class="n">in_val</span> <span class="o">=</span> <span class="n">input_spectrum</span><span class="o">.</span><span class="n">value</span>
        <span class="n">in_freq</span> <span class="o">=</span> <span class="n">input_spectrum</span><span class="o">.</span><span class="n">frequencies</span><span class="o">.</span><span class="n">value</span>
        <span class="n">map_in_freq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">frequency1</span><span class="o">.</span><span class="n">value</span>

        <span class="c1"># 周波数軸の整合性チェックと補間</span>
        <span class="k">if</span> <span class="n">interpolate</span><span class="p">:</span>
            <span class="c1"># 軸が完全に一致していない場合は補間を行う</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">in_freq</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">map_in_freq</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span>
                <span class="n">in_freq</span><span class="p">,</span> <span class="n">map_in_freq</span>
            <span class="p">):</span>
                <span class="c1"># 線形補間関数を作成</span>
                <span class="n">f</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span>
                    <span class="n">in_freq</span><span class="p">,</span>
                    <span class="n">in_val</span><span class="p">,</span>
                    <span class="n">kind</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span>
                    <span class="n">bounds_error</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="c1"># マップのX軸に合わせてリサンプリング</span>
                <span class="n">in_val</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">map_in_freq</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># 補間しない場合はサイズチェックのみ</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">in_val</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Input spectrum size </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">in_val</span><span class="p">)</span><span class="si">}</span><span class="s2"> does not match &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;map input size </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">. Enable `interpolate=True`.&quot;</span>
                <span class="p">)</span>

        <span class="c1"># 行列積の計算: (N_f2, N_f1) @ (N_f1,) -&gt; (N_f2,)</span>
        <span class="c1"># これにより、周波数1軸方向の成分が積算され、周波数2軸のデータになる</span>
        <span class="n">out_val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">@</span> <span class="n">in_val</span>

        <span class="c1"># 単位の計算</span>
        <span class="n">new_unit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span> <span class="o">*</span> <span class="n">input_spectrum</span><span class="o">.</span><span class="n">unit</span>

        <span class="c1"># 結果をFrequencySeriesとして返す（軸はマップのY軸=周波数2を使用）</span>
        <span class="k">return</span> <span class="n">FrequencySeries</span><span class="p">(</span>
            <span class="n">out_val</span><span class="p">,</span>
            <span class="n">frequencies</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">frequency2</span><span class="p">,</span>
            <span class="n">unit</span><span class="o">=</span><span class="n">new_unit</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;Projected: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> x </span><span class="si">{</span><span class="n">input_spectrum</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="BifrequencyMap.inverse">
<a class="viewcode-back" href="../../../web/ja/reference/api/frequencyseries.html#gwexpy.frequencyseries.BifrequencyMap.inverse">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rcond</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BifrequencyMap</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the (pseudo-)inverse of the BifrequencyMap.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        rcond : float or None</span>
<span class="sd">            Cutoff for small singular values. Same as `np.linalg.pinv`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        inv_map : BifrequencyMap</span>
<span class="sd">            New BifrequencyMap instance representing the inverse matrix.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">numpy.linalg</span><span class="w"> </span><span class="kn">import</span> <span class="n">pinv</span>

        <span class="k">if</span> <span class="n">rcond</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">inv_value</span> <span class="o">=</span> <span class="n">pinv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">inv_value</span> <span class="o">=</span> <span class="n">pinv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">rcond</span><span class="o">=</span><span class="n">rcond</span><span class="p">)</span>

        <span class="c1"># Determine new unit</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span> <span class="o">!=</span> <span class="n">u</span><span class="o">.</span><span class="n">dimensionless_unscaled</span><span class="p">:</span>
            <span class="n">new_unit</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_unit</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">dimensionless_unscaled</span>

        <span class="c1"># New axes:</span>
        <span class="c1"># The result of pinv(A) has shape (ncols, nrows) where A is (nrows, ncols).</span>
        <span class="c1"># Original: rows=frequency2, cols=frequency1</span>
        <span class="c1"># Inverse: rows=frequency1, cols=frequency2</span>
        <span class="c1"># So new f2 (Y) is old f1, new f1 (X) is old f2.</span>

        <span class="k">return</span> <span class="n">BifrequencyMap</span><span class="o">.</span><span class="n">from_points</span><span class="p">(</span>
            <span class="n">inv_value</span><span class="p">,</span>
            <span class="n">f2</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">frequency1</span><span class="p">,</span>
            <span class="n">f1</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">frequency2</span><span class="p">,</span>
            <span class="n">unit</span><span class="o">=</span><span class="n">new_unit</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;Inverse of </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="k">else</span> <span class="s2">&quot;Inverse&quot;</span><span class="p">,</span>
        <span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">prefix</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;&lt;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">(</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;    </span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">,</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;    unit=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="si">}</span><span class="s2">,</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;    name=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">!r}</span><span class="s2">,</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;    frequency2=[</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">frequency2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">, ..., </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">frequency2</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">],</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;    frequency1=[</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">frequency1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">, ..., </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">frequency1</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">]</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;)&gt;&quot;</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Format the array string (leveraging numpy/quantity formatting)</span>
        <span class="c1"># We use strict numpy array formatting to avoid huge outputs, similar to Series</span>
        <span class="n">arrobj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span>
        <span class="n">data_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">arrobj</span><span class="p">)</span>

        <span class="c1"># Indentation for metadata</span>
        <span class="n">indent</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Construct metadata strings</span>
        <span class="n">meta</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">meta</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;unit: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># F1/F2 info</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frequency1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">f1_str</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">frequency1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> .. </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">frequency1</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">f1_str</span> <span class="o">=</span> <span class="s2">&quot;empty&quot;</span>
        <span class="n">meta</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;freq1: </span><span class="si">{</span><span class="n">f1_str</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frequency2</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">f2_str</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">frequency2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> .. </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">frequency2</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">f2_str</span> <span class="o">=</span> <span class="s2">&quot;empty&quot;</span>
        <span class="n">meta</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;freq2: </span><span class="si">{</span><span class="n">f2_str</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">meta</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;name: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Join</span>
        <span class="n">meta_str</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;,</span><span class="se">\n</span><span class="si">{</span><span class="n">indent</span><span class="si">}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">meta</span><span class="p">)</span>

        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">(</span><span class="si">{</span><span class="n">data_str</span><span class="si">}</span><span class="se">\n</span><span class="si">{</span><span class="n">indent</span><span class="si">}{</span><span class="n">meta_str</span><span class="si">}</span><span class="s2">)&quot;</span>

<div class="viewcode-block" id="BifrequencyMap.plot">
<a class="viewcode-back" href="../../../web/ja/reference/api/frequencyseries.html#gwexpy.frequencyseries.BifrequencyMap.plot">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;imshow&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Plots the data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        method : str, optional</span>
<span class="sd">            &#39;imshow&#39; or &#39;pcolormesh&#39;. Default is &#39;imshow&#39;.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Keywork arguments passed to the plotting method or Plot constructor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">gwpy.plot</span><span class="w"> </span><span class="kn">import</span> <span class="n">Plot</span>

        <span class="c1"># Separate kwargs for Plot constructor and plotting method</span>
        <span class="n">plot_kwargs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;figsize&quot;</span><span class="p">,</span> <span class="s2">&quot;dpi&quot;</span><span class="p">,</span> <span class="s2">&quot;title&quot;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">plot_kwargs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

        <span class="k">if</span> <span class="s2">&quot;geometry&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">plot_kwargs</span><span class="p">[</span><span class="s2">&quot;geometry&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;geometry&quot;</span><span class="p">)</span>

        <span class="c1"># Background color for masked values (e.g. below vmin in LogNorm)</span>
        <span class="c1"># Default to &#39;gray&#39; as requested</span>
        <span class="n">background_color</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;background_color&quot;</span><span class="p">,</span> <span class="s2">&quot;gray&quot;</span><span class="p">)</span>

        <span class="c1"># Initialize Plot</span>
        <span class="n">plot</span> <span class="o">=</span> <span class="n">Plot</span><span class="p">(</span><span class="o">**</span><span class="n">plot_kwargs</span><span class="p">)</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">plot</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_facecolor</span><span class="p">(</span><span class="n">background_color</span><span class="p">)</span>

        <span class="c1"># Labels</span>
        <span class="n">xlabel</span> <span class="o">=</span> <span class="s2">&quot;Frequency 1&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frequency1</span><span class="p">,</span> <span class="s2">&quot;unit&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frequency1</span><span class="o">.</span><span class="n">unit</span><span class="p">)</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
            <span class="n">xlabel</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot; [</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">frequency1</span><span class="o">.</span><span class="n">unit</span><span class="si">}</span><span class="s2">]&quot;</span>

        <span class="n">ylabel</span> <span class="o">=</span> <span class="s2">&quot;Frequency 2&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frequency2</span><span class="p">,</span> <span class="s2">&quot;unit&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frequency2</span><span class="o">.</span><span class="n">unit</span><span class="p">)</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
            <span class="n">ylabel</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot; [</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">frequency2</span><span class="o">.</span><span class="n">unit</span><span class="si">}</span><span class="s2">]&quot;</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;xlabel&quot;</span><span class="p">,</span> <span class="n">xlabel</span><span class="p">))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;ylabel&quot;</span><span class="p">,</span> <span class="n">ylabel</span><span class="p">))</span>

        <span class="c1"># Scaling</span>
        <span class="k">if</span> <span class="s2">&quot;xscale&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_xscale</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;xscale&quot;</span><span class="p">))</span>
        <span class="k">if</span> <span class="s2">&quot;yscale&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_yscale</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;yscale&quot;</span><span class="p">))</span>

        <span class="c1"># Plotting</span>
        <span class="c1"># If norm is provided (e.g. LogNorm), pcolormesh is often more robust for sparse data/zeros</span>
        <span class="k">if</span> <span class="s2">&quot;norm&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="ow">and</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;imshow&quot;</span><span class="p">:</span>
            <span class="c1"># We can&#39;t easily know if user *explicitly* passed &#39;imshow&#39; vs default.</span>
            <span class="c1"># But let&#39;s assume if they want LogNorm on a map, pcolormesh is safer.</span>
            <span class="n">method</span> <span class="o">=</span> <span class="s2">&quot;pcolormesh&quot;</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;imshow&quot;</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;origin&quot;</span><span class="p">,</span> <span class="s2">&quot;lower&quot;</span><span class="p">)</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;aspect&quot;</span><span class="p">,</span> <span class="s2">&quot;auto&quot;</span><span class="p">)</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;interpolation&quot;</span><span class="p">,</span> <span class="s2">&quot;nearest&quot;</span><span class="p">)</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;cmap&quot;</span><span class="p">,</span> <span class="s2">&quot;inferno&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="s2">&quot;extent&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="c1"># Calculate extent [x0, x1, y0, y1]</span>
                <span class="n">x0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">frequency1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">value</span>
                <span class="n">x1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">frequency1</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">value</span>
                <span class="n">y0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">frequency2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">value</span>
                <span class="n">y1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">frequency2</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">value</span>

                <span class="c1"># Correct for pixel edges</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frequency1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">df1</span> <span class="o">=</span> <span class="p">(</span><span class="n">x1</span> <span class="o">-</span> <span class="n">x0</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frequency1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="n">extent_x</span> <span class="o">=</span> <span class="p">[</span><span class="n">x0</span> <span class="o">-</span> <span class="n">df1</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">x1</span> <span class="o">+</span> <span class="n">df1</span> <span class="o">/</span> <span class="mi">2</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">extent_x</span> <span class="o">=</span> <span class="p">[</span><span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">]</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frequency2</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">df2</span> <span class="o">=</span> <span class="p">(</span><span class="n">y1</span> <span class="o">-</span> <span class="n">y0</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frequency2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="n">extent_y</span> <span class="o">=</span> <span class="p">[</span><span class="n">y0</span> <span class="o">-</span> <span class="n">df2</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">y1</span> <span class="o">+</span> <span class="n">df2</span> <span class="o">/</span> <span class="mi">2</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">extent_y</span> <span class="o">=</span> <span class="p">[</span><span class="n">y0</span><span class="p">,</span> <span class="n">y1</span><span class="p">]</span>

                <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;extent&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">extent_x</span> <span class="o">+</span> <span class="n">extent_y</span>

            <span class="n">layer</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;pcolormesh&quot;</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;cmap&quot;</span><span class="p">,</span> <span class="s2">&quot;inferno&quot;</span><span class="p">)</span>
            <span class="c1"># pcolormesh expects bin edges or centers.</span>
            <span class="c1"># If we pass centers (frequency arrays), it infers edges.</span>
            <span class="c1"># However, for LogNorm, we must ensure values &lt;= 0 are masked.</span>

            <span class="c1"># Mask zeros/negative if LogNorm is used, to avoid warning/error or invisible output</span>
            <span class="k">if</span> <span class="s2">&quot;norm&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="kn">from</span><span class="w"> </span><span class="nn">matplotlib.colors</span><span class="w"> </span><span class="kn">import</span> <span class="n">LogNorm</span>

                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;norm&quot;</span><span class="p">],</span> <span class="n">LogNorm</span><span class="p">):</span>
                    <span class="c1"># Mask &lt;= 0</span>
                    <span class="n">val_to_plot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_less_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">val_to_plot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">val_to_plot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span>

            <span class="n">layer</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">frequency1</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">frequency2</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">val_to_plot</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown plot method: </span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Colorbar</span>
        <span class="c1"># Try to use unit</span>
        <span class="n">label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">:</span>
            <span class="n">label</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot; [</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="si">}</span><span class="s2">]&quot;</span>
        <span class="n">plot</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">plot</span></div>


<div class="viewcode-block" id="BifrequencyMap.get_slice">
<a class="viewcode-back" href="../../../web/ja/reference/api/frequencyseries.html#gwexpy.frequencyseries.BifrequencyMap.get_slice">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">at</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="s2">&quot;f1&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extract a 1D slice (FrequencySeries) at a specific frequency on one axis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        at : float or Quantity</span>
<span class="sd">            The frequency value to slice at.</span>
<span class="sd">        axis : str, optional</span>
<span class="sd">            The axis to slice along (&#39;f1&#39; or &#39;f2&#39;).</span>
<span class="sd">            &#39;f1&#39;: Fix f1=at, return spectrum along f2.</span>
<span class="sd">            &#39;f2&#39;: Fix f2=at, return spectrum along f1.</span>
<span class="sd">            Default is &#39;f1&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        FrequencySeries</span>
<span class="sd">            The extracted 1D spectrum.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Determine target axis and slice axis</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="s2">&quot;f1&quot;</span><span class="p">:</span>
            <span class="n">target_axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">frequency1</span><span class="o">.</span><span class="n">value</span>
            <span class="n">target_unit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">frequency1</span><span class="o">.</span><span class="n">unit</span>
            <span class="n">result_axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">frequency2</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="s2">&quot;f2&quot;</span><span class="p">:</span>
            <span class="n">target_axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">frequency2</span><span class="o">.</span><span class="n">value</span>
            <span class="n">target_unit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">frequency2</span><span class="o">.</span><span class="n">unit</span>
            <span class="n">result_axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">frequency1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;axis must be &#39;f1&#39; or &#39;f2&#39;&quot;</span><span class="p">)</span>

        <span class="c1"># Handle &#39;at&#39; input</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">at</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">Quantity</span><span class="p">):</span>
            <span class="c1"># Check units if possible?</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">at</span><span class="o">.</span><span class="n">value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">at</span>

        <span class="c1"># Find nearest index</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">target_axis</span> <span class="o">-</span> <span class="n">val</span><span class="p">)</span><span class="o">.</span><span class="n">argmin</span><span class="p">()</span>
        <span class="n">actual_val</span> <span class="o">=</span> <span class="n">target_axis</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

        <span class="c1"># Extract data</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="s2">&quot;f1&quot;</span><span class="p">:</span>
            <span class="c1"># f1 is columns (dim 1). Fix column idx.</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">[:,</span> <span class="n">idx</span><span class="p">]</span>
            <span class="n">name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> (at f1=</span><span class="si">{</span><span class="n">actual_val</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">target_unit</span><span class="si">}</span><span class="s2">)&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># f2 is rows (dim 0). Fix row idx.</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> (at f2=</span><span class="si">{</span><span class="n">actual_val</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">target_unit</span><span class="si">}</span><span class="s2">)&quot;</span>

        <span class="k">return</span> <span class="n">FrequencySeries</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">frequencies</span><span class="o">=</span><span class="n">result_axis</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span></div>


<div class="viewcode-block" id="BifrequencyMap.diagonal">
<a class="viewcode-back" href="../../../web/ja/reference/api/frequencyseries.html#gwexpy.frequencyseries.BifrequencyMap.diagonal">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">diagonal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;mean&quot;</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">absolute</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates statistics along the diagonal axis (f2 - f1).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        method : str, optional</span>
<span class="sd">            Statistical method to use.</span>
<span class="sd">            Supported: &#39;mean&#39;, &#39;median&#39;, &#39;max&#39;, &#39;min&#39;, &#39;std&#39;, &#39;rms&#39;, &#39;percentile&#39;.</span>
<span class="sd">            Default is &#39;mean&#39;.</span>
<span class="sd">            All methods ignore NaNs in the data by default.</span>
<span class="sd">        bins : int or array-like, optional</span>
<span class="sd">            Number of bins or bin edges for the diagonal axis.</span>
<span class="sd">            If None (default), it is automatically determined based on the resolution</span>
<span class="sd">            of frequency axes (max(df1, df2)).</span>
<span class="sd">        absolute : bool, optional</span>
<span class="sd">            If True, calculates statistics along the absolute difference ``abs(f2 - f1)``.</span>
<span class="sd">            Default is False.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional arguments passed to the statistical function.</span>
<span class="sd">            For &#39;percentile&#39;, use `percentile=...`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        FrequencySeries</span>
<span class="sd">            The result of the diagonal projection.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">scipy.stats</span><span class="w"> </span><span class="kn">import</span> <span class="n">binned_statistic</span>

        <span class="c1"># Create meshgrid for frequencies</span>
        <span class="n">f1_grid</span><span class="p">,</span> <span class="n">f2_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frequency1</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">frequency2</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

        <span class="c1"># Calculate diagonal axis values (f2 - f1)</span>
        <span class="n">diag_val</span> <span class="o">=</span> <span class="n">f2_grid</span> <span class="o">-</span> <span class="n">f1_grid</span>

        <span class="k">if</span> <span class="n">absolute</span><span class="p">:</span>
            <span class="n">diag_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">diag_val</span><span class="p">)</span>

        <span class="c1"># Determine bins automatically if None</span>
        <span class="k">if</span> <span class="n">bins</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Estimate resolution (df) for each axis</span>
            <span class="c1"># Use mean difference to be robust against minor numeric noise</span>
            <span class="n">df1</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frequency1</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frequency1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span>
                <span class="k">else</span> <span class="mf">1.0</span>
            <span class="p">)</span>
            <span class="n">df2</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frequency2</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frequency2</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span>
                <span class="k">else</span> <span class="mf">1.0</span>
            <span class="p">)</span>

            <span class="c1"># Use the coarser resolution (maximum df) to avoid oversampling</span>
            <span class="n">target_df</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">df1</span><span class="p">,</span> <span class="n">df2</span><span class="p">)</span>

            <span class="c1"># Calculate range</span>
            <span class="n">min_diag</span> <span class="o">=</span> <span class="n">diag_val</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
            <span class="n">max_diag</span> <span class="o">=</span> <span class="n">diag_val</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
            <span class="n">range_diag</span> <span class="o">=</span> <span class="n">max_diag</span> <span class="o">-</span> <span class="n">min_diag</span>

            <span class="c1"># Calculate number of bins</span>
            <span class="c1"># Ensure at least 1 bin</span>
            <span class="k">if</span> <span class="n">target_df</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">bins</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">range_diag</span> <span class="o">/</span> <span class="n">target_df</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">bins</span> <span class="o">=</span> <span class="mi">100</span>  <span class="c1"># Fallback if resolution is 0</span>

            <span class="n">bins</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">bins</span><span class="p">)</span>

        <span class="c1"># Flatten arrays for binning</span>

        <span class="c1"># Flatten arrays for binning</span>
        <span class="n">diag_flat</span> <span class="o">=</span> <span class="n">diag_val</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">data_flat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

        <span class="c1"># Map methods to NaN-safe functions</span>
        <span class="n">statistic_func</span><span class="p">:</span> <span class="n">Any</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;mean&quot;</span><span class="p">:</span>
            <span class="n">statistic_func</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;median&quot;</span><span class="p">:</span>
            <span class="n">statistic_func</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmedian</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;max&quot;</span><span class="p">:</span>
            <span class="n">statistic_func</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;min&quot;</span><span class="p">:</span>
            <span class="n">statistic_func</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;std&quot;</span><span class="p">:</span>
            <span class="n">statistic_func</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanstd</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;rms&quot;</span><span class="p">:</span>
            <span class="c1"># RMS is sqrt(mean(square))</span>
            <span class="c1"># Calculate mean of squares (ignoring NaNs), then take sqrt</span>
            <span class="n">data_flat</span> <span class="o">=</span> <span class="n">data_flat</span><span class="o">**</span><span class="mi">2</span>
            <span class="n">statistic_func</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;percentile&quot;</span><span class="p">:</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;percentile&quot;</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>

            <span class="k">def</span><span class="w"> </span><span class="nf">_percentile</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nanpercentile</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>

            <span class="n">statistic_func</span> <span class="o">=</span> <span class="n">_percentile</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Fallback for custom callables or unsupported strings (let binned_statistic handle)</span>
            <span class="n">statistic_func</span> <span class="o">=</span> <span class="n">method</span>

        <span class="c1"># Calculate binned statistics</span>
        <span class="n">stat_vals</span><span class="p">,</span> <span class="n">bin_edges</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">binned_statistic</span><span class="p">(</span>
            <span class="n">diag_flat</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="n">data_flat</span><span class="p">,</span> <span class="n">statistic</span><span class="o">=</span><span class="n">statistic_func</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">bins</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;rms&quot;</span><span class="p">:</span>
            <span class="n">stat_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">stat_vals</span><span class="p">)</span>

        <span class="c1"># Create frequency axis for the result (center of bins)</span>
        <span class="n">bin_centers</span> <span class="o">=</span> <span class="p">(</span><span class="n">bin_edges</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">bin_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="o">/</span> <span class="mi">2</span>

        <span class="c1"># Determine unit</span>
        <span class="n">unit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span>

        <span class="c1"># Determine axis unit</span>
        <span class="n">axis_unit</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frequency1</span><span class="p">,</span> <span class="s2">&quot;unit&quot;</span><span class="p">):</span>
            <span class="n">axis_unit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">frequency1</span><span class="o">.</span><span class="n">unit</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frequency2</span><span class="p">,</span> <span class="s2">&quot;unit&quot;</span><span class="p">):</span>
            <span class="n">axis_unit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">frequency2</span><span class="o">.</span><span class="n">unit</span>

        <span class="c1"># Create FrequencySeries</span>
        <span class="n">frequencies</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">Quantity</span><span class="p">(</span><span class="n">bin_centers</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">axis_unit</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">FrequencySeries</span><span class="p">(</span>
            <span class="n">stat_vals</span><span class="p">,</span>
            <span class="n">frequencies</span><span class="o">=</span><span class="n">frequencies</span><span class="p">,</span>
            <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> (diagonal </span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="BifrequencyMap.convolute">
<a class="viewcode-back" href="../../../web/ja/reference/api/frequencyseries.html#gwexpy.frequencyseries.BifrequencyMap.convolute">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">convolute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_spectrum</span><span class="p">,</span> <span class="n">interpolate</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convolutes the map with an input spectrum (integration along f1).</span>

<span class="sd">        Calculates:</span>
<span class="sd">            S_out(f2) = integral( M(f2, f1) * S_in(f1) * df1 )</span>

<span class="sd">        This is similar to `propagate`, but multiplies by the frequency bin width (df)</span>
<span class="sd">        to perform an integration rather than a simple sum.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        input_spectrum : FrequencySeries</span>
<span class="sd">            Input spectrum S_in(f1).</span>
<span class="sd">        interpolate : bool, optional</span>
<span class="sd">            If True, interpolates input spectrum to match map&#39;s f1 axis. Default is True.</span>
<span class="sd">        fill_value : float, optional</span>
<span class="sd">            Fill value for interpolation. Default is 0.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        FrequencySeries</span>
<span class="sd">            Output spectrum S_out(f2).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Reuse propagate logic logic to get the matrix product (Sum[M*S])</span>
        <span class="c1"># We can call propagate assuming it does the matrix product part correctly.</span>
        <span class="c1"># But propagate returns a FrequencySeries, so we can just operate on it.</span>

        <span class="c1"># However, we need to know the &#39;df&#39; used for the integration.</span>
        <span class="c1"># If we interpolate, we use the map&#39;s f1 resolution.</span>
        <span class="c1"># If we don&#39;t interpolate, we assume input matches f1.</span>

        <span class="c1"># Let&#39;s re-implement logic lightly or call propagate?</span>
        <span class="c1"># propagate does: out = self.value @ in_val</span>
        <span class="c1"># It handles interpolation.</span>

        <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">propagate</span><span class="p">(</span>
            <span class="n">input_spectrum</span><span class="p">,</span> <span class="n">interpolate</span><span class="o">=</span><span class="n">interpolate</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span>
        <span class="p">)</span>

        <span class="c1"># Now we need to multiply by df.</span>
        <span class="c1"># Which df? The df of the integration axis (f1).</span>
        <span class="c1"># We need the df of the grid used for multiplication.</span>
        <span class="c1"># In propagate:</span>
        <span class="c1">#   if interpolate: in_val is resampled to self.frequency1 -&gt; use self.frequency1 resolution.</span>
        <span class="c1">#   else: in_val must match self.shape[1] (which is len(f1)) -&gt; use self.frequency1 resolution (assuming uniform) or input&#39;s?</span>

        <span class="c1"># Safest is to calculate df from self.frequency1 since that&#39;s what the matrix is defined on.</span>
        <span class="c1"># Assuming uniform grid for integration approximation.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frequency1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frequency1</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Fallback if single point (df not well defined, maybe 1.0 or 0?)</span>
            <span class="c1"># If standard integration of a point source ??</span>
            <span class="n">df</span> <span class="o">=</span> <span class="mf">1.0</span>

        <span class="c1"># If self.frequency1 has unit, df should have that unit.</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frequency1</span><span class="p">,</span> <span class="s2">&quot;unit&quot;</span><span class="p">):</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">df</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">frequency1</span><span class="o">.</span><span class="n">unit</span>

        <span class="c1"># Multiply result by df</span>
        <span class="k">return</span> <span class="n">res</span> <span class="o">*</span> <span class="n">df</span></div>


<div class="viewcode-block" id="BifrequencyMap.plot_lines">
<a class="viewcode-back" href="../../../web/ja/reference/api/frequencyseries.html#gwexpy.frequencyseries.BifrequencyMap.plot_lines">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">plot_lines</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">xaxis</span><span class="o">=</span><span class="s2">&quot;f1&quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;f2&quot;</span><span class="p">,</span> <span class="n">num_lines</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the map as a set of lines (1D spectra).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        xaxis : str, optional</span>
<span class="sd">            The x-axis definition for each line.</span>
<span class="sd">            - &#39;f1&#39;: Frequency 1.</span>
<span class="sd">            - &#39;f2&#39;: Frequency 2.</span>
<span class="sd">            - &#39;diff&#39;, &#39;f2-f1&#39;: Frequency 2 - Frequency 1.</span>
<span class="sd">            - &#39;diff_inv&#39;, &#39;f1-f2&#39;: Frequency 1 - Frequency 2.</span>
<span class="sd">            - &#39;abs_diff&#39;, ``&#39;|f2-f1|&#39;``: absolute value of (Frequency 2 - Frequency 1).</span>
<span class="sd">            Default is &#39;f1&#39;.</span>
<span class="sd">        color : str, optional</span>
<span class="sd">             The parameter to use for coloring the lines (and defining the slices).</span>
<span class="sd">            - &#39;f2&#39; (default): Iterate over Frequency 2 (rows). Each line is a row at fixed f2. Color is f2.</span>
<span class="sd">            - &#39;f1&#39;: Iterate over Frequency 1 (columns). Each line is a column at fixed f1. Color is f1.</span>
<span class="sd">            - &#39;diff&#39;, &#39;f2-f1&#39;: (Not fully implemented for slicing) Ideally iterate over diagonals.</span>
<span class="sd">        num_lines : int, optional</span>
<span class="sd">            Maximum number of lines to plot. If None, plot all.</span>
<span class="sd">            Lines are subsampled uniformly if count exceeds num_lines.</span>
<span class="sd">        ax : matplotlib.axes.Axes, optional</span>
<span class="sd">            Axes to plot on. If None, a new figure is created.</span>
<span class="sd">        cmap : str or Colormap, optional</span>
<span class="sd">            Colormap to use.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional arguments passed to LineCollection.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        matplotlib.figure.Figure or matplotlib.axes.Axes</span>
<span class="sd">            The figure or axes where the plot was drawn.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">gwpy.plot</span><span class="w"> </span><span class="kn">import</span> <span class="n">Plot</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">matplotlib.collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">LineCollection</span>

        <span class="c1"># Determine slicing axis based on &#39;color&#39;</span>
        <span class="k">if</span> <span class="n">color</span> <span class="o">==</span> <span class="s2">&quot;f2&quot;</span><span class="p">:</span>
            <span class="c1"># Slice along f2 (rows). Fixed f2, x varies (f1 usually).</span>
            <span class="n">iter_axis_vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">frequency2</span><span class="o">.</span><span class="n">value</span>
            <span class="n">iter_axis_unit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">frequency2</span><span class="o">.</span><span class="n">unit</span>
            <span class="n">data_slices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span>  <span class="c1"># shape (nf2, nf1). Rows are f2 slices.</span>

            <span class="c1"># For each slice (row), we have full f1 array.</span>
            <span class="n">base_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">frequency1</span><span class="o">.</span><span class="n">value</span>
            <span class="c1"># We will need to compute x for each line potentially (if xaxis depends on f2)</span>

            <span class="n">slice_axis_name</span> <span class="o">=</span> <span class="s2">&quot;f2&quot;</span>

        <span class="k">elif</span> <span class="n">color</span> <span class="o">==</span> <span class="s2">&quot;f1&quot;</span><span class="p">:</span>
            <span class="c1"># Slice along f1 (columns). Fixed f1, x varies (f2 usually).</span>
            <span class="n">iter_axis_vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">frequency1</span><span class="o">.</span><span class="n">value</span>
            <span class="n">iter_axis_unit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">frequency1</span><span class="o">.</span><span class="n">unit</span>
            <span class="n">data_slices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">T</span>  <span class="c1"># shape (nf1, nf2). Rows are f1 slices.</span>

            <span class="c1"># For each slice (column), we have full f2 array.</span>
            <span class="n">base_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">frequency2</span><span class="o">.</span><span class="n">value</span>

            <span class="n">slice_axis_name</span> <span class="o">=</span> <span class="s2">&quot;f1&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Coloring/Slicing by &#39;</span><span class="si">{</span><span class="n">color</span><span class="si">}</span><span class="s2">&#39; is not yet implemented using slice iteration.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Subsample if necessary</span>
        <span class="n">n_slices</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">iter_axis_vals</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">num_lines</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">n_slices</span> <span class="o">&gt;</span> <span class="n">num_lines</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n_slices</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">num_lines</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">iter_axis_vals</span> <span class="o">=</span> <span class="n">iter_axis_vals</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>
            <span class="n">data_slices</span> <span class="o">=</span> <span class="n">data_slices</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_slices</span><span class="p">)</span>

        <span class="c1"># Prepare list of (x, y) segments</span>
        <span class="n">segments</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Pre-compute grids if needed for speed, but loop is fine for plotting usually</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">iter_axis_vals</span><span class="p">):</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">data_slices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

            <span class="c1"># Determine x array for this line</span>
            <span class="k">if</span> <span class="n">xaxis</span> <span class="o">==</span> <span class="s2">&quot;f1&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">slice_axis_name</span> <span class="o">==</span> <span class="s2">&quot;f2&quot;</span><span class="p">:</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="n">base_x</span>  <span class="c1"># f1 array</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># slice is fixed f1. x would be constant?</span>
                    <span class="c1"># If xaxis=&#39;f1&#39; and color=&#39;f1&#39;, each line is a vertical line at f1.</span>
                    <span class="c1"># x = np.full_like(base_x, val)</span>
                    <span class="c1"># But usually if color=&#39;f1&#39;, xaxis should be &#39;f2&#39; or &#39;diff&#39;.</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">base_x</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">xaxis</span> <span class="o">==</span> <span class="s2">&quot;f2&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">slice_axis_name</span> <span class="o">==</span> <span class="s2">&quot;f1&quot;</span><span class="p">:</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="n">base_x</span>  <span class="c1"># f2 array</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># slice is fixed f2.</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">base_x</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">xaxis</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;diff&quot;</span><span class="p">,</span> <span class="s2">&quot;f2-f1&quot;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">slice_axis_name</span> <span class="o">==</span> <span class="s2">&quot;f2&quot;</span><span class="p">:</span>
                    <span class="c1"># fixed f2 (val), variable f1 (base_x)</span>
                    <span class="c1"># x = f2 - f1</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="n">val</span> <span class="o">-</span> <span class="n">base_x</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># fixed f1 (val), variable f2 (base_x)</span>
                    <span class="c1"># x = f2 - f1</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="n">base_x</span> <span class="o">-</span> <span class="n">val</span>

            <span class="k">elif</span> <span class="n">xaxis</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;diff_inv&quot;</span><span class="p">,</span> <span class="s2">&quot;f1-f2&quot;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">slice_axis_name</span> <span class="o">==</span> <span class="s2">&quot;f2&quot;</span><span class="p">:</span>
                    <span class="c1"># f1 - f2</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="n">base_x</span> <span class="o">-</span> <span class="n">val</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># f1 - f2</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="n">val</span> <span class="o">-</span> <span class="n">base_x</span>

            <span class="k">elif</span> <span class="n">xaxis</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;abs_diff&quot;</span><span class="p">,</span> <span class="s2">&quot;|f2-f1|&quot;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">slice_axis_name</span> <span class="o">==</span> <span class="s2">&quot;f2&quot;</span><span class="p">:</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">val</span> <span class="o">-</span> <span class="n">base_x</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">base_x</span> <span class="o">-</span> <span class="n">val</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Default to base_x if unknown? Or error?</span>
                <span class="c1"># Assume &#39;remaining&#39; behavior if matching?</span>
                <span class="c1"># If slice is f2, &#39;remaining&#39; is f1.</span>
                <span class="k">if</span> <span class="n">slice_axis_name</span> <span class="o">==</span> <span class="s2">&quot;f2&quot;</span> <span class="ow">and</span> <span class="n">xaxis</span> <span class="o">==</span> <span class="s2">&quot;remaining&quot;</span><span class="p">:</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="n">base_x</span>
                <span class="k">elif</span> <span class="n">slice_axis_name</span> <span class="o">==</span> <span class="s2">&quot;f1&quot;</span> <span class="ow">and</span> <span class="n">xaxis</span> <span class="o">==</span> <span class="s2">&quot;remaining&quot;</span><span class="p">:</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="n">base_x</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown xaxis option: </span><span class="si">{</span><span class="n">xaxis</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="c1"># Filter NaNs from x and y for clean plotting?</span>
            <span class="c1"># LineCollection handles them but segments must be valid.</span>
            <span class="c1"># Convert to (N, 2) array</span>
            <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">segments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>

        <span class="c1"># Concatenate segments? No, LineCollection takes a list of (N, 2) arrays.</span>
        <span class="c1"># Ensure segments are (N, 2) not (N, 1, 2) logic check.</span>
        <span class="c1"># Correct format for LineCollection is list of (N, 2) arrays.</span>
        <span class="n">segments</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">segments</span><span class="p">]</span>

        <span class="c1"># Create LineCollection</span>
        <span class="n">lc</span> <span class="o">=</span> <span class="n">LineCollection</span><span class="p">(</span>
            <span class="n">segments</span><span class="p">,</span>
            <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span>
            <span class="n">norm</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">Normalize</span><span class="p">(</span><span class="n">iter_axis_vals</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">iter_axis_vals</span><span class="o">.</span><span class="n">max</span><span class="p">()),</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">lc</span><span class="o">.</span><span class="n">set_array</span><span class="p">(</span><span class="n">iter_axis_vals</span><span class="p">)</span>  <span class="c1"># Set values for color mapping</span>

        <span class="c1"># Setup plot</span>
        <span class="n">new_plot</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">new_plot</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">plot</span> <span class="o">=</span> <span class="n">Plot</span><span class="p">()</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">plot</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">lc</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">autoscale</span><span class="p">()</span>

        <span class="c1"># Add colorbar</span>
        <span class="n">cbar_label</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">color</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="n">iter_axis_unit</span><span class="p">:</span>
            <span class="n">cbar_label</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot; [</span><span class="si">{</span><span class="n">iter_axis_unit</span><span class="si">}</span><span class="s2">]&quot;</span>

        <span class="c1"># We need a mappable for colorbar. lc is mappable.</span>
        <span class="c1"># But we need figure.</span>
        <span class="k">if</span> <span class="n">ax</span><span class="o">.</span><span class="n">figure</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">figure</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">lc</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">cbar_label</span><span class="p">)</span>

        <span class="c1"># Set labels</span>
        <span class="n">xlabel</span> <span class="o">=</span> <span class="n">xaxis</span>
        <span class="k">if</span> <span class="n">xaxis</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;f1&quot;</span><span class="p">,</span> <span class="s2">&quot;f2&quot;</span><span class="p">]</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;frequency</span><span class="si">{</span><span class="n">xaxis</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">):</span>
            <span class="n">u_</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;frequency</span><span class="si">{</span><span class="n">xaxis</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">unit</span>
            <span class="k">if</span> <span class="n">u_</span><span class="p">:</span>
                <span class="n">xlabel</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot; [</span><span class="si">{</span><span class="n">u_</span><span class="si">}</span><span class="s2">]&quot;</span>
        <span class="k">elif</span> <span class="n">xaxis</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;diff&quot;</span><span class="p">,</span> <span class="s2">&quot;f2-f1&quot;</span><span class="p">,</span> <span class="s2">&quot;abs_diff&quot;</span><span class="p">,</span> <span class="s2">&quot;|f2-f1|&quot;</span><span class="p">]:</span>
            <span class="c1"># Unit is likely same as axes</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">frequency1</span><span class="o">.</span><span class="n">unit</span><span class="p">:</span>
                <span class="n">xlabel</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot; [</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">frequency1</span><span class="o">.</span><span class="n">unit</span><span class="si">}</span><span class="s2">]&quot;</span>

        <span class="n">ylabel</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> [</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="si">}</span><span class="s2">]&quot;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="n">xlabel</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="n">ylabel</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">new_plot</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">plot</span>
        <span class="k">return</span> <span class="n">ax</span></div>
</div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2026, GWexpy contributors.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>