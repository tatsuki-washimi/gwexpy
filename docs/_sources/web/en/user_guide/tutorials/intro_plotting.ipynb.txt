{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# gwexpy Plotting Introduction\n",
    "\n",
    "This notebook introduces the enhanced plotting capabilities of `gwexpy`.\n",
    "We demonstrate the \"nice\" default settings (automatic figsize adjustment, logarithmic axes, layout, axis labels) for matrix data structures such as `TimeSeriesMatrix` and `FrequencySeriesMatrix`, as well as collections like `SpectrogramList`."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import matplotlib.pyplot as plt\n",
    "import numpy as np\n",
    "from astropy import units as u\n",
    "\n",
    "from gwexpy.frequencyseries import (\n",
    "    FrequencySeries,\n",
    "    FrequencySeriesList,\n",
    "    FrequencySeriesMatrix,\n",
    ")\n",
    "from gwexpy.spectrogram import Spectrogram, SpectrogramList\n",
    "from gwexpy.timeseries import TimeSeries, TimeSeriesMatrix\n",
    "\n",
    "# Fix random seed\n",
    "np.random.seed(42)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 1. TimeSeriesMatrix Plotting\n",
    "\n",
    "`TimeSeriesMatrix` manages time series data with a 3-dimensional structure (Row, Col, Time).\n",
    "When calling `.plot()`, the following optimizations are applied:\n",
    "- **Axis Labels**: \"Time [s]\" or \"Time [s] from ...\" is automatically set by `determine_xlabel`.\n",
    "- **Auto-GPS**: For time axes, the `auto-gps` scale is applied by default to properly handle GPS time (large offsets).\n",
    "- **Layout**: The `figsize` is automatically adjusted according to the row and column structure."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Create a 2x2 TimeSeriesMatrix\n",
    "# 10 seconds from GPS time (e.g., 1356998418 = 2023-01-01 00:00:00 UTC)\n",
    "t0 = 1356998418.0\n",
    "times = t0 + np.linspace(0, 10, 1000)\n",
    "data = np.random.randn(2, 2, 1000)\n",
    "# Rows: Sensor A, B / Cols: Axis X, Y\n",
    "tsm = TimeSeriesMatrix(\n",
    "    data,\n",
    "    times=times,\n",
    "    unit=\"m\",\n",
    "    name=\"Velocity\",\n",
    "    rows=[\"Sensor A\", \"Sensor B\"],\n",
    "    cols=[\"X-axis\", \"Y-axis\"],\n",
    ")\n",
    "\n",
    "# Plot\n",
    "plot = tsm.plot()\n",
    "plot.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 2. FrequencySeriesMatrix Plotting\n",
    "\n",
    "`FrequencySeriesMatrix` manages frequency data with a 3-dimensional structure (Row, Col, Frequency).\n",
    "It typically holds results from spectral analysis.\n",
    "Features of `.plot()`:\n",
    "- **Logarithmic Axes**: The X-axis (frequency) and Y-axis (amplitude) are automatically set to logarithmic scale depending on conditions such as data size.\n",
    "- **Axis Labels**: \"Frequency [Hz]\" and \"[unit]\" are automatically set."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Create FrequencySeriesMatrix\n",
    "# From 10Hz to 1kHz\n",
    "f = np.logspace(1, 3, 500)\n",
    "# Generate 1/f noise-like data\n",
    "data = np.zeros((2, 2, 500))\n",
    "for i in range(2):\n",
    "    for j in range(2):\n",
    "        data[i, j, :] = 10 / f * (1 + 0.1 * np.random.randn(500)) + (i + j)\n",
    "\n",
    "# unit='m' (simplified here, though for Amplitude Spectral Density it would be m/sqrt(Hz))\n",
    "fsm = FrequencySeriesMatrix(\n",
    "    data,\n",
    "    frequencies=f,\n",
    "    unit=\"m\",\n",
    "    name=\"Displacement\",\n",
    "    rows=[\"Sensor A\", \"Sensor B\"],\n",
    "    cols=[\"X-axis\", \"Y-axis\"],\n",
    ")\n",
    "\n",
    "# Plot\n",
    "# Verify that it automatically becomes a log-log plot\n",
    "plot = fsm.plot()\n",
    "plot.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 3. FrequencySeriesList Plotting (Reference)\n",
    "\n",
    "`FrequencySeriesList` (or Dict) is a simple list without a grid structure.\n",
    "It can also be plotted in the same way."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Create FrequencySeriesList\n",
    "fs1 = FrequencySeries(1 / f, frequencies=f, unit=u.m, name=\"Series 1\")\n",
    "fs2 = FrequencySeries(2 / f, frequencies=f, unit=u.m, name=\"Series 2\")\n",
    "\n",
    "fs_list = FrequencySeriesList([fs1, fs2])\n",
    "\n",
    "fs_list.plot();"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "del times, data, tsm, fsm, fs1, fs2, fs_list\n",
    "\n",
    "import gc\n",
    "\n",
    "gc.collect()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 4. SpectrogramList Plotting\n",
    "\n",
    "Plotting of `SpectrogramList` applies a vertical layout with `geometry=(N, 1)` by default, along with a logarithmic colorbar.\n",
    "Since spectrograms also have a time axis, the `auto-gps` feature works when GPS time is provided."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Create Spectrogram\n",
    "# Use the same GPS time as TimeSeriesMatrix\n",
    "t = t0 + np.linspace(0, 10, 100)\n",
    "# 10Hz - 1000Hz\n",
    "f = np.logspace(1, 3, 50)\n",
    "\n",
    "spec_list = SpectrogramList(\n",
    "    [\n",
    "        Spectrogram(\n",
    "            np.random.rand(100, 50), times=t, frequencies=f, unit=u.count, name=\"Spec 1\"\n",
    "        ),\n",
    "        Spectrogram(\n",
    "            np.random.rand(100, 50) * 10,\n",
    "            times=t,\n",
    "            frequencies=f,\n",
    "            unit=u.count,\n",
    "            name=\"Spec 2\",\n",
    "        ),\n",
    "    ]\n",
    ")\n",
    "spec_list.plot();"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 4. Adaptive Plotting Optimization (Decimation)\n",
    "\n",
    "When plotting a `TimeSeries` with a large amount of data, decimation (Min-Max Decimation) is automatically applied to maintain rendering performance.\n",
    "- **Automatic Application**: By default, it is triggered when the number of samples exceeds 50,000.\n",
    "- **Peak Preservation**: The Min-Max algorithm reduces the number of data points (default ~10,000 points) while preserving the waveform envelope (maximum and minimum).\n",
    "- **Customization**: Can be controlled with the `decimate_threshold` and `decimate_points` arguments."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Generate data with 100,000,000 samples\n",
    "ts_large = TimeSeries(np.random.randn(100000000), sample_rate=1024, name=\"Large TS\")\n",
    "\n",
    "print(f\"Original samples: {len(ts_large)}\")\n",
    "\n",
    "# Execute plot (decimation is automatically applied)\n",
    "plot_opt = ts_large.plot()\n",
    "\n",
    "# Verify the number of plotted points\n",
    "ax = plot_opt.gca()\n",
    "line = ax.get_lines()[0]\n",
    "print(f\"Plotted points: {len(line.get_xdata())}\")\n",
    "plot_opt.show();"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Application to Collections/Matrices and Parameter Specification\n",
    "\n",
    "It also works transparently with `TimeSeriesList` and `TimeSeriesMatrix`. You can also force it to apply by lowering the threshold."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Example of lowering the threshold to 10,000 and specifying 2,000 plot points\n",
    "ts_med = TimeSeries(np.random.randn(20000), sample_rate=16384, name=\"Medium TS\")\n",
    "\n",
    "plot_custom = ts_med.plot(decimate_threshold=10000, decimate_points=2000)\n",
    "\n",
    "ax = plot_custom.gca()\n",
    "print(f\"Original: {len(ts_med)}, Plotted: {len(ax.get_lines()[0].get_xdata())}\")\n",
    "plot_custom.show();"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 5. Spectrogram Summary Plotting\n",
    "\n",
    "`plot_summary` is a feature that vertically arranges multiple `Spectrogram` objects and plots `FrequencySeries` statistics (10%, 50%, 90% percentiles) on the right side of each.\n",
    "This is very useful when checking the time evolution of spectrograms alongside their overall frequency characteristics.\n",
    "\n",
    "- **Automatic Synchronization**: The color axis of the spectrogram and the vertical axis of the FrequencySeries are automatically synchronized.\n",
    "- **MMM Plot**: Uses `plot_mmm` to display Min/Median/Max (or any percentiles) with shaded areas."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "from gwexpy.spectrogram import SpectrogramDict\n",
    "from gwexpy.timeseries import TimeSeries\n",
    "\n",
    "\n",
    "# Generate test data\n",
    "def make_sg(name):\n",
    "    ts = TimeSeries(np.random.randn(2048 * 10), sample_rate=2048, name=name, unit=\"m\")\n",
    "    return ts.spectrogram(stride=1, fftlength=1, overlap=0.5)\n",
    "\n",
    "\n",
    "sg_dict = SpectrogramDict({\"Channel A\": make_sg(\"A\"), \"Channel B\": make_sg(\"B\")})\n",
    "\n",
    "# Execute ASDgram plot\n",
    "fig, axes = sg_dict.plot_summary(fmin=10, fmax=500, title=\"ASDgram Demonstration\")\n",
    "plt.show();"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 6. PairPlot Example\n",
    "\n",
    "Below is a basic usage example of `gwexpy.plot.PairPlot`.\n",
    "- Create two `TimeSeries` with different sampling rates\n",
    "- `PairPlot` automatically resamples to the minimum sample rate and trims to the common interval\n",
    "- With `corner=True` (default), only the lower-left triangle is drawn\n",
    "\n",
    "When executed, histograms appear on the diagonal and 2D histograms on the off-diagonal."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "\n",
    "from gwexpy.plot import PairPlot\n",
    "from gwexpy.timeseries import TimeSeries\n",
    "\n",
    "# Create two TimeSeries with different sampling rates\n",
    "ts1 = TimeSeries(np.random.randn(5000), sample_rate=1024, name=\"TS1\")\n",
    "ts2 = TimeSeries(np.random.randn(4000), sample_rate=2048, name=\"TS2\")\n",
    "\n",
    "# Create PairPlot (corner=True is default)\n",
    "pair = PairPlot([ts1, ts2], corner=True)\n",
    "\n",
    "# Display\n",
    "pair.show()"
   ]
  }
 ],
 "metadata": {
  "language_info": {
   "name": "python"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
