{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Field × Advanced Analysis Workflow\n",
    "\n",
    "This tutorial demonstrates practical workflows combining ScalarField with advanced time-frequency analysis methods.\n",
    "\n",
    "## What You'll Learn\n",
    "\n",
    "- Extract time-series from ScalarField for analysis\n",
    "- Apply HHT, STLT, Wavelet transforms\n",
    "- Reconstruct analyzed data back into Field structure\n",
    "- Batch processing with FieldList\n",
    "\n",
    "## Use Case: Seismic Array Analysis\n",
    "\n",
    "We'll analyze a 3D seismic array where each spatial point records time-varying ground motion."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2026-02-13T04:45:58.106570Z",
     "iopub.status.busy": "2026-02-13T04:45:58.106432Z",
     "iopub.status.idle": "2026-02-13T04:45:59.930414Z",
     "shell.execute_reply": "2026-02-13T04:45:59.929537Z"
    }
   },
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "<python-env>/site-packages/gwpy/time/__init__.py:36: UserWarning: Wswiglal-redir-stdio:\n",
      "\n",
      "SWIGLAL standard output/error redirection is enabled in IPython.\n",
      "This may lead to performance penalties. To disable locally, use:\n",
      "\n",
      "with lal.no_swig_redirect_standard_output_error():\n",
      "    ...\n",
      "\n",
      "To disable globally, use:\n",
      "\n",
      "lal.swig_redirect_standard_output_error(False)\n",
      "\n",
      "Note however that this will likely lead to error messages from\n",
      "LAL functions being either misdirected or lost when called from\n",
      "Jupyter notebooks.\n",
      "\n",
      "To suppress this warning, use:\n",
      "\n",
      "import warnings\n",
      "warnings.filterwarnings(\"ignore\", \"Wswiglal-redir-stdio\")\n",
      "import lal\n",
      "\n",
      "  from lal import LIGOTimeGPS\n"
     ]
    }
   ],
   "source": [
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "from astropy import units as u\n",
    "from gwexpy.fields import ScalarField, FieldList\n",
    "from gwexpy.timeseries import TimeSeries\n",
    "\n",
    "# Suppress warnings\n",
    "import warnings\n",
    "warnings.filterwarnings('ignore')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Step 1: Create Synthetic Seismic Field\n",
    "\n",
    "Simulate ground motion from a seismic wave propagating through a 3D grid."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2026-02-13T04:45:59.933288Z",
     "iopub.status.busy": "2026-02-13T04:45:59.933054Z",
     "iopub.status.idle": "2026-02-13T04:46:00.179210Z",
     "shell.execute_reply": "2026-02-13T04:46:00.178596Z"
    }
   },
   "outputs": [
    {
     "ename": "TypeError",
     "evalue": "Array.__new__() got an unexpected keyword argument 't0'",
     "output_type": "error",
     "traceback": [
      "\u001b[31m---------------------------------------------------------------------------\u001b[39m",
      "\u001b[31mTypeError\u001b[39m                                 Traceback (most recent call last)",
      "\u001b[36mCell\u001b[39m\u001b[36m \u001b[39m\u001b[32mIn[2]\u001b[39m\u001b[32m, line 44\u001b[39m\n\u001b[32m     41\u001b[39m data += np.random.randn(*data.shape) * \u001b[32m0.1\u001b[39m\n\u001b[32m     43\u001b[39m \u001b[38;5;66;03m# Create ScalarField\u001b[39;00m\n\u001b[32m---> \u001b[39m\u001b[32m44\u001b[39m field_seismic = \u001b[43mScalarField\u001b[49m\u001b[43m(\u001b[49m\n\u001b[32m     45\u001b[39m \u001b[43m    \u001b[49m\u001b[43mdata\u001b[49m\u001b[43m,\u001b[49m\n\u001b[32m     46\u001b[39m \u001b[43m    \u001b[49m\u001b[43mt0\u001b[49m\u001b[43m=\u001b[49m\u001b[32;43m0\u001b[39;49m\u001b[43m*\u001b[49m\u001b[43mu\u001b[49m\u001b[43m.\u001b[49m\u001b[43ms\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mdt\u001b[49m\u001b[43m=\u001b[49m\u001b[43m(\u001b[49m\u001b[32;43m1\u001b[39;49m\u001b[43m/\u001b[49m\u001b[43mfs\u001b[49m\u001b[43m)\u001b[49m\u001b[43m*\u001b[49m\u001b[43mu\u001b[49m\u001b[43m.\u001b[49m\u001b[43ms\u001b[49m\u001b[43m,\u001b[49m\n\u001b[32m     47\u001b[39m \u001b[43m    \u001b[49m\u001b[43mx0\u001b[49m\u001b[43m=\u001b[49m\u001b[32;43m0\u001b[39;49m\u001b[43m*\u001b[49m\u001b[43mu\u001b[49m\u001b[43m.\u001b[49m\u001b[43mm\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mdx\u001b[49m\u001b[43m=\u001b[49m\u001b[32;43m10\u001b[39;49m\u001b[43m*\u001b[49m\u001b[43mu\u001b[49m\u001b[43m.\u001b[49m\u001b[43mm\u001b[49m\u001b[43m,\u001b[49m\n\u001b[32m     48\u001b[39m \u001b[43m    \u001b[49m\u001b[43my0\u001b[49m\u001b[43m=\u001b[49m\u001b[32;43m0\u001b[39;49m\u001b[43m*\u001b[49m\u001b[43mu\u001b[49m\u001b[43m.\u001b[49m\u001b[43mm\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mdy\u001b[49m\u001b[43m=\u001b[49m\u001b[32;43m10\u001b[39;49m\u001b[43m*\u001b[49m\u001b[43mu\u001b[49m\u001b[43m.\u001b[49m\u001b[43mm\u001b[49m\u001b[43m,\u001b[49m\n\u001b[32m     49\u001b[39m \u001b[43m    \u001b[49m\u001b[43mz0\u001b[49m\u001b[43m=\u001b[49m\u001b[32;43m0\u001b[39;49m\u001b[43m*\u001b[49m\u001b[43mu\u001b[49m\u001b[43m.\u001b[49m\u001b[43mm\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mdz\u001b[49m\u001b[43m=\u001b[49m\u001b[32;43m5\u001b[39;49m\u001b[43m*\u001b[49m\u001b[43mu\u001b[49m\u001b[43m.\u001b[49m\u001b[43mm\u001b[49m\u001b[43m,\u001b[49m\n\u001b[32m     50\u001b[39m \u001b[43m    \u001b[49m\u001b[43munit\u001b[49m\u001b[43m=\u001b[49m\u001b[33;43m'\u001b[39;49m\u001b[33;43mm\u001b[39;49m\u001b[33;43m'\u001b[39;49m\u001b[43m,\u001b[49m\u001b[43m  \u001b[49m\u001b[38;5;66;43;03m# Ground displacement\u001b[39;49;00m\n\u001b[32m     51\u001b[39m \u001b[43m    \u001b[49m\u001b[43mname\u001b[49m\u001b[43m=\u001b[49m\u001b[33;43m'\u001b[39;49m\u001b[33;43mSeismic Field\u001b[39;49m\u001b[33;43m'\u001b[39;49m\n\u001b[32m     52\u001b[39m \u001b[43m)\u001b[49m\n\u001b[32m     54\u001b[39m \u001b[38;5;28mprint\u001b[39m(\u001b[33mf\u001b[39m\u001b[33m\"\u001b[39m\u001b[33mCreated seismic field: \u001b[39m\u001b[38;5;132;01m{\u001b[39;00mfield_seismic.shape\u001b[38;5;132;01m}\u001b[39;00m\u001b[33m\"\u001b[39m)\n\u001b[32m     55\u001b[39m \u001b[38;5;28mprint\u001b[39m(\u001b[33mf\u001b[39m\u001b[33m\"\u001b[39m\u001b[33mTime span: \u001b[39m\u001b[38;5;132;01m{\u001b[39;00mduration\u001b[38;5;132;01m:\u001b[39;00m\u001b[33m.2f\u001b[39m\u001b[38;5;132;01m}\u001b[39;00m\u001b[33m s\u001b[39m\u001b[33m\"\u001b[39m)\n",
      "\u001b[36mFile \u001b[39m\u001b[32m~/work/gwexpy/gwexpy/fields/base.py:67\u001b[39m, in \u001b[36mFieldBase.__new__\u001b[39m\u001b[34m(cls, data, unit, axis0, axis1, axis2, axis3, axis_names, axis0_domain, space_domain, **kwargs)\u001b[39m\n\u001b[32m     64\u001b[39m         space_names = \u001b[38;5;28mlist\u001b[39m(\u001b[38;5;28mcls\u001b[39m._REAL_AXIS_NAMES)\n\u001b[32m     65\u001b[39m     axis_names = [time_name] + space_names\n\u001b[32m---> \u001b[39m\u001b[32m67\u001b[39m obj = \u001b[38;5;28;43msuper\u001b[39;49m\u001b[43m(\u001b[49m\u001b[43m)\u001b[49m\u001b[43m.\u001b[49m\u001b[34;43m__new__\u001b[39;49m\u001b[43m(\u001b[49m\n\u001b[32m     68\u001b[39m \u001b[43m    \u001b[49m\u001b[38;5;28;43mcls\u001b[39;49m\u001b[43m,\u001b[49m\n\u001b[32m     69\u001b[39m \u001b[43m    \u001b[49m\u001b[43mdata\u001b[49m\u001b[43m,\u001b[49m\n\u001b[32m     70\u001b[39m \u001b[43m    \u001b[49m\u001b[43munit\u001b[49m\u001b[43m=\u001b[49m\u001b[43munit\u001b[49m\u001b[43m,\u001b[49m\n\u001b[32m     71\u001b[39m \u001b[43m    \u001b[49m\u001b[43maxis0\u001b[49m\u001b[43m=\u001b[49m\u001b[43maxis0\u001b[49m\u001b[43m,\u001b[49m\n\u001b[32m     72\u001b[39m \u001b[43m    \u001b[49m\u001b[43maxis1\u001b[49m\u001b[43m=\u001b[49m\u001b[43maxis1\u001b[49m\u001b[43m,\u001b[49m\n\u001b[32m     73\u001b[39m \u001b[43m    \u001b[49m\u001b[43maxis2\u001b[49m\u001b[43m=\u001b[49m\u001b[43maxis2\u001b[49m\u001b[43m,\u001b[49m\n\u001b[32m     74\u001b[39m \u001b[43m    \u001b[49m\u001b[43maxis3\u001b[49m\u001b[43m=\u001b[49m\u001b[43maxis3\u001b[49m\u001b[43m,\u001b[49m\n\u001b[32m     75\u001b[39m \u001b[43m    \u001b[49m\u001b[43maxis_names\u001b[49m\u001b[43m=\u001b[49m\u001b[43maxis_names\u001b[49m\u001b[43m,\u001b[49m\n\u001b[32m     76\u001b[39m \u001b[43m    \u001b[49m\u001b[43m*\u001b[49m\u001b[43m*\u001b[49m\u001b[43mkwargs\u001b[49m\u001b[43m,\u001b[49m\n\u001b[32m     77\u001b[39m \u001b[43m\u001b[49m\u001b[43m)\u001b[49m\n\u001b[32m     79\u001b[39m \u001b[38;5;66;03m# Set domain states\u001b[39;00m\n\u001b[32m     80\u001b[39m \u001b[38;5;28;01mif\u001b[39;00m axis0_domain \u001b[38;5;129;01mnot\u001b[39;00m \u001b[38;5;129;01min\u001b[39;00m (\u001b[33m\"\u001b[39m\u001b[33mtime\u001b[39m\u001b[33m\"\u001b[39m, \u001b[33m\"\u001b[39m\u001b[33mfrequency\u001b[39m\u001b[33m\"\u001b[39m):\n",
      "\u001b[36mFile \u001b[39m\u001b[32m~/work/gwexpy/gwexpy/types/array4d.py:69\u001b[39m, in \u001b[36mArray4D.__new__\u001b[39m\u001b[34m(cls, data, unit, axis0, axis1, axis2, axis3, axis_names, **kwargs)\u001b[39m\n\u001b[32m     58\u001b[39m \u001b[38;5;28;01mdef\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[34m__new__\u001b[39m(\n\u001b[32m     59\u001b[39m     \u001b[38;5;28mcls\u001b[39m,\n\u001b[32m     60\u001b[39m     data,\n\u001b[32m   (...)\u001b[39m\u001b[32m     67\u001b[39m     **kwargs,\n\u001b[32m     68\u001b[39m ):\n\u001b[32m---> \u001b[39m\u001b[32m69\u001b[39m     obj = \u001b[38;5;28;43msuper\u001b[39;49m\u001b[43m(\u001b[49m\u001b[43m)\u001b[49m\u001b[43m.\u001b[49m\u001b[34;43m__new__\u001b[39;49m\u001b[43m(\u001b[49m\u001b[38;5;28;43mcls\u001b[39;49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mdata\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43munit\u001b[49m\u001b[43m=\u001b[49m\u001b[43munit\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43m*\u001b[49m\u001b[43m*\u001b[49m\u001b[43mkwargs\u001b[49m\u001b[43m)\u001b[49m\n\u001b[32m     70\u001b[39m     \u001b[38;5;28;01mif\u001b[39;00m obj.ndim != \u001b[32m4\u001b[39m:\n\u001b[32m     71\u001b[39m         \u001b[38;5;28;01mraise\u001b[39;00m \u001b[38;5;167;01mValueError\u001b[39;00m(\u001b[33mf\u001b[39m\u001b[33m\"\u001b[39m\u001b[33mArray4D must be 4-dimensional, got \u001b[39m\u001b[38;5;132;01m{\u001b[39;00mobj.ndim\u001b[38;5;132;01m}\u001b[39;00m\u001b[33mD\u001b[39m\u001b[33m\"\u001b[39m)\n",
      "\u001b[36mFile \u001b[39m\u001b[32m~/work/gwexpy/gwexpy/types/array.py:22\u001b[39m, in \u001b[36mArray.__new__\u001b[39m\u001b[34m(cls, data, axis_names, **kwargs)\u001b[39m\n\u001b[32m     21\u001b[39m \u001b[38;5;28;01mdef\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[34m__new__\u001b[39m(\u001b[38;5;28mcls\u001b[39m, data, axis_names=\u001b[38;5;28;01mNone\u001b[39;00m, **kwargs):\n\u001b[32m---> \u001b[39m\u001b[32m22\u001b[39m     obj = \u001b[38;5;28;43msuper\u001b[39;49m\u001b[43m(\u001b[49m\u001b[43m)\u001b[49m\u001b[43m.\u001b[49m\u001b[34;43m__new__\u001b[39;49m\u001b[43m(\u001b[49m\u001b[38;5;28;43mcls\u001b[39;49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mdata\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43m*\u001b[49m\u001b[43m*\u001b[49m\u001b[43mkwargs\u001b[49m\u001b[43m)\u001b[49m\n\u001b[32m     23\u001b[39m     \u001b[38;5;28;01mif\u001b[39;00m axis_names \u001b[38;5;129;01mis\u001b[39;00m \u001b[38;5;28;01mNone\u001b[39;00m:\n\u001b[32m     24\u001b[39m         axis_names = [\u001b[33mf\u001b[39m\u001b[33m\"\u001b[39m\u001b[33maxis\u001b[39m\u001b[38;5;132;01m{\u001b[39;00mi\u001b[38;5;132;01m}\u001b[39;00m\u001b[33m\"\u001b[39m \u001b[38;5;28;01mfor\u001b[39;00m i \u001b[38;5;129;01min\u001b[39;00m \u001b[38;5;28mrange\u001b[39m(obj.ndim)]\n",
      "\u001b[31mTypeError\u001b[39m: Array.__new__() got an unexpected keyword argument 't0'"
     ]
    }
   ],
   "source": [
    "# Parameters\n",
    "nt, nx, ny, nz = 256, 8, 8, 4  # 256 time samples, 8×8×4 spatial grid\n",
    "fs = 100  # Hz\n",
    "duration = nt / fs\n",
    "\n",
    "# Create axis coordinates\n",
    "t_axis = np.arange(nt) * (1/fs) * u.s\n",
    "x_axis = np.arange(nx) * 10.0 * u.m  # 10m spacing\n",
    "y_axis = np.arange(ny) * 10.0 * u.m\n",
    "z_axis = np.arange(nz) * 5.0 * u.m   # 5m depth spacing\n",
    "\n",
    "# Simulate seismic wave (P-wave + surface wave)\n",
    "data = np.zeros((nt, nx, ny, nz))\n",
    "\n",
    "# P-wave (bulk wave, faster)\n",
    "v_p = 3000  # m/s\n",
    "f_p = 10    # Hz\n",
    "for ix in range(nx):\n",
    "    for iy in range(ny):\n",
    "        for iz in range(nz):\n",
    "            # Distance from source (corner)\n",
    "            dist = np.sqrt(x_axis[ix].value**2 + y_axis[iy].value**2 + z_axis[iz].value**2)\n",
    "            delay = dist / v_p\n",
    "            t_vals = t_axis.value\n",
    "            \n",
    "            # P-wave with geometric spreading\n",
    "            amplitude_p = 1.0 / (dist + 1)\n",
    "            data[:, ix, iy, iz] += amplitude_p * np.sin(2*np.pi*f_p * (t_vals - delay)) * (t_vals > delay)\n",
    "\n",
    "# Surface wave (slower, stronger)\n",
    "v_s = 1500  # m/s\n",
    "f_s = 5     # Hz\n",
    "for ix in range(nx):\n",
    "    for iy in range(ny):\n",
    "        dist_surf = np.sqrt(x_axis[ix].value**2 + y_axis[iy].value**2)\n",
    "        delay_s = dist_surf / v_s\n",
    "        amplitude_s = 2.0 / (dist_surf + 1)\n",
    "        data[:, ix, iy, 0] += amplitude_s * np.sin(2*np.pi*f_s * (t_vals - delay_s)) * (t_vals > delay_s)\n",
    "\n",
    "# Add noise\n",
    "data += np.random.randn(*data.shape) * 0.1\n",
    "\n",
    "# Create ScalarField\n",
    "field_seismic = ScalarField(\n",
    "    data,\n",
    "    t0=0*u.s, dt=(1/fs)*u.s,\n",
    "    x0=0*u.m, dx=10*u.m,\n",
    "    y0=0*u.m, dy=10*u.m,\n",
    "    z0=0*u.m, dz=5*u.m,\n",
    "    unit='m',  # Ground displacement\n",
    "    name='Seismic Field'\n",
    ")\n",
    "\n",
    "print(f\"Created seismic field: {field_seismic.shape}\")\n",
    "print(f\"Time span: {duration:.2f} s\")\n",
    "print(f\"Spatial extent: {nx*10}m × {ny*10}m × {nz*5}m\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Step 2: Extract TimeSeries for Analysis\n",
    "\n",
    "Extract time-series from specific spatial locations for detailed analysis."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2026-02-13T04:46:00.180828Z",
     "iopub.status.busy": "2026-02-13T04:46:00.180715Z",
     "iopub.status.idle": "2026-02-13T04:46:00.198847Z",
     "shell.execute_reply": "2026-02-13T04:46:00.198355Z"
    }
   },
   "outputs": [
    {
     "ename": "NameError",
     "evalue": "name 'field_seismic' is not defined",
     "output_type": "error",
     "traceback": [
      "\u001b[31m---------------------------------------------------------------------------\u001b[39m",
      "\u001b[31mNameError\u001b[39m                                 Traceback (most recent call last)",
      "\u001b[36mCell\u001b[39m\u001b[36m \u001b[39m\u001b[32mIn[3]\u001b[39m\u001b[32m, line 2\u001b[39m\n\u001b[32m      1\u001b[39m \u001b[38;5;66;03m# Extract time-series at corner (near source) and far point\u001b[39;00m\n\u001b[32m----> \u001b[39m\u001b[32m2\u001b[39m ts_near = \u001b[43mfield_seismic\u001b[49m[:, \u001b[32m1\u001b[39m, \u001b[32m1\u001b[39m, \u001b[32m0\u001b[39m].to_timeseries()  \u001b[38;5;66;03m# Near source\u001b[39;00m\n\u001b[32m      3\u001b[39m ts_far = field_seismic[:, \u001b[32m6\u001b[39m, \u001b[32m6\u001b[39m, \u001b[32m0\u001b[39m].to_timeseries()   \u001b[38;5;66;03m# Far from source\u001b[39;00m\n\u001b[32m      5\u001b[39m \u001b[38;5;66;03m# Plot\u001b[39;00m\n",
      "\u001b[31mNameError\u001b[39m: name 'field_seismic' is not defined"
     ]
    }
   ],
   "source": [
    "# Extract time-series at corner (near source) and far point\n",
    "ts_near = field_seismic[:, 1, 1, 0].to_timeseries()  # Near source\n",
    "ts_far = field_seismic[:, 6, 6, 0].to_timeseries()   # Far from source\n",
    "\n",
    "# Plot\n",
    "fig, axes = plt.subplots(2, 1, figsize=(12, 6), sharex=True)\n",
    "\n",
    "axes[0].plot(ts_near.times.value, ts_near.value, linewidth=0.8)\n",
    "axes[0].set_ylabel('Displacement (m)')\n",
    "axes[0].set_title('Near Source (10m, 10m, 0m)')\n",
    "axes[0].grid(True, alpha=0.3)\n",
    "\n",
    "axes[1].plot(ts_far.times.value, ts_far.value, linewidth=0.8)\n",
    "axes[1].set_ylabel('Displacement (m)')\n",
    "axes[1].set_xlabel('Time (s)')\n",
    "axes[1].set_title('Far Point (60m, 60m, 0m)')\n",
    "axes[1].grid(True, alpha=0.3)\n",
    "\n",
    "plt.tight_layout()\n",
    "plt.show()\n",
    "\n",
    "print(\"Extracted TimeSeries for analysis\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Step 3: Apply STLT to Detect Damping\n",
    "\n",
    "Use Short-Time Laplace Transform to identify decay rates in the seismic signal."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2026-02-13T04:46:00.200941Z",
     "iopub.status.busy": "2026-02-13T04:46:00.200581Z",
     "iopub.status.idle": "2026-02-13T04:46:00.214828Z",
     "shell.execute_reply": "2026-02-13T04:46:00.214412Z"
    }
   },
   "outputs": [
    {
     "ename": "NameError",
     "evalue": "name 'ts_far' is not defined",
     "output_type": "error",
     "traceback": [
      "\u001b[31m---------------------------------------------------------------------------\u001b[39m",
      "\u001b[31mNameError\u001b[39m                                 Traceback (most recent call last)",
      "\u001b[36mCell\u001b[39m\u001b[36m \u001b[39m\u001b[32mIn[4]\u001b[39m\u001b[32m, line 2\u001b[39m\n\u001b[32m      1\u001b[39m \u001b[38;5;66;03m# Apply STLT to detect damping (geometric spreading + attenuation)\u001b[39;00m\n\u001b[32m----> \u001b[39m\u001b[32m2\u001b[39m stlt_result = \u001b[43mts_far\u001b[49m.stlt(fftlength=\u001b[32m1.0\u001b[39m, overlap=\u001b[32m0.5\u001b[39m)\n\u001b[32m      4\u001b[39m \u001b[38;5;28mprint\u001b[39m(\u001b[33mf\u001b[39m\u001b[33m\"\u001b[39m\u001b[33mSTLT result shape: \u001b[39m\u001b[38;5;132;01m{\u001b[39;00mstlt_result.shape\u001b[38;5;132;01m}\u001b[39;00m\u001b[33m\"\u001b[39m)\n\u001b[32m      5\u001b[39m \u001b[38;5;28mprint\u001b[39m(\u001b[33m\"\u001b[39m\u001b[33mUse STLT to identify decay rates (σ) at different frequencies (ω)\u001b[39m\u001b[33m\"\u001b[39m)\n",
      "\u001b[31mNameError\u001b[39m: name 'ts_far' is not defined"
     ]
    }
   ],
   "source": [
    "# Apply STLT to detect damping (geometric spreading + attenuation)\n",
    "stlt_result = ts_far.stlt(fftlength=1.0, overlap=0.5)\n",
    "\n",
    "print(f\"STLT result shape: {stlt_result.shape}\")\n",
    "print(\"Use STLT to identify decay rates (σ) at different frequencies (ω)\")\n",
    "print(\"Note: Actual visualization would show σ-ω plane with decay rate information\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Step 4: Batch Processing with FieldList\n",
    "\n",
    "Process multiple spatial slices in parallel using FieldList."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2026-02-13T04:46:00.217046Z",
     "iopub.status.busy": "2026-02-13T04:46:00.216933Z",
     "iopub.status.idle": "2026-02-13T04:46:00.231121Z",
     "shell.execute_reply": "2026-02-13T04:46:00.230721Z"
    }
   },
   "outputs": [
    {
     "ename": "NameError",
     "evalue": "name 'field_seismic' is not defined",
     "output_type": "error",
     "traceback": [
      "\u001b[31m---------------------------------------------------------------------------\u001b[39m",
      "\u001b[31mNameError\u001b[39m                                 Traceback (most recent call last)",
      "\u001b[36mCell\u001b[39m\u001b[36m \u001b[39m\u001b[32mIn[5]\u001b[39m\u001b[32m, line 3\u001b[39m\n\u001b[32m      1\u001b[39m \u001b[38;5;66;03m# Extract horizontal slices at different depths\u001b[39;00m\n\u001b[32m      2\u001b[39m slices_at_depths = [\n\u001b[32m----> \u001b[39m\u001b[32m3\u001b[39m     \u001b[43mfield_seismic\u001b[49m[:, :, :, iz] \u001b[38;5;28;01mfor\u001b[39;00m iz \u001b[38;5;129;01min\u001b[39;00m \u001b[38;5;28mrange\u001b[39m(nz)\n\u001b[32m      4\u001b[39m ]\n\u001b[32m      6\u001b[39m \u001b[38;5;66;03m# Create FieldList\u001b[39;00m\n\u001b[32m      7\u001b[39m field_list = FieldList(slices_at_depths, name=\u001b[33m'\u001b[39m\u001b[33mDepth Slices\u001b[39m\u001b[33m'\u001b[39m)\n",
      "\u001b[31mNameError\u001b[39m: name 'field_seismic' is not defined"
     ]
    }
   ],
   "source": [
    "# Extract horizontal slices at different depths\n",
    "slices_at_depths = [\n",
    "    field_seismic[:, :, :, iz] for iz in range(nz)\n",
    "]\n",
    "\n",
    "# Create FieldList\n",
    "field_list = FieldList(slices_at_depths, name='Depth Slices')\n",
    "\n",
    "print(f\"Created FieldList with {len(field_list)} depth slices\")\n",
    "print(f\"Each slice shape: {field_list[0].shape}\")\n",
    "\n",
    "# Batch operation: compute PSD at each depth\n",
    "# (This would be a real batch operation in practice)\n",
    "print(\"\\nBatch processing workflow:\")\n",
    "print(\"  1. Extract slices → FieldList\")\n",
    "print(\"  2. Apply transform → [field.fft_time() for field in field_list]\")\n",
    "print(\"  3. Aggregate results → stack or average\")\n",
    "print(\"  4. Reconstruct Field → combine processed slices\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Step 5: Reconstruct Field from Processed Data\n",
    "\n",
    "After analysis, reconstruct the Field structure to maintain 4D organization."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2026-02-13T04:46:00.232732Z",
     "iopub.status.busy": "2026-02-13T04:46:00.232623Z",
     "iopub.status.idle": "2026-02-13T04:46:00.246378Z",
     "shell.execute_reply": "2026-02-13T04:46:00.245900Z"
    }
   },
   "outputs": [
    {
     "ename": "NameError",
     "evalue": "name 'field_seismic' is not defined",
     "output_type": "error",
     "traceback": [
      "\u001b[31m---------------------------------------------------------------------------\u001b[39m",
      "\u001b[31mNameError\u001b[39m                                 Traceback (most recent call last)",
      "\u001b[36mCell\u001b[39m\u001b[36m \u001b[39m\u001b[32mIn[6]\u001b[39m\u001b[32m, line 2\u001b[39m\n\u001b[32m      1\u001b[39m \u001b[38;5;66;03m# Example: FFT in time, then reconstruct\u001b[39;00m\n\u001b[32m----> \u001b[39m\u001b[32m2\u001b[39m field_freq = \u001b[43mfield_seismic\u001b[49m.fft_time()\n\u001b[32m      4\u001b[39m \u001b[38;5;28mprint\u001b[39m(\u001b[33mf\u001b[39m\u001b[33m\"\u001b[39m\u001b[33mFrequency-domain field: \u001b[39m\u001b[38;5;132;01m{\u001b[39;00mfield_freq.shape\u001b[38;5;132;01m}\u001b[39;00m\u001b[33m\"\u001b[39m)\n\u001b[32m      5\u001b[39m \u001b[38;5;28mprint\u001b[39m(\u001b[33mf\u001b[39m\u001b[33m\"\u001b[39m\u001b[33mTime domain: \u001b[39m\u001b[38;5;132;01m{\u001b[39;00mfield_freq.time_domain\u001b[38;5;132;01m}\u001b[39;00m\u001b[33m\"\u001b[39m)\n",
      "\u001b[31mNameError\u001b[39m: name 'field_seismic' is not defined"
     ]
    }
   ],
   "source": [
    "# Example: FFT in time, then reconstruct\n",
    "field_freq = field_seismic.fft_time()\n",
    "\n",
    "print(f\"Frequency-domain field: {field_freq.shape}\")\n",
    "print(f\"Time domain: {field_freq.time_domain}\")\n",
    "\n",
    "# Inverse transform\n",
    "field_reconstructed = field_freq.ifft_time()\n",
    "\n",
    "# Verify reconstruction\n",
    "max_error = np.max(np.abs(field_seismic.value - field_reconstructed.value))\n",
    "print(f\"\\nReconstruction error: {max_error:.2e} m\")\n",
    "print(\"4D structure preserved through FFT → IFFT cycle ✓\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Summary: Field × Advanced Analysis Best Practices\n",
    "\n",
    "### Workflow Pattern\n",
    "\n",
    "```\n",
    "ScalarField (4D)\n",
    "    ↓ extract\n",
    "TimeSeries (1D) → Advanced Analysis (HHT, STLT, Wavelet)\n",
    "    ↓ results\n",
    "Metrics / Features\n",
    "    ↓ aggregate\n",
    "ScalarField (4D) ← Reconstructed\n",
    "```\n",
    "\n",
    "### Key Techniques\n",
    "\n",
    "1. **Extraction**: `field[:, x, y, z].to_timeseries()` for point analysis\n",
    "2. **Batch Processing**: Use FieldList for parallel operations\n",
    "3. **Transform Cycle**: `fft_time()` → process → `ifft_time()` preserves 4D\n",
    "4. **Slicing**: Maintain 4D structure even when selecting single indices\n",
    "\n",
    "### When to Use What\n",
    "\n",
    "- **Point analysis**: Extract TimeSeries, apply HHT/STLT/Wavelet\n",
    "- **Spatial patterns**: Use `fft_space()` for k-space analysis\n",
    "- **Batch operations**: FieldList for multiple realizations\n",
    "- **Full 4D transforms**: `fft_time()` + `fft_space()` for frequency-wavenumber"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.12"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
