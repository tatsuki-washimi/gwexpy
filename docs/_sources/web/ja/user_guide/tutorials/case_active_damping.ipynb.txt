{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 6自由度アクティブ防振装置のアクティブダンピング (非コロケート配置)\n",
    "\n",
    "[![Open In Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/tatsuki-washimi/gwexpy/blob/main/docs/web/en/user_guide/tutorials/case_active_damping.ipynb)\n",
    "\n",
    "このチュートリアルでは、`gwexpy` と `python-control` を組み合わせて、多自由度（MIMO）システムのシミュレーション、システム同定、そして制御系設計を行う一連の流れを実演します。\n",
    "\n",
    "**シナリオ:**\n",
    "3つの足で支持された正三角形の防振台（6自由度剛体）を想定します。\n",
    "今回は、**アクチュエータとセンサーの位置が異なる（非コロケート）** 構成を扱います。\n",
    "*   **アクチュエータ**: 3つの足の位置（支持点）に設置 ($0^\\circ, 120^\\circ, 240^\\circ$)\n",
    "*   **センサー**: 足と足の中間地点に設置 ($60^\\circ, 180^\\circ, 300^\\circ$)\n",
    "\n",
    "このように入出力位置がずれている場合、単純な各軸独立制御ではうまくいかないため、**モード空間（Modal Space）** での制御器設計を行います。\n",
    "\n",
    "**ステップ:**\n",
    "1.  **物理モデルの構築**: センサー・アクチュエータ配置を考慮した状態空間モデルを作成します。\n",
    "2.  **MIMO伝達関数の測定**: `FrequencySeriesMatrix` で非対角成分を含む伝達関数行列を可視化します。\n",
    "3.  **システム同定**: 物理パラメータと幾何学配置から制御用モデルを定義します。\n",
    "4.  **ダンピング制御器の設計**: センサー信号をモード座標に変換し、モードごとにダンピングをかける「モード制御」を設計します。\n",
    "5.  **閉ループ検証**: インパルス応答とASD比較により制振性能を確認します。\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2026-01-25T11:54:42.772834Z",
     "iopub.status.busy": "2026-01-25T11:54:42.772733Z",
     "iopub.status.idle": "2026-01-25T11:54:45.678898Z",
     "shell.execute_reply": "2026-01-25T11:54:45.678054Z"
    }
   },
   "outputs": [],
   "source": [
    "import control\n",
    "import matplotlib.pyplot as plt\n",
    "import numpy as np\n",
    "from scipy import signal\n",
    "\n",
    "from gwexpy import TimeSeries, TimeSeriesDict\n",
    "from gwexpy.frequencyseries import FrequencySeriesMatrix"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 1. 6自由度アクティブ防振装置のシミュレーション (Plant Model)\n",
    "\n",
    "剛体の運動方程式 $M \\ddot{q} + C \\dot{q} + K q = F$ を定義します。\n",
    "ここでは垂直3自由度（$z, \\theta_x, \\theta_y$）に焦点を当てます。\n",
    "\n",
    "**座標変換:**\n",
    "モード座標 $q = [z, \\theta_x, \\theta_y]^T$ に対し、\n",
    "*   アクチュエータ物理座標 $p_{act}$: $0^\\circ, 120^\\circ, 240^\\circ$\n",
    "*   センサー物理座標 $p_{sen}$: $60^\\circ, 180^\\circ, 300^\\circ$\n",
    "\n",
    "それぞれの変換行列 $T_{act}, T_{sen}$ を定義し、状態空間モデルに組み込みます。\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2026-01-25T11:54:45.681797Z",
     "iopub.status.busy": "2026-01-25T11:54:45.681268Z",
     "iopub.status.idle": "2026-01-25T11:54:45.688194Z",
     "shell.execute_reply": "2026-01-25T11:54:45.687613Z"
    }
   },
   "outputs": [],
   "source": [
    "#\n",
    "m = 100.0 # Mass [kg]\n",
    "I_x = 20.0 # Moment of inertia [kg m^2]\n",
    "I_y = 20.0\n",
    "\n",
    "# ( Position = Position)\n",
    "k_leg = 2000.0 # Spring constant [N/m]\n",
    "c_leg = 0.20 # Damping coefficient [N s/m]\n",
    "\n",
    "# : R\n",
    "R = 0.5 # [m]\n",
    "\n",
    "# Set (deg -> rad)\n",
    "deg2rad = np.pi / 180.0\n",
    "# : Position\n",
    "angles_act = np.array([0, 120, 240]) * deg2rad\n",
    "# :\n",
    "angles_sen = np.array([60, 180, 300]) * deg2rad\n",
    "\n",
    "\n",
    "# CoordinatesTransformMatrix CreateFunction\n",
    "# p = T * q => [z_i] = [1, R*sin(th), -R*cos(th)] @ [z, tx, ty]\n",
    "def make_transform_matrix(angles, radius):\n",
    "    T = np.zeros((3, 3))\n",
    "    for i, ang in enumerate(angles):\n",
    "        T[i, 0] = 1.0\n",
    "        T[i, 1] = radius * np.sin(ang)\n",
    "        T[i, 2] = -radius * np.cos(ang)\n",
    "    return T\n",
    "\n",
    "\n",
    "T_act = make_transform_matrix(angles_act, R)\n",
    "T_sen = make_transform_matrix(angles_sen, R)\n",
    "\n",
    "print(\"Actuator Transform Matrix T_act:\")\n",
    "print(np.round(T_act, 2))\n",
    "print(\"Sensor Transform Matrix T_sen:\")\n",
    "print(np.round(T_sen, 2))\n",
    "\n",
    "# Space M, K, C Matrix\n",
    "M_modal = np.diag([m, I_x, I_y])\n",
    "\n",
    "# Space( Position) K, C\n",
    "K_phys = np.diag([k_leg, k_leg, k_leg])\n",
    "C_phys = np.diag([c_leg, c_leg, c_leg])\n",
    "\n",
    "# Space Projection: K_modal = T_act.T * K_phys * T_act\n",
    "# ( Position T_act )\n",
    "K_modal = T_act.T @ K_phys @ T_act\n",
    "C_modal = T_act.T @ C_phys @ T_act\n",
    "\n",
    "# State Space Create\n",
    "# x = [q, q_dot]^T\n",
    "A_sys = np.block(\n",
    "    [\n",
    "        [np.zeros((3, 3)), np.eye(3)],\n",
    "        [-np.linalg.inv(M_modal) @ K_modal, -np.linalg.inv(M_modal) @ C_modal],\n",
    "    ]\n",
    ")\n",
    "B_sys_modal = np.block([[np.zeros((3, 3))], [np.linalg.inv(M_modal)]])\n",
    "C_sys_modal = np.block([np.eye(3), np.zeros((3, 3))])\n",
    "D_sys = np.zeros((3, 3))\n",
    "\n",
    "# Coordinates Transform\n",
    "# Input: Actuator Forces u (at angles_act) -> Generalized Force Q = T_act.T * u\n",
    "# Output: Sensor Displacements y (at angles_sen) -> y = T_sen * q\n",
    "B_sys = B_sys_modal @ T_act.T\n",
    "C_sys = T_sen @ C_sys_modal\n",
    "\n",
    "sys = control.StateSpace(\n",
    "    A_sys,\n",
    "    B_sys,\n",
    "    C_sys,\n",
    "    D_sys,\n",
    "    inputs=[\"ACT1\", \"ACT2\", \"ACT3\"],\n",
    "    outputs=[\"SEN1\", \"SEN2\", \"SEN3\"],\n",
    ")\n",
    "print(sys)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 2. MIMO伝達関数の測定\n",
    "\n",
    "センサーとアクチュエータの位置が異なるため、対角成分（ACT1->SEN1）だけでなく、非対角成分にも強い応答が現れるはずです。\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2026-01-25T11:54:45.712916Z",
     "iopub.status.busy": "2026-01-25T11:54:45.712411Z",
     "iopub.status.idle": "2026-01-25T11:54:48.096722Z",
     "shell.execute_reply": "2026-01-25T11:54:48.096303Z"
    }
   },
   "outputs": [],
   "source": [
    "fs = 64\n",
    "duration = 1024.0\n",
    "t = np.arange(0, duration, 1 / fs)\n",
    "n_samples = len(t)\n",
    "\n",
    "# Signal: 3ch Noise\n",
    "np.random.seed(0)\n",
    "u_data = np.random.normal(0, 1.0, (3, n_samples))\n",
    "\n",
    "# time / durationResponse\n",
    "time_response = control.forced_response(sys, T=t, U=u_data)\n",
    "\n",
    "# gwexpy TimeSeriesDict\n",
    "tsd_input = TimeSeriesDict(\n",
    "    {\n",
    "        f\"ACT{i + 1}\": TimeSeries(\n",
    "            u_data[i], t0=0, sample_rate=fs, name=f\"Actuator {i + 1}\", unit=\"N\"\n",
    "        )\n",
    "        for i in range(3)\n",
    "    }\n",
    ")\n",
    "\n",
    "tsd_output = TimeSeriesDict.from_control(time_response, unit=\"m\")\n",
    "for i in range(3):\n",
    "    tsd_output[f\"SEN{i + 1}\"].name = f\"Sensor {i + 1}\"\n",
    "\n",
    "# MIMO TF Calculate\n",
    "tfs = [\n",
    "    [\n",
    "        tsd_input[f\"ACT{j + 1}\"].transfer_function(\n",
    "            tsd_output[f\"SEN{i + 1}\"], fftlength=5\n",
    "        )\n",
    "        for j in range(3)\n",
    "    ]\n",
    "    for i in range(3)\n",
    "]\n",
    "\n",
    "tf_matrix = FrequencySeriesMatrix(\n",
    "    [[tf.value for tf in row] for row in tfs], frequencies=tfs[0][0].frequencies\n",
    ")\n",
    "\n",
    "tf_data = tf_matrix.value\n",
    "freqs = tf_matrix.frequencies\n",
    "\n",
    "# plot\n",
    "tf_matrix.abs().plot(figsize=(12, 10), xscale=\"log\", yscale=\"log\").suptitle(\n",
    "    \"MIMO Transfer Function Matrix (Non-collocated)\\n\\n\"\n",
    ")\n",
    "plt.tight_layout()\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 3 & 4. モード制御系の設計 (Modal Control Design)\n",
    "\n",
    "アクチュエータとセンサーの位置が一致していないため、単純な分散制御（$F_i \\propto \\dot{y}_i$）では不安定になる恐れがあります。\n",
    "そこで、**座標変換行列を用いてセンサー信号からモード変位を推定し、モード空間でダンピングをかけた後、アクチュエータ推力に分配する** 手法を採ります。\n",
    "\n",
    "**制御フロー:**\n",
    "1.  **Sensing**: センサー出力 $y$ からモード変位 $q$ を推定\n",
    "    $$ q_{est} = T_{sen}^{-1} y $$\n",
    "2.  **Modal Damping**: モードごとに擬似微分フィルタ $K(s)$ を適用し、モード力 $F_{modal}$ を計算\n",
    "    $$ F_{modal} = -K_{modal}(s) q_{est} $$\n",
    "3.  **Actuation**: モード力 $F_{modal}$ をアクチュエータ推力 $u$ に分配\n",
    "    $$ u = (T_{act}^T)^{-1} F_{modal} $$\n",
    "\n",
    "全体として、コントローラ $K_{MIMO}$ は以下のようになります。\n",
    "$$ K_{MIMO}(s) = (T_{act}^T)^{-1} \\cdot \\mathrm{diag}(K_{z}(s), K_{\\theta x}(s), K_{\\theta y}(s)) \\cdot T_{sen}^{-1} $$\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2026-01-25T11:54:48.100032Z",
     "iopub.status.busy": "2026-01-25T11:54:48.099914Z",
     "iopub.status.idle": "2026-01-25T11:54:48.107894Z",
     "shell.execute_reply": "2026-01-25T11:54:48.107361Z"
    }
   },
   "outputs": [],
   "source": [
    "# --- 1. Sensing & Actuation Matrix ---\n",
    "# Estimated TransformMatrix （ ）\n",
    "# Sensing Matrix: y -> q\n",
    "S_sensing = np.linalg.inv(T_sen)\n",
    "\n",
    "# Actuation Matrix: F_modal -> u\n",
    "# F_modal = T_act.T * u => u = inv(T_act.T) * F_modal\n",
    "D_actuation = np.linalg.inv(T_act.T)\n",
    "\n",
    "print(\"Sensing Matrix (Sensor -> Mode):\")\n",
    "print(np.round(S_sensing, 2))\n",
    "print(\"Actuation Matrix (Mode Force -> Actuator):\")\n",
    "print(np.round(D_actuation, 2))\n",
    "\n",
    "# --- 2. Modal Damping Filter Design ---\n",
    "# Mode DampingGain Set\n",
    "# Mode(z) Mode(tx, ty) Gain 、\n",
    "# Gain Filter 。\n",
    "gain = 1000.0 # Modal Damping Gain\n",
    "fc_l = 0.1\n",
    "fc_h = 20.0\n",
    "w_l = 2 * np.pi * fc_l\n",
    "w_h = 2 * np.pi * fc_h\n",
    "\n",
    "s = control.tf(\"s\")\n",
    "K_filter = gain * s / ((1 + s / w_l) * (1 + s / w_h))\n",
    "\n",
    "# Matrix (3Modeminutes)\n",
    "K_modal_diag = []\n",
    "for _ in range(3):\n",
    "    K_modal_diag.append(control.ss(K_filter))\n",
    "\n",
    "# control.append do 、 。\n",
    "# State Space do 、\n",
    "# python-control K_MIMO 。\n",
    "\n",
    "# K_modal_block: 3-input 3-output Diagonal System\n",
    "# [ K_f 0 0 ]\n",
    "# [ 0 K_f 0 ]\n",
    "# [ 0 0 K_f ]\n",
    "K_modal_block = control.append(K_modal_diag[0], K_modal_diag[1], K_modal_diag[2])\n",
    "\n",
    "\n",
    "# --- 3. MIMO Controller Construction ---\n",
    "# K_MIMO = D_actuation * K_modal_block * S_sensing\n",
    "# python-control ConstantMatrix SS\n",
    "\n",
    "# S_sensing (Static Gain) * y\n",
    "# K_modal_block * (S_sensing * y)\n",
    "# D_actuation * (K_modal_block * S_sensing * y)\n",
    "\n",
    "# Note: Matrix 。Control object 。\n",
    "# Sys2 * Sys1 Out <--- Sys2 <--- Sys1 <--- In\n",
    "# : u = D * K * S * y\n",
    "# Code: K_mimo = D * K * S\n",
    "# D, S numpy array。control.ss(D) Transform 。\n",
    "\n",
    "K_mimo = D_actuation * K_modal_block * S_sensing\n",
    "\n",
    "print(\"MIMO Controller States:\", K_mimo.nstates)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 5 & 6. 閉ループ検証 (インパルス応答 & ASD)\n",
    "\n",
    "構築したモード制御系を用いて、閉ループシミュレーションを行います。\n",
    "アクチュエータ1へのインパルス外乱、および全軸への定常地面振動に対する応答を確認します。\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2026-01-25T11:54:48.109107Z",
     "iopub.status.busy": "2026-01-25T11:54:48.109002Z",
     "iopub.status.idle": "2026-01-25T11:54:49.961834Z",
     "shell.execute_reply": "2026-01-25T11:54:49.960794Z"
    }
   },
   "outputs": [],
   "source": [
    "#\n",
    "sys_cl = control.feedback(sys, K_mimo, sign=-1)\n",
    "\n",
    "# --- Impulse Response ---\n",
    "u_impulse = np.zeros((3, n_samples))\n",
    "u_impulse[0, 100] = 100.0 * fs # Impulse on Actuator 1\n",
    "\n",
    "resp_ol = control.forced_response(sys, T=t, U=u_impulse)\n",
    "resp_cl = control.forced_response(sys_cl, T=t, U=u_impulse)\n",
    "\n",
    "fig, axes = plt.subplots(3, 1, figsize=(10, 8), sharex=True)\n",
    "for i in range(3):\n",
    "    ax = axes[i]\n",
    "    ax.plot(t, resp_ol.outputs[i], label=\"Open Loop\", alpha=0.6)\n",
    "    ax.plot(t, resp_cl.outputs[i], label=\"Closed Loop (Modal Control)\", linewidth=2)\n",
    "    ax.set_ylabel(f\"SEN{i + 1}\")\n",
    "    ax.grid(True)\n",
    "    if i == 0:\n",
    "        ax.legend(loc=\"upper right\")\n",
    "axes[2].set_xlabel(\"Time [s]\")\n",
    "axes[0].set_title(\"Impulse Response Comparison (Impulse on ACT1)\")\n",
    "plt.show()\n",
    "\n",
    "# --- ASD Comparison ---\n",
    "# Ground Vibration Simulation\n",
    "np.random.seed(42)\n",
    "wn = np.random.normal(0, 1.0, (3, n_samples))\n",
    "b, a = signal.butter(1, 5.0, fs=fs, btype=\"low\")\n",
    "dist = signal.lfilter(b, a, wn) * 50.0\n",
    "\n",
    "resp_ol_noise = control.forced_response(sys, T=t, U=dist)\n",
    "resp_cl_noise = control.forced_response(sys_cl, T=t, U=dist)\n",
    "\n",
    "tsd_ol = TimeSeriesDict.from_control(resp_ol_noise)\n",
    "for i in range(3):\n",
    "    tsd_ol[list(tsd_ol.keys())[i]].name = f\"SEN{i + 1}\"\n",
    "tsd_ol = TimeSeriesDict({ts.name: ts for ts in tsd_ol.values()})\n",
    "tsd_cl = TimeSeriesDict.from_control(resp_cl_noise)\n",
    "for i in range(3):\n",
    "    tsd_cl[list(tsd_cl.keys())[i]].name = f\"SEN{i + 1}\"\n",
    "tsd_cl = TimeSeriesDict({ts.name: ts for ts in tsd_cl.values()})\n",
    "\n",
    "fig, axes = plt.subplots(1, 3, figsize=(18, 5), sharey=True)\n",
    "for i in range(3):\n",
    "    ax = axes[i]\n",
    "    asd_ol = (\n",
    "        tsd_ol[f\"SEN{i + 1}\"].asd(fftlength=16, overlap=8, method=\"welch\").crop(0.1, 10)\n",
    "    )\n",
    "    asd_cl = (\n",
    "        tsd_cl[f\"SEN{i + 1}\"].asd(fftlength=16, overlap=8, method=\"welch\").crop(0.1, 10)\n",
    "    )\n",
    "\n",
    "    ax.loglog(asd_ol, label=\"Open Loop\", alpha=0.8)\n",
    "    ax.loglog(asd_cl, label=\"Closed Loop\", linewidth=2)\n",
    "    ax.set_title(f\"Sensor {i + 1} ASD\")\n",
    "    ax.set_xlabel(\"Frequency [Hz]\")\n",
    "    ax.grid(True, which=\"both\", alpha=0.5)\n",
    "    if i == 0:\n",
    "        ax.set_ylabel(r\"ASD [$\\mathrm{m}/\\sqrt{\\mathrm{Hz}}$]\")\n",
    "        ax.legend()\n",
    "plt.tight_layout()\n",
    "plt.show()\n",
    "\n",
    "# Position 、\n",
    "# ModeCoordinatesTransform Damping 。"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "base",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.12"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}