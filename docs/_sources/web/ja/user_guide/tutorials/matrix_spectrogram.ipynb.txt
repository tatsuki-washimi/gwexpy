{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# SpectrogramMatrix Tutorial\n",
    "\n",
    "[![Open In Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/tatsuki-washimi/gwexpy/blob/main/docs/web/en/user_guide/tutorials/matrix_spectrogram.ipynb)\n",
    "\n",
    "このノートブックでは `gwexpy` の `SpectrogramMatrix` クラスの基本的な使い方を紹介します。\n",
    "\n",
    "`SpectrogramMatrix` は、複数の `gwpy.spectrogram.Spectrogram` オブジェクトを 3次元 (Batch, Time, Frequency) の行列として効率的に扱うためのクラスです。`numpy.ndarray` を継承しており、高速な数値計算や PyTorch/CuPy との連携が可能です。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2026-02-15T03:33:51.583887Z",
     "iopub.status.busy": "2026-02-15T03:33:51.583778Z",
     "iopub.status.idle": "2026-02-15T03:33:53.914801Z",
     "shell.execute_reply": "2026-02-15T03:33:53.913792Z"
    }
   },
   "outputs": [],
   "source": [
    "import astropy.units as u\n",
    "import matplotlib.pyplot as plt\n",
    "import numpy as np\n",
    "\n",
    "from gwexpy.timeseries import TimeSeriesMatrix\n",
    "\n",
    "#\n",
    "np.random.seed(42)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 1. データの準備\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2026-02-15T03:33:53.919122Z",
     "iopub.status.busy": "2026-02-15T03:33:53.918675Z",
     "iopub.status.idle": "2026-02-15T03:34:07.526818Z",
     "shell.execute_reply": "2026-02-15T03:34:07.526277Z"
    }
   },
   "outputs": [],
   "source": [
    "rng = np.random.default_rng(0)\n",
    "\n",
    "# SampleSet\n",
    "n = 512\n",
    "dt = (1 / 128) * u.s\n",
    "t0 = 0 * u.s\n",
    "\n",
    "t = (np.arange(n) * dt).to_value(u.s)\n",
    "\n",
    "tone50 = np.sin(2 * np.pi * 50 * t)\n",
    "tone20 = np.sin(2 * np.pi * 20 * t + 0.3)\n",
    "\n",
    "data = np.empty((2, 2, n), dtype=float)\n",
    "data[0, 0] = 0.5 * tone50 + 0.05 * rng.normal(size=n)\n",
    "data[0, 1] = 0.5 * tone20 + 0.05 * rng.normal(size=n)\n",
    "data[1, 0] = 0.3 * tone50 + 0.3 * tone20 + 0.05 * rng.normal(size=n)\n",
    "data[1, 1] = 0.2 * tone50 - 0.4 * tone20 + 0.05 * rng.normal(size=n)\n",
    "\n",
    "units = np.full((2, 2), u.V)\n",
    "names = [[\"ch00\", \"ch01\"], [\"ch10\", \"ch11\"]]\n",
    "channels = [[\"X:A\", \"X:B\"], [\"Y:A\", \"Y:B\"]]\n",
    "\n",
    "tsm = TimeSeriesMatrix(\n",
    "    data,\n",
    "    dt=dt,\n",
    "    t0=t0,\n",
    "    units=units,\n",
    "    names=names,\n",
    "    channels=channels,\n",
    "    rows={\"r0\": {\"name\": \"row0\"}, \"r1\": {\"name\": \"row1\"}},\n",
    "    cols={\"c0\": {\"name\": \"col0\"}, \"c1\": {\"name\": \"col1\"}},\n",
    "    name=\"demo\",\n",
    ")\n",
    "\n",
    "display(tsm)\n",
    "tsm.plot()\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 2. SpectrogramMatrix の作成\n",
    "\n",
    "`SpectrogramList` の `to_matrix()` メソッドを使用すると、全てのスペクトログラムが一つの `SpectrogramMatrix` にスタックされます。\n",
    "これにより、形状が `(N, Time, Frequency)` の3次元配列が得られます。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2026-02-15T03:34:07.533235Z",
     "iopub.status.busy": "2026-02-15T03:34:07.533097Z",
     "iopub.status.idle": "2026-02-15T03:34:20.527490Z",
     "shell.execute_reply": "2026-02-15T03:34:20.526631Z"
    }
   },
   "outputs": [],
   "source": [
    "spec_matrix = tsm.spectrogram(2, fftlength=0.5, overlap=0.25)\n",
    "\n",
    "print(\"Type:\", type(spec_matrix))\n",
    "print(\"Shape:\", spec_matrix.shape) # (Batch, Time, Freq)\n",
    "spec_matrix.plot();"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 属性へのアクセス\n",
    "`SpectrogramMatrix` は元のスペクトログラムの時間軸や周波数軸の情報を保持しています。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2026-02-15T03:34:20.530849Z",
     "iopub.status.busy": "2026-02-15T03:34:20.530731Z",
     "iopub.status.idle": "2026-02-15T03:34:20.533778Z",
     "shell.execute_reply": "2026-02-15T03:34:20.533331Z"
    }
   },
   "outputs": [],
   "source": [
    "print(\"Time axis (first 5):\", spec_matrix.times[:5])\n",
    "print(\"Freq axis (first 5):\", spec_matrix.frequencies[:5])\n",
    "print(\"Unit:\", spec_matrix.unit)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 3. 数値計算と統計\n",
    "\n",
    "`SpectrogramMatrix` は `numpy.ndarray` のサブクラスであるため、Numpy の関数をそのまま適用できます。\n",
    "また、`mean()` などのメソッドも利用可能です。\n",
    "\n",
    "例えば、全チャネル（バッチ方向）の平均スペクトログラムを計算してみましょう。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2026-02-15T03:34:20.535129Z",
     "iopub.status.busy": "2026-02-15T03:34:20.535010Z",
     "iopub.status.idle": "2026-02-15T03:34:20.537321Z",
     "shell.execute_reply": "2026-02-15T03:34:20.536915Z"
    }
   },
   "outputs": [],
   "source": [
    "# axis=0 (BatchAxis) Mean\n",
    "mean_spectrogram_data = spec_matrix.mean(axis=0)\n",
    "\n",
    "print(\"Mean Data Shape:\", mean_spectrogram_data.shape)\n",
    "# Result (Time, Freq) 2DimensionArray"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 4. プロット\n",
    "\n",
    "`plot()` メソッドを使用すると、データを可視化できます。\n",
    "3次元データ（Batch, Time, Freq）に対して `plot()` を呼び出すと、デフォルトでは**バッチ方向の平均**がプロットされます。\n",
    "これは複数のイベントの平均的な特徴を確認するのに便利です。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2026-02-15T03:34:20.538447Z",
     "iopub.status.busy": "2026-02-15T03:34:20.538335Z",
     "iopub.status.idle": "2026-02-15T03:35:05.005279Z",
     "shell.execute_reply": "2026-02-15T03:35:05.003581Z"
    }
   },
   "outputs": [],
   "source": [
    "plot = spec_matrix.plot(title=\"Mean Spectrogram (All Channels)\")\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "特定のチャネルだけをプロットしたい場合は、`monitor` 引数にインデックスを指定します。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2026-02-15T03:35:05.007813Z",
     "iopub.status.busy": "2026-02-15T03:35:05.007502Z",
     "iopub.status.idle": "2026-02-15T03:35:28.728820Z",
     "shell.execute_reply": "2026-02-15T03:35:28.727391Z"
    }
   },
   "outputs": [],
   "source": [
    "# (Channel_0) Plot\n",
    "plot0 = spec_matrix.plot(monitor=0, title=\"Channel 0 Spectrogram\")\n",
    "plot0.show()\n",
    "\n",
    "# 5 (Channel_5) Plot\n",
    "plot5 = spec_matrix.plot(monitor=3, title=\"Channel 5 Spectrogram\")\n",
    "plot5.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 5. 外部ライブラリとの連携\n",
    "\n",
    "機械学習やGPU計算のために、PyTorch や CuPy のテンソルへ簡単に変換できます。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2026-02-15T03:35:28.730841Z",
     "iopub.status.busy": "2026-02-15T03:35:28.730691Z",
     "iopub.status.idle": "2026-02-15T03:35:29.687074Z",
     "shell.execute_reply": "2026-02-15T03:35:29.685965Z"
    }
   },
   "outputs": [],
   "source": [
    "# PyTorch Tensor Transform\n",
    "try:\n",
    "    import torch\n",
    "\n",
    "    _ = torch\n",
    "    torch_tensor = spec_matrix.to_torch()\n",
    "    print(\"PyTorch Tensor:\", type(torch_tensor))\n",
    "    print(\"Shape:\", torch_tensor.shape)\n",
    "except ImportError:\n",
    "    print(\"PyTorch is not installed.\")\n",
    "\n",
    "# CuPy Array Transform（CUDA ）\n",
    "from gwexpy.interop import is_cupy_available\n",
    "\n",
    "if is_cupy_available():\n",
    "    cupy_array = spec_matrix.to_cupy()\n",
    "    print(\"CuPy Array:\", type(cupy_array))\n",
    "    print(\"Shape:\", cupy_array.shape)\n",
    "else:\n",
    "    pass"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## まとめ\n",
    "\n",
    "- **`SpectrogramMatrix`** は `SpectrogramList.to_matrix()` で作成できます。\n",
    "- 3次元配列 `(Batch, Time, Freq)` としてデータを保持します。\n",
    "- `mean()` や `plot()` メソッドで、データの集約や可視化が簡単に行えます。\n",
    "- `to_torch()` などでディープラーニングフレームワークへデータを渡す際の中間形式としても有用です。"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "base",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.12"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}