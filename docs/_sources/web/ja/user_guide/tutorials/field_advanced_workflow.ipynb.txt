{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Field × 高度解析ワークフロー\n",
    "\n",
    "[![Open In Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/tatsuki-washimi/gwexpy/blob/main/docs/web/en/user_guide/tutorials/field_advanced_workflow.ipynb)\n",
    "\n",
    "このチュートリアルでは、ScalarField と高度な時間-周波数解析手法を組み合わせた実践的なワークフローを紹介します。\n",
    "\n",
    "## 学べること\n",
    "\n",
    "- ScalarField から時系列データを抽出して解析する\n",
    "- HHT、STLT、Wavelet 変換を適用する\n",
    "- 解析済みデータを Field 構造に再構成する\n",
    "- FieldList を使ったバッチ処理\n",
    "\n",
    "## ユースケース：地震アレイ解析\n",
    "\n",
    "各空間点が時間変動する地動を記録する3次元地震アレイを解析します。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2026-02-14T16:51:39.540096Z",
     "iopub.status.busy": "2026-02-14T16:51:39.539958Z",
     "iopub.status.idle": "2026-02-14T16:51:41.549726Z",
     "shell.execute_reply": "2026-02-14T16:51:41.548873Z"
    }
   },
   "outputs": [],
   "source": [
    "# Suppress warnings\n",
    "import warnings\n",
    "\n",
    "import matplotlib.pyplot as plt\n",
    "import numpy as np\n",
    "from astropy import units as u\n",
    "\n",
    "from gwexpy.fields import FieldList, ScalarField\n",
    "from gwexpy.timeseries import TimeSeries\n",
    "\n",
    "warnings.filterwarnings('ignore')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## ステップ 1：合成地震フィールドの作成\n",
    "\n",
    "3次元グリッドを伝搬する地震波による地動をシミュレートします。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2026-02-14T16:51:41.553833Z",
     "iopub.status.busy": "2026-02-14T16:51:41.553608Z",
     "iopub.status.idle": "2026-02-14T16:51:41.565471Z",
     "shell.execute_reply": "2026-02-14T16:51:41.564665Z"
    }
   },
   "outputs": [],
   "source": [
    "# Parameters\n",
    "nt, nx, ny, nz = 256, 8, 8, 4 # 256 time samples, 8×8×4 spatial grid\n",
    "fs = 100 # Hz\n",
    "duration = nt / fs\n",
    "\n",
    "# Create axis coordinates\n",
    "t_axis = np.arange(nt) * (1/fs) * u.s\n",
    "x_axis = np.arange(nx) * 10.0 * u.m # 10m spacing\n",
    "y_axis = np.arange(ny) * 10.0 * u.m\n",
    "z_axis = np.arange(nz) * 5.0 * u.m # 5m depth spacing\n",
    "\n",
    "# Simulate seismic wave (P-wave + surface wave)\n",
    "data = np.zeros((nt, nx, ny, nz))\n",
    "\n",
    "# P-wave (bulk wave, faster)\n",
    "v_p = 3000 # m/s\n",
    "f_p = 10 # Hz\n",
    "for ix in range(nx):\n",
    "    for iy in range(ny):\n",
    "        for iz in range(nz):\n",
    "            # Distance from source (corner)\n",
    "            dist = np.sqrt(x_axis[ix].value**2 + y_axis[iy].value**2 + z_axis[iz].value**2)\n",
    "            delay = dist / v_p\n",
    "            t_vals = t_axis.value\n",
    "\n",
    "            # P-wave with geometric spreading\n",
    "            amplitude_p = 1.0 / (dist + 1)\n",
    "            data[:, ix, iy, iz] += amplitude_p * np.sin(2*np.pi*f_p * (t_vals - delay)) * (t_vals > delay)\n",
    "\n",
    "# Surface wave (slower, stronger)\n",
    "v_s = 1500 # m/s\n",
    "f_s = 5 # Hz\n",
    "for ix in range(nx):\n",
    "    for iy in range(ny):\n",
    "        dist_surf = np.sqrt(x_axis[ix].value**2 + y_axis[iy].value**2)\n",
    "        delay_s = dist_surf / v_s\n",
    "        amplitude_s = 2.0 / (dist_surf + 1)\n",
    "        data[:, ix, iy, 0] += amplitude_s * np.sin(2*np.pi*f_s * (t_vals - delay_s)) * (t_vals > delay_s)\n",
    "\n",
    "# Add noise\n",
    "data += np.random.randn(*data.shape) * 0.1\n",
    "\n",
    "# Create ScalarField\n",
    "field_seismic = ScalarField(\n",
    "    data,\n",
    "    axis0=t_axis,\n",
    "    axis1=x_axis,\n",
    "    axis2=y_axis,\n",
    "    axis3=z_axis,\n",
    "    axis_names=['t', 'x', 'y', 'z'],\n",
    "    unit=u.m, # Ground displacement\n",
    "    name='Seismic Field',\n",
    ")\n",
    "\n",
    "print(f\"Created seismic field: {field_seismic.shape}\")\n",
    "print(f\"Time span: {duration:.2f} s\")\n",
    "print(f\"Spatial extent: {nx*10}m × {ny*10}m × {nz*5}m\")\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## ステップ 2：解析用の TimeSeries 抽出\n",
    "\n",
    "特定の空間位置から時系列データを抽出し、詳細な解析を行います。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2026-02-14T16:51:41.588617Z",
     "iopub.status.busy": "2026-02-14T16:51:41.588434Z",
     "iopub.status.idle": "2026-02-14T16:51:41.836661Z",
     "shell.execute_reply": "2026-02-14T16:51:41.835903Z"
    }
   },
   "outputs": [],
   "source": [
    "# Extract time-series at corner (near source) and far point\n",
    "slice_near = field_seismic[:, 1, 1, 0] # Near source (keeps 4D structure)\n",
    "slice_far = field_seismic[:, 6, 6, 0] # Far from source\n",
    "\n",
    "# Convert point-slices to 1D TimeSeries\n",
    "times = slice_near.axis(0).index\n",
    "ts_near = TimeSeries(slice_near.value[:, 0, 0, 0], times=times, unit=slice_near.unit, name='Near source')\n",
    "ts_far = TimeSeries(slice_far.value[:, 0, 0, 0], times=times, unit=slice_far.unit, name='Far point')\n",
    "\n",
    "# Plot\n",
    "fig, axes = plt.subplots(2, 1, figsize=(12, 6), sharex=True)\n",
    "\n",
    "axes[0].plot(ts_near.times.value, ts_near.value, linewidth=0.8)\n",
    "axes[0].set_ylabel('Displacement (m)')\n",
    "axes[0].set_title('Near Source (10m, 10m, 0m)')\n",
    "axes[0].grid(True, alpha=0.3)\n",
    "\n",
    "axes[1].plot(ts_far.times.value, ts_far.value, linewidth=0.8)\n",
    "axes[1].set_ylabel('Displacement (m)')\n",
    "axes[1].set_xlabel('Time (s)')\n",
    "axes[1].set_title('Far Point (60m, 60m, 0m)')\n",
    "axes[1].grid(True, alpha=0.3)\n",
    "\n",
    "plt.tight_layout()\n",
    "plt.show()\n",
    "\n",
    "print('Extracted TimeSeries for analysis')\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## ステップ 3：STLT による減衰検出\n",
    "\n",
    "Short-Time Laplace Transform を用いて、地震信号の減衰率を特定します。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2026-02-14T16:51:41.838797Z",
     "iopub.status.busy": "2026-02-14T16:51:41.838673Z",
     "iopub.status.idle": "2026-02-14T16:51:41.841950Z",
     "shell.execute_reply": "2026-02-14T16:51:41.841408Z"
    }
   },
   "outputs": [],
   "source": [
    "# Apply STLT to detect damping (geometric spreading + attenuation)\n",
    "stlt_result = ts_far.stlt(fftlength=1.0, overlap=0.5)\n",
    "\n",
    "print(f\"STLT result shape: {stlt_result.shape}\")\n",
    "print(\"Use STLT to identify decay rates (σ) at different frequencies (ω)\")\n",
    "print(\"Note: Actual visualization would show σ-ω plane with decay rate information\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## ステップ 4：FieldList によるバッチ処理\n",
    "\n",
    "FieldList を使用して、複数の空間スライスを並列的に処理します。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2026-02-14T16:51:41.843241Z",
     "iopub.status.busy": "2026-02-14T16:51:41.843123Z",
     "iopub.status.idle": "2026-02-14T16:51:41.846881Z",
     "shell.execute_reply": "2026-02-14T16:51:41.846463Z"
    }
   },
   "outputs": [],
   "source": [
    "# Extract horizontal slices at different depths\n",
    "slices_at_depths = [\n",
    "    field_seismic[:, :, :, iz] for iz in range(nz)\n",
    "]\n",
    "\n",
    "# Create FieldList\n",
    "field_list = FieldList(slices_at_depths)\n",
    "\n",
    "print(f\"Created FieldList with {len(field_list)} depth slices\")\n",
    "print(f\"Each slice shape: {field_list[0].shape}\")\n",
    "\n",
    "# Batch operation: compute PSD at each depth\n",
    "# (This would be a real batch operation in practice)\n",
    "print(\"\\nBatch processing workflow:\")\n",
    "print(\" 1. Extract slices → FieldList\")\n",
    "print(\" 2. Apply transform → [field.fft_time() for field in field_list]\")\n",
    "print(\" 3. Aggregate results → stack or average\")\n",
    "print(\" 4. Reconstruct Field → combine processed slices\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## ステップ 5：処理済みデータからの Field 再構成\n",
    "\n",
    "解析後、4次元構造を維持するために Field 構造を再構成します。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2026-02-14T16:51:41.848176Z",
     "iopub.status.busy": "2026-02-14T16:51:41.848070Z",
     "iopub.status.idle": "2026-02-14T16:51:41.853392Z",
     "shell.execute_reply": "2026-02-14T16:51:41.852951Z"
    }
   },
   "outputs": [],
   "source": [
    "# Example: FFT in time, then reconstruct\n",
    "field_freq = field_seismic.fft_time()\n",
    "\n",
    "print(f\"Frequency-domain field: {field_freq.shape}\")\n",
    "print(f\"Axis0 domain: {field_freq.axis0_domain}\")\n",
    "print(f\"Space domains: {field_freq.space_domains}\")\n",
    "\n",
    "# Inverse transform\n",
    "field_reconstructed = field_freq.ifft_time()\n",
    "\n",
    "# Verify reconstruction\n",
    "max_error = np.max(np.abs(field_seismic.value - field_reconstructed.value))\n",
    "print(f\"\\nReconstruction error: {max_error:.2e} m\")\n",
    "print(\"4D structure preserved through FFT → IFFT cycle ✓\")\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## まとめ：Field × 高度解析のベストプラクティス\n",
    "\n",
    "### ワークフローパターン\n",
    "\n",
    "```\n",
    "ScalarField (4D)\n",
    "    ↓ 抽出\n",
    "TimeSeries (1D) → 高度解析 (HHT, STLT, Wavelet)\n",
    "    ↓ 結果\n",
    "メトリクス / 特徴量\n",
    "    ↓ 集約\n",
    "ScalarField (4D) ← 再構成\n",
    "```\n",
    "\n",
    "### 主要テクニック\n",
    "\n",
    "1. **抽出**: `field[:, x, y, z].to_timeseries()` でポイント解析\n",
    "2. **バッチ処理**: FieldList で並列操作\n",
    "3. **変換サイクル**: `fft_time()` → 処理 → `ifft_time()` で4D構造を保持\n",
    "4. **スライシング**: 単一インデックス選択時でも4D構造を維持\n",
    "\n",
    "### 手法の使い分け\n",
    "\n",
    "- **ポイント解析**: TimeSeries を抽出し、HHT/STLT/Wavelet を適用\n",
    "- **空間パターン**: `fft_space()` で K空間解析\n",
    "- **バッチ操作**: FieldList で複数の実現値を処理\n",
    "- **全4D変換**: `fft_time()` + `fft_space()` で周波数-波数解析"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.12"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}