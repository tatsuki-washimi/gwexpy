{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Bruco (Brute force coherence) Pythonチュートリアル\n",
    "\n",
    "[![Open In Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/tatsuki-washimi/gwexpy/blob/main/docs/web/en/user_guide/tutorials/advanced_bruco.ipynb)\n",
    "\n",
    "Brucoは**「総当たりコヒーレンス（Brute force coherence）」**を計算するためのツールです。重力波検出器（LIGOやVirgo）の主チャンネル（ターゲット）と、多数の補助チャンネルとの間のコヒーレンスを計算し、ノイズ源を特定することを目的としています。\n",
    "\n",
    "#### 並列処理によるコヒーレンス計算\n",
    "\n",
    "Pythonの `multiprocessing` モジュールを使用して複数のCPUコアで並列実行されます。\n",
    "\n",
    "1. **タスク分割**: 全補助チャンネルリストをCPU数に応じて分割し、各プロセスに割り当てます。\n",
    "2. **データ取得と前処理**:\n",
    "* 各補助チャンネルのデータを取得します。\n",
    "* データが一定（フラット）の場合はスキップします。\n",
    "* サンプリングレートが出力要求レート (`outfs`) より高い場合、`decimate` 関数を用いてダウンサンプリングします。\n",
    "3. **コヒーレンス算出**:\n",
    "* 補助チャンネルのFFTとPSD（パワースペクトル密度）を計算します。\n",
    "* ターゲットチャンネルとのCSD（クロススペクトル密度）を計算します。\n",
    "* コヒーレンス  を以下の式で計算します：\n",
    "4. **Top N の選出**:\n",
    "* すべての周波数ビンについて、計算されたコヒーレンス値が既存の上位リスト（`top`）よりも高い場合、その値を更新します。これにより、全チャンネルの結果を保持するのではなく、相関の高い上位チャンネルのみを効率的に記録します。\n",
    "5. **結果の集約と出力**:\n",
    "* 各プロセスから返された `cohtab`（コヒーレンス値）と `idxtab`（チャンネルID）を結合・ソートし、最終的な上位リストを作成します。\n",
    "* **HTMLレポート作成**: `markup.py` を使用して `index.html` を生成します。これには、周波数ごとの上位相関チャンネルの表（ヒートマップ形式の着色あり）や、プロット画像へのリンクが含まれます。\n",
    "* **プロット作成**: `matplotlib` を使用して、コヒーレンスとスペクトルのグラフ（PNGまたはPDF）を生成します。\n",
    "\n",
    "この実装は、大量のチャンネルデータを効率的に処理するために、**FFTの事前計算**、**並列処理**、および**メモリ効率の良いTop-N記録方式**を採用している点が特徴です。\n",
    "\n",
    "オリジナルのBruco実装は以下で公開されています。設計詳細やCLIの挙動を確認したい場合はこちらを参照してください。\n",
    "- https://github.com/mikelovskij/bruco\n",
    "\n",
    "このノートブックでは `gwexpy` の `Bruco` モジュールを **Pythonライブラリとして** 使う利点を体感するために、\n",
    "対話的な解析・柔軟なデータ操作・高度な仮説検証を一通り実演します。\n",
    "\n",
    "- 実データは使わず、`gwpy` / `numpy` で生成した擬似データを利用します。\n",
    "- CLIでは難しい「非線形結合」や「変調」の仮説検証を、Python APIで高速に試します。\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## セットアップとモックデータ生成\n",
    "\n",
    "**何をするか**: ターゲット/補助チャンネルの擬似データを作り、Brucoに食わせるための `TimeSeries` を準備します。  \n",
    "**なぜ重要か**: 実運用ではNDSやフレームから取得しますが、ノートブック上で自由に信号を設計できると仮説検証が加速します。\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2026-02-15T03:04:42.886053Z",
     "iopub.status.busy": "2026-02-15T03:04:42.885904Z",
     "iopub.status.idle": "2026-02-15T03:04:44.947151Z",
     "shell.execute_reply": "2026-02-15T03:04:44.946098Z"
    }
   },
   "outputs": [],
   "source": [
    "# ruff: noqa: I001\n",
    "import warnings\n",
    "\n",
    "warnings.filterwarnings(\"ignore\")\n",
    "from astropy import units as u\n",
    "import matplotlib.pyplot as plt\n",
    "import numpy as np\n",
    "\n",
    "from gwexpy.analysis import Bruco\n",
    "from gwexpy.analysis.bruco import FastCoherenceEngine\n",
    "from gwexpy.astro import inspiral_range\n",
    "from gwexpy.frequencyseries import FrequencySeriesDict\n",
    "from gwexpy.noise.asd import from_pygwinc\n",
    "from gwexpy.noise.wave import from_asd\n",
    "from gwexpy.plot import Plot\n",
    "from gwexpy.timeseries import TimeSeries, TimeSeriesDict"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2026-02-15T03:04:44.951219Z",
     "iopub.status.busy": "2026-02-15T03:04:44.950913Z",
     "iopub.status.idle": "2026-02-15T03:04:48.490134Z",
     "shell.execute_reply": "2026-02-15T03:04:48.488985Z"
    }
   },
   "outputs": [],
   "source": [
    "rng = np.random.default_rng(7)\n",
    "\n",
    "duration = 128 # seconds\n",
    "sample_rate = 2048 # Hz\n",
    "fftlength = 4.0 # seconds\n",
    "overlap = 2.0 # seconds\n",
    "\n",
    "t = np.arange(0, duration, 1 / sample_rate)\n",
    "\n",
    "# aLIGO Sensitivity (ASD) \n",
    "fmax = sample_rate / 2 # Nyquist frequency\n",
    "asd_aligo = from_pygwinc(\n",
    " \"aLIGO\", fmin=4.0, fmax=fmax, df=1.0 / duration, quantity=\"strain\"\n",
    ")\n",
    "\n",
    "# aLIGO Sensitivity Noise Generate\n",
    "target = from_asd(asd_aligo, duration, sample_rate, t0=0, rng=rng).highpass(1)\n",
    "target.channel = \"H1:TARGET\"\n",
    "\n",
    "# Signal\n",
    "fast_line = np.sin(2 * np.pi * 60.0 * t)\n",
    "slow_motion = 70 * np.sin(2 * np.pi * 2.3 * t) + 30 * np.sin(2 * np.pi * 7.1 * t)\n",
    "\n",
    "aux1_data = 0.8 * fast_line + 0.2 * rng.normal(0, 1.0, size=t.size)\n",
    "aux2_data = 0.9 * slow_motion + 0.2 * rng.normal(0, 1.0, size=t.size) + 1\n",
    "aux1 = TimeSeries(\n",
    " aux1_data, sample_rate=sample_rate, t0=0, unit=\"V\", channel=\"H1:AUX1_FAST\"\n",
    ")\n",
    "aux2 = TimeSeries(\n",
    " aux2_data, sample_rate=sample_rate, t0=0, unit=\"V\", channel=\"H1:AUX2_SLOW\"\n",
    ").lowpass(30)\n",
    "\n",
    "# Signal: aLIGO Noise + + \n",
    "target = target + 1e-22 * target.unit * (\n",
    " aux1 / u.V + aux2 / u.V + (aux1 / u.V / 2) ** 2 + 0.01 * (aux1 * aux2 / u.V**2)\n",
    ")\n",
    "\n",
    "\n",
    "target.name = target.channel\n",
    "aux1.name = aux1.channel\n",
    "aux2.name = aux2.channel\n",
    "\n",
    "aux_dict = TimeSeriesDict(\n",
    " {\n",
    " aux1.channel: aux1,\n",
    " aux2.channel: aux2,\n",
    " }\n",
    ")\n",
    "\n",
    "print(f\"aLIGO ASD at 100 Hz: {asd_aligo.crop(99, 101).value[0]:.2e} strain/sqrt(Hz)\")\n",
    "print(f\"Target data std: {target.std():.2e}\")\n",
    "\n",
    "plot = Plot(\n",
    " [target.asd(8, 4), asd_aligo],\n",
    " aux1.asd(8, 4),\n",
    " aux2.asd(8, 4),\n",
    " figsize=(10, 12),\n",
    " sharex=True,\n",
    ")\n",
    "axes = plot.get_axes()\n",
    "axes[0].set_xlim(1, 1e3)\n",
    "axes[0].set_ylim(1e-24, 1e-19)\n",
    "axes[1].set_ylim(1e-3, 1e1)\n",
    "axes[2].set_ylim(1e-4, 1e3)\n",
    "axes[0].legend([target.name, \"Model ASD\"])\n",
    "axes[1].legend([aux1.name])\n",
    "axes[2].legend([aux2.name]);\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Section 1: 基本的なBruco解析の実行 (Jupyter上での再現)\n",
    "\n",
    "**何をするか**: `Bruco` クラスで総当たりコヒーレンス解析を実行し、結果をテーブルとプロットで確認します。  \n",
    "**なぜ重要か**: Python APIなら、対話的に条件や可視化を変えながら“犯人探し”を素早く試せます。\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2026-02-15T03:04:48.492529Z",
     "iopub.status.busy": "2026-02-15T03:04:48.492388Z",
     "iopub.status.idle": "2026-02-15T03:04:48.532726Z",
     "shell.execute_reply": "2026-02-15T03:04:48.532063Z"
    }
   },
   "outputs": [],
   "source": [
    "# Bruco 。\n",
    "# Data NDSfrom List(aux_channels) List 。\n",
    "bruco = Bruco(target_channel=target.name, aux_channels=[])\n",
    "\n",
    "# computemethod target_data aux_data 、 Fetch Run 。\n",
    "result = bruco.compute(\n",
    " start=0,\n",
    " duration=int(duration),\n",
    " fftlength=fftlength,\n",
    " overlap=overlap,\n",
    " parallel=1,\n",
    " batch_size=2,\n",
    " top_n=3,\n",
    " target_data=target, # Generatedid Data\n",
    " aux_data=aux_dict, # Generatedid Data Dictionary\n",
    ")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2026-02-15T03:04:48.534712Z",
     "iopub.status.busy": "2026-02-15T03:04:48.534550Z",
     "iopub.status.idle": "2026-02-15T03:04:48.548933Z",
     "shell.execute_reply": "2026-02-15T03:04:48.548158Z"
    }
   },
   "outputs": [],
   "source": [
    "df = result.to_dataframe(ranks=[0])\n",
    "\n",
    "df_sorted = (\n",
    " df.sort_values(\"coherence\", ascending=False)\n",
    " .dropna(subset=[\"channel\"])\n",
    " .head(15)\n",
    " .reset_index(drop=True)\n",
    ")\n",
    "\n",
    "df_sorted"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2026-02-15T03:04:48.551594Z",
     "iopub.status.busy": "2026-02-15T03:04:48.551466Z",
     "iopub.status.idle": "2026-02-15T03:04:49.003565Z",
     "shell.execute_reply": "2026-02-15T03:04:49.002516Z"
    }
   },
   "outputs": [],
   "source": [
    "result.plot_projection(coherence_threshold=0.5)\n",
    "plt.xlim(4, 1000)\n",
    "plt.show()\n",
    "\n",
    "result.plot_coherence(coherence_threshold=0.5)\n",
    "plt.xlim(1, 1000)\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2026-02-15T03:04:49.007119Z",
     "iopub.status.busy": "2026-02-15T03:04:49.006956Z",
     "iopub.status.idle": "2026-02-15T03:04:49.471138Z",
     "shell.execute_reply": "2026-02-15T03:04:49.470225Z"
    }
   },
   "outputs": [],
   "source": [
    "report_path = result.generate_report(\"bruco_report\", coherence_threshold=0.4)\n",
    "report_path"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Section 2: 高度な前処理と仮説検証 (Deep Dive: Nonlinear & Bilinear)\n",
    "\n",
    "**何をするか**: 既存の線形相関だけでは説明できないノイズを想定し、非線形結合（2乗）や変調（積）を仮説として検定します。  \n",
    "**なぜ重要か**: `FastCoherenceEngine` を使うと、ターゲットのFFTを再計算せずに仮想チャンネルを高速に試せます。\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2026-02-15T03:04:49.473077Z",
     "iopub.status.busy": "2026-02-15T03:04:49.472959Z",
     "iopub.status.idle": "2026-02-15T03:04:49.476613Z",
     "shell.execute_reply": "2026-02-15T03:04:49.476154Z"
    }
   },
   "outputs": [],
   "source": [
    "ts_sq = aux1**2\n",
    "ts_sq.name = f\"{aux1.name}^2\"\n",
    "\n",
    "ts_prod = aux1 * aux2\n",
    "ts_prod.name = f\"{aux1.name}*{aux2.name}\""
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2026-02-15T03:04:49.478238Z",
     "iopub.status.busy": "2026-02-15T03:04:49.478130Z",
     "iopub.status.idle": "2026-02-15T03:04:49.501306Z",
     "shell.execute_reply": "2026-02-15T03:04:49.500433Z"
    }
   },
   "outputs": [],
   "source": [
    "engine = FastCoherenceEngine(target, fftlength=fftlength, overlap=overlap)\n",
    "\n",
    "coh_linear = engine.compute_coherence(aux1)\n",
    "coh_sq = engine.compute_coherence(ts_sq)\n",
    "coh_prod = engine.compute_coherence(ts_prod)\n",
    "\n",
    "freqs = engine.frequencies"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2026-02-15T03:04:49.503724Z",
     "iopub.status.busy": "2026-02-15T03:04:49.503605Z",
     "iopub.status.idle": "2026-02-15T03:04:49.689689Z",
     "shell.execute_reply": "2026-02-15T03:04:49.688605Z"
    }
   },
   "outputs": [],
   "source": [
    "fig, ax = plt.subplots(figsize=(12, 6))\n",
    "ax.semilogx(freqs, coh_linear, label=f\"Linear: {aux1.name}\")\n",
    "ax.semilogx(freqs, coh_sq, label=f\"Squared: {ts_sq.name}\")\n",
    "ax.semilogx(freqs, coh_prod, label=f\"Product: {ts_prod.name}\")\n",
    "\n",
    "ax.set_xlabel(\"Frequency [Hz]\")\n",
    "ax.set_ylabel(\"Coherence\")\n",
    "ax.set_ylim(0.0, 1.0)\n",
    "ax.grid(True, which=\"both\", ls=\"-\", alpha=0.4)\n",
    "ax.legend()\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Section 3: 下流解析への接続 (Actionable Outcome)\n",
    "\n",
    "**何をするか**: もっとも寄与が大きいノイズ仮説を用いて残差スペクトルを推定し、BNS Rangeの改善量を見積もります。  \n",
    "**なぜ重要か**: Bruco結果を“見つけて終わり”にせず、感度改善やノイズ除去ワークフローにつなげられます。\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2026-02-15T03:04:49.691253Z",
     "iopub.status.busy": "2026-02-15T03:04:49.691133Z",
     "iopub.status.idle": "2026-02-15T03:04:50.044738Z",
     "shell.execute_reply": "2026-02-15T03:04:50.043896Z"
    }
   },
   "outputs": [],
   "source": [
    "target_asd = target.asd(fftlength=fftlength, overlap=overlap)\n",
    "target_asd_vals = target_asd.value\n",
    "\n",
    "coh_map = {\n",
    " aux1.name: coh_linear,\n",
    " ts_sq.name: coh_sq,\n",
    " ts_prod.name: coh_prod,\n",
    "}\n",
    "\n",
    "dominant_label = max(coh_map, key=lambda k: np.nanmax(coh_map[k]))\n",
    "dominant_coh = coh_map[dominant_label]\n",
    "\n",
    "# Bruco Projection Define Contribution ASD Estimated\n",
    "projected_asd = target_asd_vals * np.sqrt(dominant_coh)\n",
    "residual_asd_vals = np.sqrt(np.maximum(target_asd_vals**2 - projected_asd**2, 0.0))\n",
    "\n",
    "residual_asd = target_asd.copy()\n",
    "residual_asd.value[:] = residual_asd_vals\n",
    "\n",
    "fig, ax = plt.subplots(figsize=(12, 6))\n",
    "# ax.loglog(target_asd.frequencies.value, target_asd_vals, label=\"Target ASD\")\n",
    "# ax.loglog(target_asd.frequencies.value, residual_asd_vals, label=\"Residual ASD\")\n",
    "ax.loglog(target_asd, label=\"Target ASD\")\n",
    "ax.loglog(residual_asd, label=\"Residual ASD\")\n",
    "ax.set_xlabel(\"Frequency [Hz]\")\n",
    "ax.set_ylabel(\"ASD\")\n",
    "ax.grid(True, which=\"both\", ls=\"-\", alpha=0.4)\n",
    "ax.legend()\n",
    "plt.show()\n",
    "\n",
    "# BNS Range Ratiocomparison\n",
    "bns_range_before = inspiral_range(target_asd**2, mass1=1.4, mass2=1.4, fmin=10)\n",
    "bns_range_after = inspiral_range(residual_asd**2, mass1=1.4, mass2=1.4, fmin=10)\n",
    "\n",
    "print(f\"Dominant hypothesis: {dominant_label}\")\n",
    "print(f\"BNS range (before): {bns_range_before.to_value(u.Mpc):.2f} Mpc\")\n",
    "print(f\"BNS range (after): {bns_range_after.to_value(u.Mpc):.2f} Mpc\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2026-02-15T03:04:50.047468Z",
     "iopub.status.busy": "2026-02-15T03:04:50.047173Z",
     "iopub.status.idle": "2026-02-15T03:04:50.421691Z",
     "shell.execute_reply": "2026-02-15T03:04:50.421095Z"
    }
   },
   "outputs": [],
   "source": [
    "virtual_channels = {\n",
    " aux1.name: aux1,\n",
    " ts_sq.name: ts_sq,\n",
    " ts_prod.name: ts_prod,\n",
    "}\n",
    "\n",
    "culprit_channels = [dominant_label]\n",
    "witnesses = TimeSeriesDict({name: virtual_channels[name] for name in culprit_channels})\n",
    "\n",
    "cxx = witnesses.csd_matrix(fftlength=8.0)\n",
    "cyx = TimeSeriesDict({\"TARGET\": target}).csd_matrix(other=witnesses, fftlength=8.0)\n",
    "\n",
    "# Matrix H = Cyx @ Cxx^-1\n",
    "H_lowres = cyx @ cxx.inv()\n",
    "\n",
    "# EstimateddoneTransfer Function Display\n",
    "H_lowres.abs().plot(xscale=\"log\", yscale=\"log\").suptitle(\"Estimated MIMO Coupling (H)\")\n",
    "plt.show()\n",
    "\n",
    "# FFT\n",
    "\n",
    "\n",
    "tsd = TimeSeriesDict({\"MAIN\": target, **witnesses})\n",
    "aux_names = culprit_channels\n",
    "\n",
    "tsd_fft = tsd.fft()\n",
    "main_fft = tsd_fft[\"MAIN\"]\n",
    "\n",
    "# Filter Matrix \n",
    "H = H_lowres.interpolate(main_fft.frequencies)\n",
    "X_mat = FrequencySeriesDict({k: tsd_fft[k] for k in aux_names}).to_matrix()\n",
    "\n",
    "# Projection \n",
    "Y_proj = (H @ X_mat)[0, 0]\n",
    "cleaned_fft = main_fft - Y_proj\n",
    "\n",
    "# time / duration \n",
    "cleaned_ts = cleaned_fft.ifft()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2026-02-15T03:04:50.423998Z",
     "iopub.status.busy": "2026-02-15T03:04:50.423863Z",
     "iopub.status.idle": "2026-02-15T03:04:56.240788Z",
     "shell.execute_reply": "2026-02-15T03:04:56.240421Z"
    }
   },
   "outputs": [],
   "source": [
    "# NoiseSubtraction Verify\n",
    "fig = plt.figure(figsize=(12, 6))\n",
    "ax = fig.gca()\n",
    "\n",
    "# Data Subtraction Data Plot ( 1seconds )\n",
    "plot_duration = 1.0\n",
    "target.crop(end=target.t0.value + plot_duration).plot(\n",
    " ax=ax, label=\"Original\", alpha=0.7\n",
    ") # noqa: F821\n",
    "cleaned_ts.crop(end=target.t0.value + plot_duration).plot(\n",
    " ax=ax, label=\"Cleaned (Bruco)\", linestyle=\"--\", alpha=0.8\n",
    ") # noqa: F821\n",
    "\n",
    "ax.set_title(f\"Noise Subtraction Result (First {plot_duration}s)\")\n",
    "ax.legend()\n",
    "plt.show()"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "base",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.12"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}