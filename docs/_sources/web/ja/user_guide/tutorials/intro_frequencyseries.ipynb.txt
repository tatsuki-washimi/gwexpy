{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# FrequencySeries の新機能と高度な操作\n",
    "\n",
    "[![Open In Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/tatsuki-washimi/gwexpy/blob/main/docs/web/en/user_guide/tutorials/intro_frequencyseries.ipynb)\n",
    "\n",
    "このノートブックでは、`gwexpy` で拡張された `FrequencySeries` クラスの新しいメソッドと機能について紹介します。\n",
    "主に複素スペクトルの扱い、微積分、フィルタリング（スムージング）、および他ライブラリとの連携機能に焦点を当てます。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2026-02-15T02:45:24.182856Z",
     "iopub.status.busy": "2026-02-15T02:45:24.182706Z",
     "iopub.status.idle": "2026-02-15T02:45:26.572225Z",
     "shell.execute_reply": "2026-02-15T02:45:26.571301Z"
    }
   },
   "outputs": [],
   "source": [
    "import matplotlib.pyplot as plt\n",
    "import numpy as np\n",
    "\n",
    "from gwexpy.frequencyseries import FrequencySeries\n",
    "from gwexpy.plot import Plot\n",
    "from gwexpy.timeseries import TimeSeries\n",
    "\n",
    "plt.rcParams[\"figure.figsize\"] = (10, 6)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 1. データの準備\n",
    "\n",
    "まずは `TimeSeries` から FFT を用いて `FrequencySeries` を作成します。\n",
    "ここでは、特定の周波数成分を持つテスト信号を生成します。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2026-02-15T02:45:26.574756Z",
     "iopub.status.busy": "2026-02-15T02:45:26.574520Z",
     "iopub.status.idle": "2026-02-15T02:45:40.878116Z",
     "shell.execute_reply": "2026-02-15T02:45:40.877188Z"
    }
   },
   "outputs": [],
   "source": [
    "fs = 1024\n",
    "t = np.arange(0, 4, 1 / fs)\n",
    "exp = np.exp(-t / 1.5)\n",
    "exp[: int(exp.size / 4)] = 0\n",
    "data = (\n",
    "    np.sin(2 * np.pi * 10.1 * t)\n",
    "    + 5 * exp * np.sin(2 * np.pi * 100.1 * t)\n",
    "    + np.random.normal(scale=0.3, size=len(t))\n",
    ")\n",
    "ts = TimeSeries(data, dt=1 / fs, unit=\"um\", name=\"Test Signal\")\n",
    "print(ts)\n",
    "ts.plot(title=ts.name)\n",
    "\n",
    "# FFT Run FrequencySeries (transient Mode )\n",
    "spec = ts.fft(mode=\"transient\", pad_left=1.0, pad_right=1.0, nfft_mode=\"next_fast_len\")\n",
    "print(f\"Type: {type(spec)}\")\n",
    "print(f\"Length: {len(spec)}\")\n",
    "print(f\"df: {spec.df}\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 2. 複素スペクトルの可視化と変換\n",
    "\n",
    "### 位相と振幅\n",
    "`phase()`, `degree()`, `to_db()` メソッドを使用すると、複素スペクトルを直感的な単位に変換できます。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2026-02-15T02:45:40.881167Z",
     "iopub.status.busy": "2026-02-15T02:45:40.881007Z",
     "iopub.status.idle": "2026-02-15T02:45:41.305915Z",
     "shell.execute_reply": "2026-02-15T02:45:41.304579Z"
    }
   },
   "outputs": [],
   "source": [
    "# Amplitude dB Transform (ref=1.0, 20*log10)\n",
    "spec_db = spec.to_db()\n",
    "\n",
    "# Phase ( 、unwrap=True Continuous )\n",
    "spec_phase = spec.degree(unwrap=True)\n",
    "\n",
    "plot = Plot(spec_db, spec_phase, separate=True, sharex=True, xscale=\"log\")\n",
    "ax = plot.axes\n",
    "ax[0].set_ylabel(\"Magnitude [dB (m)]\")\n",
    "ax[0].grid(True, which=\"both\")\n",
    "\n",
    "ax[1].set_ylabel(\"Phase [deg]\")\n",
    "ax[1].set_xlabel(\"Frequency [Hz]\")\n",
    "ax[1].grid(True, which=\"both\")\n",
    "plot.figure.suptitle(\"Complex Spectrum Analysis\")\n",
    "plot.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 3. 周波数ドメインでの微積分\n",
    "\n",
    "`differentiate()` および `integrate()` メソッドにより、周波数ドメインで微分・積分を行うことができます。\n",
    "引数 `order` で階数を指定できます（デフォルトは1）。\n",
    "これは「変位・速度・加速度」の変換（$(2 \\pi i f)^n$ の乗算・除算）を簡単に行うための機能です。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2026-02-15T02:45:41.308098Z",
     "iopub.status.busy": "2026-02-15T02:45:41.307972Z",
     "iopub.status.idle": "2026-02-15T02:45:41.729309Z",
     "shell.execute_reply": "2026-02-15T02:45:41.728658Z"
    }
   },
   "outputs": [],
   "source": [
    "# (m) -> Velocity (m/s) Differentiate (order=1)\n",
    "vel_spec = spec.differentiate()\n",
    "\n",
    "# (m) -> Acceleration (m/s^2) 2 Differentiate (order=2)\n",
    "accel_spec = spec.differentiate(order=2)\n",
    "\n",
    "# Integrate : Acceleration -> Velocity\n",
    "vel_from_accel = accel_spec.integrate()\n",
    "\n",
    "plot = Plot(\n",
    "    spec.abs(), vel_spec.abs(), accel_spec.abs(), xscale=\"log\", yscale=\"log\", alpha=0.8\n",
    ")\n",
    "ax = plot.gca()\n",
    "ax.get_lines()[0].set_label(\"Displacement [m]\")\n",
    "ax.get_lines()[1].set_label(\"Velocity [m/s]\")\n",
    "ax.get_lines()[2].set_label(\"Acceleration [m/s^2]\")\n",
    "ax.legend()\n",
    "ax.grid(True, which=\"both\")\n",
    "ax.set_title(\"Calculus in Frequency Domain\")\n",
    "ax.set_ylabel(\"Magnitude\")\n",
    "plot.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 4. スペクトルのスムージングとピーク検出\n",
    "\n",
    "### スムージング\n",
    "`smooth()` メソッドを使用すると、移動平均などによるスペクトルの平滑化が可能です。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2026-02-15T02:45:41.732896Z",
     "iopub.status.busy": "2026-02-15T02:45:41.732785Z",
     "iopub.status.idle": "2026-02-15T02:45:42.019117Z",
     "shell.execute_reply": "2026-02-15T02:45:42.018288Z"
    }
   },
   "outputs": [],
   "source": [
    "# Amplitude 11 Sample Smoothing\n",
    "spec_smooth = spec.smooth(width=11)\n",
    "\n",
    "plot = Plot(spec.abs(), spec_smooth.abs(), xscale=\"log\", yscale=\"log\")\n",
    "ax = plot.gca()\n",
    "ax.get_lines()[0].set_label(\"Original\")\n",
    "ax.get_lines()[0].set_alpha(0.6)\n",
    "ax.get_lines()[1].set_label(\"Smoothed (width=11)\")\n",
    "ax.get_lines()[1].set_color(\"red\")\n",
    "ax.legend()\n",
    "ax.grid(True, which=\"both\")\n",
    "ax.set_title(\"Spectrum Smoothing\")\n",
    "plot.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### ピーク検出\n",
    "`find_peaks()` メソッドは `scipy.signal.find_peaks` をラップしており、特定の閾値を超えるピークを簡単に抽出できます。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2026-02-15T02:45:42.021120Z",
     "iopub.status.busy": "2026-02-15T02:45:42.021001Z",
     "iopub.status.idle": "2026-02-15T02:45:42.221611Z",
     "shell.execute_reply": "2026-02-15T02:45:42.220734Z"
    }
   },
   "outputs": [],
   "source": [
    "# Amplitude 0.2 Peak\n",
    "peaks, props = spec.find_peaks(threshold=0.2)\n",
    "\n",
    "plot = Plot(spec.abs())\n",
    "ax = plot.gca()\n",
    "ax.plot(\n",
    "    peaks.abs(), color=\"red\", marker=\".\", ms=15, lw=0, zorder=3, label=\"Detected Peaks\"\n",
    ")\n",
    "ax.set_xlim(1, 150)\n",
    "ax.set_xscale(\"log\")\n",
    "ax.set_yscale(\"log\")\n",
    "ax.set_title(\"Peak Detection\")\n",
    "ax.legend()\n",
    "plot.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 5. 高度な解析機能\n",
    "\n",
    "### 群遅延 (Group Delay)\n",
    "`group_delay()` メソッドは、位相の周波数微分から群遅延（信号のエンベロープの遅延）を計算します。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2026-02-15T02:45:42.223257Z",
     "iopub.status.busy": "2026-02-15T02:45:42.223143Z",
     "iopub.status.idle": "2026-02-15T02:45:42.563521Z",
     "shell.execute_reply": "2026-02-15T02:45:42.562707Z"
    }
   },
   "outputs": [],
   "source": [
    "gd = spec.group_delay()\n",
    "\n",
    "plot = Plot(gd)\n",
    "ax = plot.gca()\n",
    "ax.set_ylabel(\"Group Delay [s]\")\n",
    "ax.set_xlabel(\"Frequency [Hz]\")\n",
    "ax.set_xlim(0, 200)\n",
    "ax.set_title(\"Group Delay Calculation\")\n",
    "plot.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 逆FFT (ifft)\n",
    "`ifft()` メソッドは、`TimeSeries` を返します。`mode=\"transient\"` で FFT した結果であっても、情報を引き継いで元の長さに戻す (trim=True) などの制御が可能です。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2026-02-15T02:45:42.565516Z",
     "iopub.status.busy": "2026-02-15T02:45:42.565374Z",
     "iopub.status.idle": "2026-02-15T02:45:53.967389Z",
     "shell.execute_reply": "2026-02-15T02:45:53.966706Z"
    }
   },
   "outputs": [],
   "source": [
    "# FFT TimeSeries\n",
    "# mode=\"auto\" 、 FrequencySeries transient\n",
    "inv_ts = spec.ifft(mode=\"auto\")\n",
    "red_ts = inv_ts - ts\n",
    "\n",
    "plot = Plot(ts, inv_ts, red_ts)\n",
    "ax = plot.gca()\n",
    "ax.get_lines()[0].set_label(\"Original\")\n",
    "ax.get_lines()[1].set_label(\"IFFT Result\")\n",
    "ax.get_lines()[2].set_label(\"Residual\")\n",
    "ax.get_lines()[1].set_linestyle(\"--\")\n",
    "ax.get_lines()[1].set_alpha(0.8)\n",
    "ax.get_lines()[2].set_color(\"black\")\n",
    "ax.legend()\n",
    "ax.set_title(\"Time Domain Round-trip (FFT -> IFFT)\")\n",
    "plot.show()\n",
    "\n",
    "red_ts.plot(title=\"Residual Time Series after IFFT\");"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 6. 他ライブラリとの連携\n",
    "\n",
    "Pandas, xarray, control ライブラリとの相互変換が追加されています。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2026-02-15T02:45:53.969676Z",
     "iopub.status.busy": "2026-02-15T02:45:53.969554Z",
     "iopub.status.idle": "2026-02-15T02:45:54.106346Z",
     "shell.execute_reply": "2026-02-15T02:45:54.105000Z"
    }
   },
   "outputs": [],
   "source": [
    "# Pandas Series Transform\n",
    "pd_series = spec.to_pandas()\n",
    "print(\"Pandas index sample:\", pd_series.index[:5])\n",
    "display(pd_series)\n",
    "\n",
    "# xarray DataArray Transform\n",
    "try:\n",
    "    da = spec.to_xarray()\n",
    "    print(\"xarray coord name:\", list(da.coords))\n",
    "    display(da)\n",
    "except ImportError:\n",
    "    print(\"xarray not installed, skipping DataArray conversion.\")\n",
    "\n",
    "# control.FRD Transform (Control )\n",
    "try:\n",
    "    from control import FRD\n",
    "\n",
    "    _ = FRD\n",
    "    frd_obj = spec.to_control_frd()\n",
    "    print(\"Successfully converted to control.FRD\")\n",
    "    display(frd_obj)\n",
    "except ImportError:\n",
    "    print(\"python-control library not installed\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 7. Python Control Library との連携\n",
    "\n",
    "制御工学の分野で標準的な `control` ライブラリの **Frequency Response Data (FRD)** オブジェクトと相互変換が可能です。\n",
    "これにより、GWExPyで計測した伝達関数を、制御系の設計や解析に直接利用できます。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2026-02-15T02:45:54.108421Z",
     "iopub.status.busy": "2026-02-15T02:45:54.108154Z",
     "iopub.status.idle": "2026-02-15T02:45:54.604739Z",
     "shell.execute_reply": "2026-02-15T02:45:54.603790Z"
    }
   },
   "outputs": [],
   "source": [
    "try:\n",
    "    import control\n",
    "\n",
    "    # FrequencySeries -> control.FRD Transform\n",
    "    # frequency_unit=\"Hz\" do 、 rad/s Transform\n",
    "    frd_sys = spec.to_control_frd(frequency_unit=\"Hz\")\n",
    "\n",
    "    print(\"\\n--- Converted to Control FRD ---\")\n",
    "    print(str(frd_sys)[:1000] + \"\\n... (truncated) ...\")\n",
    "\n",
    "    # Plot (control )\n",
    "    control.bode(frd_sys) # (Plot Run )\n",
    "\n",
    "    # control.FRD -> FrequencySeries\n",
    "    fs_restored = FrequencySeries.from_control_frd(frd_sys, frequency_unit=\"Hz\")\n",
    "\n",
    "    print(\"\\n--- Restored FrequencySeries ---\")\n",
    "    print(fs_restored)\n",
    "\n",
    "except ImportError:\n",
    "    print(\"Python Control Systems Library is not installed.\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 8. 求積和 (Quadrature Sum)\n",
    "\n",
    "直交位相の和を計算する機能です。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2026-02-15T02:45:54.608752Z",
     "iopub.status.busy": "2026-02-15T02:45:54.608628Z",
     "iopub.status.idle": "2026-02-15T02:45:55.059974Z",
     "shell.execute_reply": "2026-02-15T02:45:55.059421Z"
    }
   },
   "outputs": [],
   "source": [
    "# Generate noisy data\n",
    "np.random.seed(42)\n",
    "f = spec.frequencies.value\n",
    "noise = np.abs(np.random.randn(f.size))\n",
    "peak = 10.0 * np.exp(-((f - 200) ** 2) / 50.0)\n",
    "data = noise + peak\n",
    "\n",
    "raw = FrequencySeries(data, frequencies=f, unit=\"V\", name=\"Raw Data\")\n",
    "\n",
    "# Smooth\n",
    "smoothed = raw.smooth(width=10, method=\"amplitude\")\n",
    "smoothed.name = \"Smoothed\"\n",
    "\n",
    "# Convert to dB\n",
    "raw_db = raw.to_db()\n",
    "smoothed_db = smoothed.to_db()\n",
    "raw_db.name = \"Raw (dB)\"\n",
    "smoothed_db.name = \"Smoothed (dB)\"\n",
    "\n",
    "plot = raw_db.plot(label=\"Raw\", title=\"Smoothing & dB\")\n",
    "ax = plot.gca()\n",
    "ax.plot(smoothed_db, label=\"Smoothed\", linewidth=2)\n",
    "ax.legend()\n",
    "plot.show()\n",
    "plt.close()\n",
    "\n",
    "# Quadrature Sum (Noise Budget example)\n",
    "noise_a = FrequencySeries(np.ones_like(f), frequencies=f, unit=\"V\", name=\"Noise A\")\n",
    "noise_b = FrequencySeries(np.ones_like(f) * 2, frequencies=f, unit=\"V\", name=\"Noise B\")\n",
    "\n",
    "total = noise_a.quadrature_sum(noise_b)\n",
    "print(f\"Noise A: {noise_a.value[0]}, Noise B: {noise_b.value[0]}\")\n",
    "print(f\"Total (Sqrt Sum): {total.value[0]}\")\n",
    "Plot(total, noise_a, noise_b, alpha=0.8)\n",
    "plt.legend([\"Total\", \"Noise A\", \"Noise B\"])\n",
    "plt.xscale(\"log\")\n",
    "plt.yscale(\"log\")\n",
    "plt.show()"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "base",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.12"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}