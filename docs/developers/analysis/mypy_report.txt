gwexpy/gui/nds/nds_thread.py:24: error: Name "QtCore.QThread" is not defined  [name-defined]
gwexpy/gui/nds/nds_thread.py:93: error: Name "QtCore.QThread" is not defined  [name-defined]
gwexpy/types/metadata.py:207: error: No overload variant of "__call__" of "_UFunc_Nin2_Nout1" matches argument types "MetaData", "Any"  [call-overload]
gwexpy/types/metadata.py:207: note: Possible overload variants:
gwexpy/types/metadata.py:207: note:     def __call__(complex | str | bytes | generic[Any], complex | str | bytes | generic[Any], /, out: None = ..., *, dtype: type[Any] | dtype[Any] | _SupportsDType[dtype[Any]] | tuple[Any, Any] | list[Any] | _DTypeDict | str | None = ..., where: _SupportsArray[dtype[numpy.bool[builtins.bool]]] | _NestedSequence[_SupportsArray[dtype[numpy.bool[builtins.bool]]]] | builtins.bool | _NestedSequence[builtins.bool] | None = ..., casting: Literal['no', 'equiv', 'safe', 'same_kind', 'unsafe'] = ..., order: Literal['K', 'A', 'C', 'F'] | None = ..., subok: bool = ..., signature: tuple[str | None, str | None, str | None] | str | None = ...) -> Any
gwexpy/types/metadata.py:207: note:     def __call__(Buffer | _SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] | complex | bytes | str | _NestedSequence[complex | bytes | str], ndarray[tuple[Any, ...], dtype[generic[Any]]], /, out: ndarray[tuple[Any, ...], dtype[generic[Any]]] | tuple[ndarray[tuple[Any, ...], dtype[generic[Any]]]] | None = ..., *, dtype: type[Any] | dtype[Any] | _SupportsDType[dtype[Any]] | tuple[Any, Any] | list[Any] | _DTypeDict | str | None = ..., where: _SupportsArray[dtype[numpy.bool[builtins.bool]]] | _NestedSequence[_SupportsArray[dtype[numpy.bool[builtins.bool]]]] | builtins.bool | _NestedSequence[builtins.bool] | None = ..., casting: Literal['no', 'equiv', 'safe', 'same_kind', 'unsafe'] = ..., order: Literal['K', 'A', 'C', 'F'] | None = ..., subok: bool = ..., signature: tuple[str | None, str | None, str | None] | str | None = ...) -> ndarray[tuple[Any, ...], dtype[Any]]
gwexpy/types/metadata.py:207: note:     def __call__(ndarray[tuple[Any, ...], dtype[generic[Any]]], Buffer | _SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] | complex | bytes | str | _NestedSequence[complex | bytes | str], /, out: ndarray[tuple[Any, ...], dtype[generic[Any]]] | tuple[ndarray[tuple[Any, ...], dtype[generic[Any]]]] | None = ..., *, dtype: type[Any] | dtype[Any] | _SupportsDType[dtype[Any]] | tuple[Any, Any] | list[Any] | _DTypeDict | str | None = ..., where: _SupportsArray[dtype[numpy.bool[builtins.bool]]] | _NestedSequence[_SupportsArray[dtype[numpy.bool[builtins.bool]]]] | builtins.bool | _NestedSequence[builtins.bool] | None = ..., casting: Literal['no', 'equiv', 'safe', 'same_kind', 'unsafe'] = ..., order: Literal['K', 'A', 'C', 'F'] | None = ..., subok: bool = ..., signature: tuple[str | None, str | None, str | None] | str | None = ...) -> ndarray[tuple[Any, ...], dtype[Any]]
gwexpy/types/metadata.py:207: note:     def __call__(Buffer | _SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] | complex | bytes | str | _NestedSequence[complex | bytes | str], Buffer | _SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] | complex | bytes | str | _NestedSequence[complex | bytes | str], /, out: ndarray[tuple[Any, ...], dtype[generic[Any]]] | tuple[ndarray[tuple[Any, ...], dtype[generic[Any]]]], *, dtype: type[Any] | dtype[Any] | _SupportsDType[dtype[Any]] | tuple[Any, Any] | list[Any] | _DTypeDict | str | None = ..., where: _SupportsArray[dtype[numpy.bool[builtins.bool]]] | _NestedSequence[_SupportsArray[dtype[numpy.bool[builtins.bool]]]] | builtins.bool | _NestedSequence[builtins.bool] | None = ..., casting: Literal['no', 'equiv', 'safe', 'same_kind', 'unsafe'] = ..., order: Literal['K', 'A', 'C', 'F'] | None = ..., subok: bool = ..., signature: tuple[str | None, str | None, str | None] | str | None = ...) -> ndarray[tuple[Any, ...], dtype[Any]]
gwexpy/types/metadata.py:207: note:     def __call__(Buffer | _SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] | complex | bytes | str | _NestedSequence[complex | bytes | str], Buffer | _SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] | complex | bytes | str | _NestedSequence[complex | bytes | str], /, out: ndarray[tuple[Any, ...], dtype[generic[Any]]] | tuple[ndarray[tuple[Any, ...], dtype[generic[Any]]]] | None = ..., *, dtype: type[Any] | dtype[Any] | _SupportsDType[dtype[Any]] | tuple[Any, Any] | list[Any] | _DTypeDict | str | None = ..., where: _SupportsArray[dtype[numpy.bool[builtins.bool]]] | _NestedSequence[_SupportsArray[dtype[numpy.bool[builtins.bool]]]] | builtins.bool | _NestedSequence[builtins.bool] | None = ..., casting: Literal['no', 'equiv', 'safe', 'same_kind', 'unsafe'] = ..., order: Literal['K', 'A', 'C', 'F'] | None = ..., subok: bool = ..., signature: tuple[str | None, str | None, str | None] | str | None = ...) -> ndarray[tuple[Any, ...], dtype[Any]] | Any
gwexpy/types/metadata.py:210: error: No overload variant of "__call__" of "_UFunc_Nin2_Nout1" matches argument types "Any", "MetaData"  [call-overload]
gwexpy/types/metadata.py:210: note: Possible overload variants:
gwexpy/types/metadata.py:210: note:     def __call__(complex | str | bytes | generic[Any], complex | str | bytes | generic[Any], /, out: None = ..., *, dtype: type[Any] | dtype[Any] | _SupportsDType[dtype[Any]] | tuple[Any, Any] | list[Any] | _DTypeDict | str | None = ..., where: _SupportsArray[dtype[numpy.bool[builtins.bool]]] | _NestedSequence[_SupportsArray[dtype[numpy.bool[builtins.bool]]]] | builtins.bool | _NestedSequence[builtins.bool] | None = ..., casting: Literal['no', 'equiv', 'safe', 'same_kind', 'unsafe'] = ..., order: Literal['K', 'A', 'C', 'F'] | None = ..., subok: bool = ..., signature: tuple[str | None, str | None, str | None] | str | None = ...) -> Any
gwexpy/types/metadata.py:210: note:     def __call__(Buffer | _SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] | complex | bytes | str | _NestedSequence[complex | bytes | str], ndarray[tuple[Any, ...], dtype[generic[Any]]], /, out: ndarray[tuple[Any, ...], dtype[generic[Any]]] | tuple[ndarray[tuple[Any, ...], dtype[generic[Any]]]] | None = ..., *, dtype: type[Any] | dtype[Any] | _SupportsDType[dtype[Any]] | tuple[Any, Any] | list[Any] | _DTypeDict | str | None = ..., where: _SupportsArray[dtype[numpy.bool[builtins.bool]]] | _NestedSequence[_SupportsArray[dtype[numpy.bool[builtins.bool]]]] | builtins.bool | _NestedSequence[builtins.bool] | None = ..., casting: Literal['no', 'equiv', 'safe', 'same_kind', 'unsafe'] = ..., order: Literal['K', 'A', 'C', 'F'] | None = ..., subok: bool = ..., signature: tuple[str | None, str | None, str | None] | str | None = ...) -> ndarray[tuple[Any, ...], dtype[Any]]
gwexpy/types/metadata.py:210: note:     def __call__(ndarray[tuple[Any, ...], dtype[generic[Any]]], Buffer | _SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] | complex | bytes | str | _NestedSequence[complex | bytes | str], /, out: ndarray[tuple[Any, ...], dtype[generic[Any]]] | tuple[ndarray[tuple[Any, ...], dtype[generic[Any]]]] | None = ..., *, dtype: type[Any] | dtype[Any] | _SupportsDType[dtype[Any]] | tuple[Any, Any] | list[Any] | _DTypeDict | str | None = ..., where: _SupportsArray[dtype[numpy.bool[builtins.bool]]] | _NestedSequence[_SupportsArray[dtype[numpy.bool[builtins.bool]]]] | builtins.bool | _NestedSequence[builtins.bool] | None = ..., casting: Literal['no', 'equiv', 'safe', 'same_kind', 'unsafe'] = ..., order: Literal['K', 'A', 'C', 'F'] | None = ..., subok: bool = ..., signature: tuple[str | None, str | None, str | None] | str | None = ...) -> ndarray[tuple[Any, ...], dtype[Any]]
gwexpy/types/metadata.py:210: note:     def __call__(Buffer | _SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] | complex | bytes | str | _NestedSequence[complex | bytes | str], Buffer | _SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] | complex | bytes | str | _NestedSequence[complex | bytes | str], /, out: ndarray[tuple[Any, ...], dtype[generic[Any]]] | tuple[ndarray[tuple[Any, ...], dtype[generic[Any]]]], *, dtype: type[Any] | dtype[Any] | _SupportsDType[dtype[Any]] | tuple[Any, Any] | list[Any] | _DTypeDict | str | None = ..., where: _SupportsArray[dtype[numpy.bool[builtins.bool]]] | _NestedSequence[_SupportsArray[dtype[numpy.bool[builtins.bool]]]] | builtins.bool | _NestedSequence[builtins.bool] | None = ..., casting: Literal['no', 'equiv', 'safe', 'same_kind', 'unsafe'] = ..., order: Literal['K', 'A', 'C', 'F'] | None = ..., subok: bool = ..., signature: tuple[str | None, str | None, str | None] | str | None = ...) -> ndarray[tuple[Any, ...], dtype[Any]]
gwexpy/types/metadata.py:210: note:     def __call__(Buffer | _SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] | complex | bytes | str | _NestedSequence[complex | bytes | str], Buffer | _SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] | complex | bytes | str | _NestedSequence[complex | bytes | str], /, out: ndarray[tuple[Any, ...], dtype[generic[Any]]] | tuple[ndarray[tuple[Any, ...], dtype[generic[Any]]]] | None = ..., *, dtype: type[Any] | dtype[Any] | _SupportsDType[dtype[Any]] | tuple[Any, Any] | list[Any] | _DTypeDict | str | None = ..., where: _SupportsArray[dtype[numpy.bool[builtins.bool]]] | _NestedSequence[_SupportsArray[dtype[numpy.bool[builtins.bool]]]] | builtins.bool | _NestedSequence[builtins.bool] | None = ..., casting: Literal['no', 'equiv', 'safe', 'same_kind', 'unsafe'] = ..., order: Literal['K', 'A', 'C', 'F'] | None = ..., subok: bool = ..., signature: tuple[str | None, str | None, str | None] | str | None = ...) -> ndarray[tuple[Any, ...], dtype[Any]] | Any
gwexpy/types/metadata.py:213: error: No overload variant of "__call__" of "_UFunc_Nin2_Nout1" matches argument types "MetaData", "Any"  [call-overload]
gwexpy/types/metadata.py:213: note: Possible overload variants:
gwexpy/types/metadata.py:213: note:     def __call__(complex | str | bytes | generic[Any], complex | str | bytes | generic[Any], /, out: None = ..., *, dtype: type[Any] | dtype[Any] | _SupportsDType[dtype[Any]] | tuple[Any, Any] | list[Any] | _DTypeDict | str | None = ..., where: _SupportsArray[dtype[numpy.bool[builtins.bool]]] | _NestedSequence[_SupportsArray[dtype[numpy.bool[builtins.bool]]]] | builtins.bool | _NestedSequence[builtins.bool] | None = ..., casting: Literal['no', 'equiv', 'safe', 'same_kind', 'unsafe'] = ..., order: Literal['K', 'A', 'C', 'F'] | None = ..., subok: bool = ..., signature: tuple[str | None, str | None, str | None] | str | None = ...) -> Any
gwexpy/types/metadata.py:213: note:     def __call__(Buffer | _SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] | complex | bytes | str | _NestedSequence[complex | bytes | str], ndarray[tuple[Any, ...], dtype[generic[Any]]], /, out: ndarray[tuple[Any, ...], dtype[generic[Any]]] | tuple[ndarray[tuple[Any, ...], dtype[generic[Any]]]] | None = ..., *, dtype: type[Any] | dtype[Any] | _SupportsDType[dtype[Any]] | tuple[Any, Any] | list[Any] | _DTypeDict | str | None = ..., where: _SupportsArray[dtype[numpy.bool[builtins.bool]]] | _NestedSequence[_SupportsArray[dtype[numpy.bool[builtins.bool]]]] | builtins.bool | _NestedSequence[builtins.bool] | None = ..., casting: Literal['no', 'equiv', 'safe', 'same_kind', 'unsafe'] = ..., order: Literal['K', 'A', 'C', 'F'] | None = ..., subok: bool = ..., signature: tuple[str | None, str | None, str | None] | str | None = ...) -> ndarray[tuple[Any, ...], dtype[Any]]
gwexpy/types/metadata.py:213: note:     def __call__(ndarray[tuple[Any, ...], dtype[generic[Any]]], Buffer | _SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] | complex | bytes | str | _NestedSequence[complex | bytes | str], /, out: ndarray[tuple[Any, ...], dtype[generic[Any]]] | tuple[ndarray[tuple[Any, ...], dtype[generic[Any]]]] | None = ..., *, dtype: type[Any] | dtype[Any] | _SupportsDType[dtype[Any]] | tuple[Any, Any] | list[Any] | _DTypeDict | str | None = ..., where: _SupportsArray[dtype[numpy.bool[builtins.bool]]] | _NestedSequence[_SupportsArray[dtype[numpy.bool[builtins.bool]]]] | builtins.bool | _NestedSequence[builtins.bool] | None = ..., casting: Literal['no', 'equiv', 'safe', 'same_kind', 'unsafe'] = ..., order: Literal['K', 'A', 'C', 'F'] | None = ..., subok: bool = ..., signature: tuple[str | None, str | None, str | None] | str | None = ...) -> ndarray[tuple[Any, ...], dtype[Any]]
gwexpy/types/metadata.py:213: note:     def __call__(Buffer | _SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] | complex | bytes | str | _NestedSequence[complex | bytes | str], Buffer | _SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] | complex | bytes | str | _NestedSequence[complex | bytes | str], /, out: ndarray[tuple[Any, ...], dtype[generic[Any]]] | tuple[ndarray[tuple[Any, ...], dtype[generic[Any]]]], *, dtype: type[Any] | dtype[Any] | _SupportsDType[dtype[Any]] | tuple[Any, Any] | list[Any] | _DTypeDict | str | None = ..., where: _SupportsArray[dtype[numpy.bool[builtins.bool]]] | _NestedSequence[_SupportsArray[dtype[numpy.bool[builtins.bool]]]] | builtins.bool | _NestedSequence[builtins.bool] | None = ..., casting: Literal['no', 'equiv', 'safe', 'same_kind', 'unsafe'] = ..., order: Literal['K', 'A', 'C', 'F'] | None = ..., subok: bool = ..., signature: tuple[str | None, str | None, str | None] | str | None = ...) -> ndarray[tuple[Any, ...], dtype[Any]]
gwexpy/types/metadata.py:213: note:     def __call__(Buffer | _SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] | complex | bytes | str | _NestedSequence[complex | bytes | str], Buffer | _SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] | complex | bytes | str | _NestedSequence[complex | bytes | str], /, out: ndarray[tuple[Any, ...], dtype[generic[Any]]] | tuple[ndarray[tuple[Any, ...], dtype[generic[Any]]]] | None = ..., *, dtype: type[Any] | dtype[Any] | _SupportsDType[dtype[Any]] | tuple[Any, Any] | list[Any] | _DTypeDict | str | None = ..., where: _SupportsArray[dtype[numpy.bool[builtins.bool]]] | _NestedSequence[_SupportsArray[dtype[numpy.bool[builtins.bool]]]] | builtins.bool | _NestedSequence[builtins.bool] | None = ..., casting: Literal['no', 'equiv', 'safe', 'same_kind', 'unsafe'] = ..., order: Literal['K', 'A', 'C', 'F'] | None = ..., subok: bool = ..., signature: tuple[str | None, str | None, str | None] | str | None = ...) -> ndarray[tuple[Any, ...], dtype[Any]] | Any
gwexpy/types/metadata.py:216: error: No overload variant of "__call__" of "_UFunc_Nin2_Nout1" matches argument types "Any", "MetaData"  [call-overload]
gwexpy/types/metadata.py:216: note: Possible overload variants:
gwexpy/types/metadata.py:216: note:     def __call__(complex | str | bytes | generic[Any], complex | str | bytes | generic[Any], /, out: None = ..., *, dtype: type[Any] | dtype[Any] | _SupportsDType[dtype[Any]] | tuple[Any, Any] | list[Any] | _DTypeDict | str | None = ..., where: _SupportsArray[dtype[numpy.bool[builtins.bool]]] | _NestedSequence[_SupportsArray[dtype[numpy.bool[builtins.bool]]]] | builtins.bool | _NestedSequence[builtins.bool] | None = ..., casting: Literal['no', 'equiv', 'safe', 'same_kind', 'unsafe'] = ..., order: Literal['K', 'A', 'C', 'F'] | None = ..., subok: bool = ..., signature: tuple[str | None, str | None, str | None] | str | None = ...) -> Any
gwexpy/types/metadata.py:216: note:     def __call__(Buffer | _SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] | complex | bytes | str | _NestedSequence[complex | bytes | str], ndarray[tuple[Any, ...], dtype[generic[Any]]], /, out: ndarray[tuple[Any, ...], dtype[generic[Any]]] | tuple[ndarray[tuple[Any, ...], dtype[generic[Any]]]] | None = ..., *, dtype: type[Any] | dtype[Any] | _SupportsDType[dtype[Any]] | tuple[Any, Any] | list[Any] | _DTypeDict | str | None = ..., where: _SupportsArray[dtype[numpy.bool[builtins.bool]]] | _NestedSequence[_SupportsArray[dtype[numpy.bool[builtins.bool]]]] | builtins.bool | _NestedSequence[builtins.bool] | None = ..., casting: Literal['no', 'equiv', 'safe', 'same_kind', 'unsafe'] = ..., order: Literal['K', 'A', 'C', 'F'] | None = ..., subok: bool = ..., signature: tuple[str | None, str | None, str | None] | str | None = ...) -> ndarray[tuple[Any, ...], dtype[Any]]
gwexpy/types/metadata.py:216: note:     def __call__(ndarray[tuple[Any, ...], dtype[generic[Any]]], Buffer | _SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] | complex | bytes | str | _NestedSequence[complex | bytes | str], /, out: ndarray[tuple[Any, ...], dtype[generic[Any]]] | tuple[ndarray[tuple[Any, ...], dtype[generic[Any]]]] | None = ..., *, dtype: type[Any] | dtype[Any] | _SupportsDType[dtype[Any]] | tuple[Any, Any] | list[Any] | _DTypeDict | str | None = ..., where: _SupportsArray[dtype[numpy.bool[builtins.bool]]] | _NestedSequence[_SupportsArray[dtype[numpy.bool[builtins.bool]]]] | builtins.bool | _NestedSequence[builtins.bool] | None = ..., casting: Literal['no', 'equiv', 'safe', 'same_kind', 'unsafe'] = ..., order: Literal['K', 'A', 'C', 'F'] | None = ..., subok: bool = ..., signature: tuple[str | None, str | None, str | None] | str | None = ...) -> ndarray[tuple[Any, ...], dtype[Any]]
gwexpy/types/metadata.py:216: note:     def __call__(Buffer | _SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] | complex | bytes | str | _NestedSequence[complex | bytes | str], Buffer | _SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] | complex | bytes | str | _NestedSequence[complex | bytes | str], /, out: ndarray[tuple[Any, ...], dtype[generic[Any]]] | tuple[ndarray[tuple[Any, ...], dtype[generic[Any]]]], *, dtype: type[Any] | dtype[Any] | _SupportsDType[dtype[Any]] | tuple[Any, Any] | list[Any] | _DTypeDict | str | None = ..., where: _SupportsArray[dtype[numpy.bool[builtins.bool]]] | _NestedSequence[_SupportsArray[dtype[numpy.bool[builtins.bool]]]] | builtins.bool | _NestedSequence[builtins.bool] | None = ..., casting: Literal['no', 'equiv', 'safe', 'same_kind', 'unsafe'] = ..., order: Literal['K', 'A', 'C', 'F'] | None = ..., subok: bool = ..., signature: tuple[str | None, str | None, str | None] | str | None = ...) -> ndarray[tuple[Any, ...], dtype[Any]]
gwexpy/types/metadata.py:216: note:     def __call__(Buffer | _SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] | complex | bytes | str | _NestedSequence[complex | bytes | str], Buffer | _SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] | complex | bytes | str | _NestedSequence[complex | bytes | str], /, out: ndarray[tuple[Any, ...], dtype[generic[Any]]] | tuple[ndarray[tuple[Any, ...], dtype[generic[Any]]]] | None = ..., *, dtype: type[Any] | dtype[Any] | _SupportsDType[dtype[Any]] | tuple[Any, Any] | list[Any] | _DTypeDict | str | None = ..., where: _SupportsArray[dtype[numpy.bool[builtins.bool]]] | _NestedSequence[_SupportsArray[dtype[numpy.bool[builtins.bool]]]] | builtins.bool | _NestedSequence[builtins.bool] | None = ..., casting: Literal['no', 'equiv', 'safe', 'same_kind', 'unsafe'] = ..., order: Literal['K', 'A', 'C', 'F'] | None = ..., subok: bool = ..., signature: tuple[str | None, str | None, str | None] | str | None = ...) -> ndarray[tuple[Any, ...], dtype[Any]] | Any
gwexpy/types/metadata.py:219: error: No overload variant of "__call__" of "_UFunc_Nin2_Nout1" matches argument types "MetaData", "Any"  [call-overload]
gwexpy/types/metadata.py:219: note: Possible overload variants:
gwexpy/types/metadata.py:219: note:     def __call__(complex | str | bytes | generic[Any], complex | str | bytes | generic[Any], /, out: None = ..., *, dtype: type[Any] | dtype[Any] | _SupportsDType[dtype[Any]] | tuple[Any, Any] | list[Any] | _DTypeDict | str | None = ..., where: _SupportsArray[dtype[numpy.bool[builtins.bool]]] | _NestedSequence[_SupportsArray[dtype[numpy.bool[builtins.bool]]]] | builtins.bool | _NestedSequence[builtins.bool] | None = ..., casting: Literal['no', 'equiv', 'safe', 'same_kind', 'unsafe'] = ..., order: Literal['K', 'A', 'C', 'F'] | None = ..., subok: bool = ..., signature: tuple[str | None, str | None, str | None] | str | None = ...) -> Any
gwexpy/types/metadata.py:219: note:     def __call__(Buffer | _SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] | complex | bytes | str | _NestedSequence[complex | bytes | str], ndarray[tuple[Any, ...], dtype[generic[Any]]], /, out: ndarray[tuple[Any, ...], dtype[generic[Any]]] | tuple[ndarray[tuple[Any, ...], dtype[generic[Any]]]] | None = ..., *, dtype: type[Any] | dtype[Any] | _SupportsDType[dtype[Any]] | tuple[Any, Any] | list[Any] | _DTypeDict | str | None = ..., where: _SupportsArray[dtype[numpy.bool[builtins.bool]]] | _NestedSequence[_SupportsArray[dtype[numpy.bool[builtins.bool]]]] | builtins.bool | _NestedSequence[builtins.bool] | None = ..., casting: Literal['no', 'equiv', 'safe', 'same_kind', 'unsafe'] = ..., order: Literal['K', 'A', 'C', 'F'] | None = ..., subok: bool = ..., signature: tuple[str | None, str | None, str | None] | str | None = ...) -> ndarray[tuple[Any, ...], dtype[Any]]
gwexpy/types/metadata.py:219: note:     def __call__(ndarray[tuple[Any, ...], dtype[generic[Any]]], Buffer | _SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] | complex | bytes | str | _NestedSequence[complex | bytes | str], /, out: ndarray[tuple[Any, ...], dtype[generic[Any]]] | tuple[ndarray[tuple[Any, ...], dtype[generic[Any]]]] | None = ..., *, dtype: type[Any] | dtype[Any] | _SupportsDType[dtype[Any]] | tuple[Any, Any] | list[Any] | _DTypeDict | str | None = ..., where: _SupportsArray[dtype[numpy.bool[builtins.bool]]] | _NestedSequence[_SupportsArray[dtype[numpy.bool[builtins.bool]]]] | builtins.bool | _NestedSequence[builtins.bool] | None = ..., casting: Literal['no', 'equiv', 'safe', 'same_kind', 'unsafe'] = ..., order: Literal['K', 'A', 'C', 'F'] | None = ..., subok: bool = ..., signature: tuple[str | None, str | None, str | None] | str | None = ...) -> ndarray[tuple[Any, ...], dtype[Any]]
gwexpy/types/metadata.py:219: note:     def __call__(Buffer | _SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] | complex | bytes | str | _NestedSequence[complex | bytes | str], Buffer | _SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] | complex | bytes | str | _NestedSequence[complex | bytes | str], /, out: ndarray[tuple[Any, ...], dtype[generic[Any]]] | tuple[ndarray[tuple[Any, ...], dtype[generic[Any]]]], *, dtype: type[Any] | dtype[Any] | _SupportsDType[dtype[Any]] | tuple[Any, Any] | list[Any] | _DTypeDict | str | None = ..., where: _SupportsArray[dtype[numpy.bool[builtins.bool]]] | _NestedSequence[_SupportsArray[dtype[numpy.bool[builtins.bool]]]] | builtins.bool | _NestedSequence[builtins.bool] | None = ..., casting: Literal['no', 'equiv', 'safe', 'same_kind', 'unsafe'] = ..., order: Literal['K', 'A', 'C', 'F'] | None = ..., subok: bool = ..., signature: tuple[str | None, str | None, str | None] | str | None = ...) -> ndarray[tuple[Any, ...], dtype[Any]]
gwexpy/types/metadata.py:219: note:     def __call__(Buffer | _SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] | complex | bytes | str | _NestedSequence[complex | bytes | str], Buffer | _SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] | complex | bytes | str | _NestedSequence[complex | bytes | str], /, out: ndarray[tuple[Any, ...], dtype[generic[Any]]] | tuple[ndarray[tuple[Any, ...], dtype[generic[Any]]]] | None = ..., *, dtype: type[Any] | dtype[Any] | _SupportsDType[dtype[Any]] | tuple[Any, Any] | list[Any] | _DTypeDict | str | None = ..., where: _SupportsArray[dtype[numpy.bool[builtins.bool]]] | _NestedSequence[_SupportsArray[dtype[numpy.bool[builtins.bool]]]] | builtins.bool | _NestedSequence[builtins.bool] | None = ..., casting: Literal['no', 'equiv', 'safe', 'same_kind', 'unsafe'] = ..., order: Literal['K', 'A', 'C', 'F'] | None = ..., subok: bool = ..., signature: tuple[str | None, str | None, str | None] | str | None = ...) -> ndarray[tuple[Any, ...], dtype[Any]] | Any
gwexpy/types/metadata.py:222: error: No overload variant of "__call__" of "_UFunc_Nin2_Nout1" matches argument types "Any", "MetaData"  [call-overload]
gwexpy/types/metadata.py:222: note: Possible overload variants:
gwexpy/types/metadata.py:222: note:     def __call__(complex | str | bytes | generic[Any], complex | str | bytes | generic[Any], /, out: None = ..., *, dtype: type[Any] | dtype[Any] | _SupportsDType[dtype[Any]] | tuple[Any, Any] | list[Any] | _DTypeDict | str | None = ..., where: _SupportsArray[dtype[numpy.bool[builtins.bool]]] | _NestedSequence[_SupportsArray[dtype[numpy.bool[builtins.bool]]]] | builtins.bool | _NestedSequence[builtins.bool] | None = ..., casting: Literal['no', 'equiv', 'safe', 'same_kind', 'unsafe'] = ..., order: Literal['K', 'A', 'C', 'F'] | None = ..., subok: bool = ..., signature: tuple[str | None, str | None, str | None] | str | None = ...) -> Any
gwexpy/types/metadata.py:222: note:     def __call__(Buffer | _SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] | complex | bytes | str | _NestedSequence[complex | bytes | str], ndarray[tuple[Any, ...], dtype[generic[Any]]], /, out: ndarray[tuple[Any, ...], dtype[generic[Any]]] | tuple[ndarray[tuple[Any, ...], dtype[generic[Any]]]] | None = ..., *, dtype: type[Any] | dtype[Any] | _SupportsDType[dtype[Any]] | tuple[Any, Any] | list[Any] | _DTypeDict | str | None = ..., where: _SupportsArray[dtype[numpy.bool[builtins.bool]]] | _NestedSequence[_SupportsArray[dtype[numpy.bool[builtins.bool]]]] | builtins.bool | _NestedSequence[builtins.bool] | None = ..., casting: Literal['no', 'equiv', 'safe', 'same_kind', 'unsafe'] = ..., order: Literal['K', 'A', 'C', 'F'] | None = ..., subok: bool = ..., signature: tuple[str | None, str | None, str | None] | str | None = ...) -> ndarray[tuple[Any, ...], dtype[Any]]
gwexpy/types/metadata.py:222: note:     def __call__(ndarray[tuple[Any, ...], dtype[generic[Any]]], Buffer | _SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] | complex | bytes | str | _NestedSequence[complex | bytes | str], /, out: ndarray[tuple[Any, ...], dtype[generic[Any]]] | tuple[ndarray[tuple[Any, ...], dtype[generic[Any]]]] | None = ..., *, dtype: type[Any] | dtype[Any] | _SupportsDType[dtype[Any]] | tuple[Any, Any] | list[Any] | _DTypeDict | str | None = ..., where: _SupportsArray[dtype[numpy.bool[builtins.bool]]] | _NestedSequence[_SupportsArray[dtype[numpy.bool[builtins.bool]]]] | builtins.bool | _NestedSequence[builtins.bool] | None = ..., casting: Literal['no', 'equiv', 'safe', 'same_kind', 'unsafe'] = ..., order: Literal['K', 'A', 'C', 'F'] | None = ..., subok: bool = ..., signature: tuple[str | None, str | None, str | None] | str | None = ...) -> ndarray[tuple[Any, ...], dtype[Any]]
gwexpy/types/metadata.py:222: note:     def __call__(Buffer | _SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] | complex | bytes | str | _NestedSequence[complex | bytes | str], Buffer | _SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] | complex | bytes | str | _NestedSequence[complex | bytes | str], /, out: ndarray[tuple[Any, ...], dtype[generic[Any]]] | tuple[ndarray[tuple[Any, ...], dtype[generic[Any]]]], *, dtype: type[Any] | dtype[Any] | _SupportsDType[dtype[Any]] | tuple[Any, Any] | list[Any] | _DTypeDict | str | None = ..., where: _SupportsArray[dtype[numpy.bool[builtins.bool]]] | _NestedSequence[_SupportsArray[dtype[numpy.bool[builtins.bool]]]] | builtins.bool | _NestedSequence[builtins.bool] | None = ..., casting: Literal['no', 'equiv', 'safe', 'same_kind', 'unsafe'] = ..., order: Literal['K', 'A', 'C', 'F'] | None = ..., subok: bool = ..., signature: tuple[str | None, str | None, str | None] | str | None = ...) -> ndarray[tuple[Any, ...], dtype[Any]]
gwexpy/types/metadata.py:222: note:     def __call__(Buffer | _SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] | complex | bytes | str | _NestedSequence[complex | bytes | str], Buffer | _SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] | complex | bytes | str | _NestedSequence[complex | bytes | str], /, out: ndarray[tuple[Any, ...], dtype[generic[Any]]] | tuple[ndarray[tuple[Any, ...], dtype[generic[Any]]]] | None = ..., *, dtype: type[Any] | dtype[Any] | _SupportsDType[dtype[Any]] | tuple[Any, Any] | list[Any] | _DTypeDict | str | None = ..., where: _SupportsArray[dtype[numpy.bool[builtins.bool]]] | _NestedSequence[_SupportsArray[dtype[numpy.bool[builtins.bool]]]] | builtins.bool | _NestedSequence[builtins.bool] | None = ..., casting: Literal['no', 'equiv', 'safe', 'same_kind', 'unsafe'] = ..., order: Literal['K', 'A', 'C', 'F'] | None = ..., subok: bool = ..., signature: tuple[str | None, str | None, str | None] | str | None = ...) -> ndarray[tuple[Any, ...], dtype[Any]] | Any
gwexpy/types/metadata.py:225: error: No overload variant of "__call__" of "_UFunc_Nin2_Nout1" matches argument types "MetaData", "Any"  [call-overload]
gwexpy/types/metadata.py:225: note: Possible overload variants:
gwexpy/types/metadata.py:225: note:     def __call__(complex | str | bytes | generic[Any], complex | str | bytes | generic[Any], /, out: None = ..., *, dtype: type[Any] | dtype[Any] | _SupportsDType[dtype[Any]] | tuple[Any, Any] | list[Any] | _DTypeDict | str | None = ..., where: _SupportsArray[dtype[numpy.bool[builtins.bool]]] | _NestedSequence[_SupportsArray[dtype[numpy.bool[builtins.bool]]]] | builtins.bool | _NestedSequence[builtins.bool] | None = ..., casting: Literal['no', 'equiv', 'safe', 'same_kind', 'unsafe'] = ..., order: Literal['K', 'A', 'C', 'F'] | None = ..., subok: bool = ..., signature: tuple[str | None, str | None, str | None] | str | None = ...) -> Any
gwexpy/types/metadata.py:225: note:     def __call__(Buffer | _SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] | complex | bytes | str | _NestedSequence[complex | bytes | str], ndarray[tuple[Any, ...], dtype[generic[Any]]], /, out: ndarray[tuple[Any, ...], dtype[generic[Any]]] | tuple[ndarray[tuple[Any, ...], dtype[generic[Any]]]] | None = ..., *, dtype: type[Any] | dtype[Any] | _SupportsDType[dtype[Any]] | tuple[Any, Any] | list[Any] | _DTypeDict | str | None = ..., where: _SupportsArray[dtype[numpy.bool[builtins.bool]]] | _NestedSequence[_SupportsArray[dtype[numpy.bool[builtins.bool]]]] | builtins.bool | _NestedSequence[builtins.bool] | None = ..., casting: Literal['no', 'equiv', 'safe', 'same_kind', 'unsafe'] = ..., order: Literal['K', 'A', 'C', 'F'] | None = ..., subok: bool = ..., signature: tuple[str | None, str | None, str | None] | str | None = ...) -> ndarray[tuple[Any, ...], dtype[Any]]
gwexpy/types/metadata.py:225: note:     def __call__(ndarray[tuple[Any, ...], dtype[generic[Any]]], Buffer | _SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] | complex | bytes | str | _NestedSequence[complex | bytes | str], /, out: ndarray[tuple[Any, ...], dtype[generic[Any]]] | tuple[ndarray[tuple[Any, ...], dtype[generic[Any]]]] | None = ..., *, dtype: type[Any] | dtype[Any] | _SupportsDType[dtype[Any]] | tuple[Any, Any] | list[Any] | _DTypeDict | str | None = ..., where: _SupportsArray[dtype[numpy.bool[builtins.bool]]] | _NestedSequence[_SupportsArray[dtype[numpy.bool[builtins.bool]]]] | builtins.bool | _NestedSequence[builtins.bool] | None = ..., casting: Literal['no', 'equiv', 'safe', 'same_kind', 'unsafe'] = ..., order: Literal['K', 'A', 'C', 'F'] | None = ..., subok: bool = ..., signature: tuple[str | None, str | None, str | None] | str | None = ...) -> ndarray[tuple[Any, ...], dtype[Any]]
gwexpy/types/metadata.py:225: note:     def __call__(Buffer | _SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] | complex | bytes | str | _NestedSequence[complex | bytes | str], Buffer | _SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] | complex | bytes | str | _NestedSequence[complex | bytes | str], /, out: ndarray[tuple[Any, ...], dtype[generic[Any]]] | tuple[ndarray[tuple[Any, ...], dtype[generic[Any]]]], *, dtype: type[Any] | dtype[Any] | _SupportsDType[dtype[Any]] | tuple[Any, Any] | list[Any] | _DTypeDict | str | None = ..., where: _SupportsArray[dtype[numpy.bool[builtins.bool]]] | _NestedSequence[_SupportsArray[dtype[numpy.bool[builtins.bool]]]] | builtins.bool | _NestedSequence[builtins.bool] | None = ..., casting: Literal['no', 'equiv', 'safe', 'same_kind', 'unsafe'] = ..., order: Literal['K', 'A', 'C', 'F'] | None = ..., subok: bool = ..., signature: tuple[str | None, str | None, str | None] | str | None = ...) -> ndarray[tuple[Any, ...], dtype[Any]]
gwexpy/types/metadata.py:225: note:     def __call__(Buffer | _SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] | complex | bytes | str | _NestedSequence[complex | bytes | str], Buffer | _SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] | complex | bytes | str | _NestedSequence[complex | bytes | str], /, out: ndarray[tuple[Any, ...], dtype[generic[Any]]] | tuple[ndarray[tuple[Any, ...], dtype[generic[Any]]]] | None = ..., *, dtype: type[Any] | dtype[Any] | _SupportsDType[dtype[Any]] | tuple[Any, Any] | list[Any] | _DTypeDict | str | None = ..., where: _SupportsArray[dtype[numpy.bool[builtins.bool]]] | _NestedSequence[_SupportsArray[dtype[numpy.bool[builtins.bool]]]] | builtins.bool | _NestedSequence[builtins.bool] | None = ..., casting: Literal['no', 'equiv', 'safe', 'same_kind', 'unsafe'] = ..., order: Literal['K', 'A', 'C', 'F'] | None = ..., subok: bool = ..., signature: tuple[str | None, str | None, str | None] | str | None = ...) -> ndarray[tuple[Any, ...], dtype[Any]] | Any
gwexpy/types/metadata.py:228: error: No overload variant of "__call__" of "_UFunc_Nin2_Nout1" matches argument types "Any", "MetaData"  [call-overload]
gwexpy/types/metadata.py:228: note: Possible overload variants:
gwexpy/types/metadata.py:228: note:     def __call__(complex | str | bytes | generic[Any], complex | str | bytes | generic[Any], /, out: None = ..., *, dtype: type[Any] | dtype[Any] | _SupportsDType[dtype[Any]] | tuple[Any, Any] | list[Any] | _DTypeDict | str | None = ..., where: _SupportsArray[dtype[numpy.bool[builtins.bool]]] | _NestedSequence[_SupportsArray[dtype[numpy.bool[builtins.bool]]]] | builtins.bool | _NestedSequence[builtins.bool] | None = ..., casting: Literal['no', 'equiv', 'safe', 'same_kind', 'unsafe'] = ..., order: Literal['K', 'A', 'C', 'F'] | None = ..., subok: bool = ..., signature: tuple[str | None, str | None, str | None] | str | None = ...) -> Any
gwexpy/types/metadata.py:228: note:     def __call__(Buffer | _SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] | complex | bytes | str | _NestedSequence[complex | bytes | str], ndarray[tuple[Any, ...], dtype[generic[Any]]], /, out: ndarray[tuple[Any, ...], dtype[generic[Any]]] | tuple[ndarray[tuple[Any, ...], dtype[generic[Any]]]] | None = ..., *, dtype: type[Any] | dtype[Any] | _SupportsDType[dtype[Any]] | tuple[Any, Any] | list[Any] | _DTypeDict | str | None = ..., where: _SupportsArray[dtype[numpy.bool[builtins.bool]]] | _NestedSequence[_SupportsArray[dtype[numpy.bool[builtins.bool]]]] | builtins.bool | _NestedSequence[builtins.bool] | None = ..., casting: Literal['no', 'equiv', 'safe', 'same_kind', 'unsafe'] = ..., order: Literal['K', 'A', 'C', 'F'] | None = ..., subok: bool = ..., signature: tuple[str | None, str | None, str | None] | str | None = ...) -> ndarray[tuple[Any, ...], dtype[Any]]
gwexpy/types/metadata.py:228: note:     def __call__(ndarray[tuple[Any, ...], dtype[generic[Any]]], Buffer | _SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] | complex | bytes | str | _NestedSequence[complex | bytes | str], /, out: ndarray[tuple[Any, ...], dtype[generic[Any]]] | tuple[ndarray[tuple[Any, ...], dtype[generic[Any]]]] | None = ..., *, dtype: type[Any] | dtype[Any] | _SupportsDType[dtype[Any]] | tuple[Any, Any] | list[Any] | _DTypeDict | str | None = ..., where: _SupportsArray[dtype[numpy.bool[builtins.bool]]] | _NestedSequence[_SupportsArray[dtype[numpy.bool[builtins.bool]]]] | builtins.bool | _NestedSequence[builtins.bool] | None = ..., casting: Literal['no', 'equiv', 'safe', 'same_kind', 'unsafe'] = ..., order: Literal['K', 'A', 'C', 'F'] | None = ..., subok: bool = ..., signature: tuple[str | None, str | None, str | None] | str | None = ...) -> ndarray[tuple[Any, ...], dtype[Any]]
gwexpy/types/metadata.py:228: note:     def __call__(Buffer | _SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] | complex | bytes | str | _NestedSequence[complex | bytes | str], Buffer | _SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] | complex | bytes | str | _NestedSequence[complex | bytes | str], /, out: ndarray[tuple[Any, ...], dtype[generic[Any]]] | tuple[ndarray[tuple[Any, ...], dtype[generic[Any]]]], *, dtype: type[Any] | dtype[Any] | _SupportsDType[dtype[Any]] | tuple[Any, Any] | list[Any] | _DTypeDict | str | None = ..., where: _SupportsArray[dtype[numpy.bool[builtins.bool]]] | _NestedSequence[_SupportsArray[dtype[numpy.bool[builtins.bool]]]] | builtins.bool | _NestedSequence[builtins.bool] | None = ..., casting: Literal['no', 'equiv', 'safe', 'same_kind', 'unsafe'] = ..., order: Literal['K', 'A', 'C', 'F'] | None = ..., subok: bool = ..., signature: tuple[str | None, str | None, str | None] | str | None = ...) -> ndarray[tuple[Any, ...], dtype[Any]]
gwexpy/types/metadata.py:228: note:     def __call__(Buffer | _SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] | complex | bytes | str | _NestedSequence[complex | bytes | str], Buffer | _SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] | complex | bytes | str | _NestedSequence[complex | bytes | str], /, out: ndarray[tuple[Any, ...], dtype[generic[Any]]] | tuple[ndarray[tuple[Any, ...], dtype[generic[Any]]]] | None = ..., *, dtype: type[Any] | dtype[Any] | _SupportsDType[dtype[Any]] | tuple[Any, Any] | list[Any] | _DTypeDict | str | None = ..., where: _SupportsArray[dtype[numpy.bool[builtins.bool]]] | _NestedSequence[_SupportsArray[dtype[numpy.bool[builtins.bool]]]] | builtins.bool | _NestedSequence[builtins.bool] | None = ..., casting: Literal['no', 'equiv', 'safe', 'same_kind', 'unsafe'] = ..., order: Literal['K', 'A', 'C', 'F'] | None = ..., subok: bool = ..., signature: tuple[str | None, str | None, str | None] | str | None = ...) -> ndarray[tuple[Any, ...], dtype[Any]] | Any
gwexpy/types/metadata.py:231: error: No overload variant of "__call__" of "_UFunc_Nin2_Nout1" matches argument types "MetaData", "Any"  [call-overload]
gwexpy/types/metadata.py:231: note: Possible overload variants:
gwexpy/types/metadata.py:231: note:     def __call__(complex | str | bytes | generic[Any], complex | str | bytes | generic[Any], /, out: None = ..., *, dtype: type[Any] | dtype[Any] | _SupportsDType[dtype[Any]] | tuple[Any, Any] | list[Any] | _DTypeDict | str | None = ..., where: _SupportsArray[dtype[numpy.bool[builtins.bool]]] | _NestedSequence[_SupportsArray[dtype[numpy.bool[builtins.bool]]]] | builtins.bool | _NestedSequence[builtins.bool] | None = ..., casting: Literal['no', 'equiv', 'safe', 'same_kind', 'unsafe'] = ..., order: Literal['K', 'A', 'C', 'F'] | None = ..., subok: bool = ..., signature: tuple[str | None, str | None, str | None] | str | None = ...) -> Any
gwexpy/types/metadata.py:231: note:     def __call__(Buffer | _SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] | complex | bytes | str | _NestedSequence[complex | bytes | str], ndarray[tuple[Any, ...], dtype[generic[Any]]], /, out: ndarray[tuple[Any, ...], dtype[generic[Any]]] | tuple[ndarray[tuple[Any, ...], dtype[generic[Any]]]] | None = ..., *, dtype: type[Any] | dtype[Any] | _SupportsDType[dtype[Any]] | tuple[Any, Any] | list[Any] | _DTypeDict | str | None = ..., where: _SupportsArray[dtype[numpy.bool[builtins.bool]]] | _NestedSequence[_SupportsArray[dtype[numpy.bool[builtins.bool]]]] | builtins.bool | _NestedSequence[builtins.bool] | None = ..., casting: Literal['no', 'equiv', 'safe', 'same_kind', 'unsafe'] = ..., order: Literal['K', 'A', 'C', 'F'] | None = ..., subok: bool = ..., signature: tuple[str | None, str | None, str | None] | str | None = ...) -> ndarray[tuple[Any, ...], dtype[Any]]
gwexpy/types/metadata.py:231: note:     def __call__(ndarray[tuple[Any, ...], dtype[generic[Any]]], Buffer | _SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] | complex | bytes | str | _NestedSequence[complex | bytes | str], /, out: ndarray[tuple[Any, ...], dtype[generic[Any]]] | tuple[ndarray[tuple[Any, ...], dtype[generic[Any]]]] | None = ..., *, dtype: type[Any] | dtype[Any] | _SupportsDType[dtype[Any]] | tuple[Any, Any] | list[Any] | _DTypeDict | str | None = ..., where: _SupportsArray[dtype[numpy.bool[builtins.bool]]] | _NestedSequence[_SupportsArray[dtype[numpy.bool[builtins.bool]]]] | builtins.bool | _NestedSequence[builtins.bool] | None = ..., casting: Literal['no', 'equiv', 'safe', 'same_kind', 'unsafe'] = ..., order: Literal['K', 'A', 'C', 'F'] | None = ..., subok: bool = ..., signature: tuple[str | None, str | None, str | None] | str | None = ...) -> ndarray[tuple[Any, ...], dtype[Any]]
gwexpy/types/metadata.py:231: note:     def __call__(Buffer | _SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] | complex | bytes | str | _NestedSequence[complex | bytes | str], Buffer | _SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] | complex | bytes | str | _NestedSequence[complex | bytes | str], /, out: ndarray[tuple[Any, ...], dtype[generic[Any]]] | tuple[ndarray[tuple[Any, ...], dtype[generic[Any]]]], *, dtype: type[Any] | dtype[Any] | _SupportsDType[dtype[Any]] | tuple[Any, Any] | list[Any] | _DTypeDict | str | None = ..., where: _SupportsArray[dtype[numpy.bool[builtins.bool]]] | _NestedSequence[_SupportsArray[dtype[numpy.bool[builtins.bool]]]] | builtins.bool | _NestedSequence[builtins.bool] | None = ..., casting: Literal['no', 'equiv', 'safe', 'same_kind', 'unsafe'] = ..., order: Literal['K', 'A', 'C', 'F'] | None = ..., subok: bool = ..., signature: tuple[str | None, str | None, str | None] | str | None = ...) -> ndarray[tuple[Any, ...], dtype[Any]]
gwexpy/types/metadata.py:231: note:     def __call__(Buffer | _SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] | complex | bytes | str | _NestedSequence[complex | bytes | str], Buffer | _SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] | complex | bytes | str | _NestedSequence[complex | bytes | str], /, out: ndarray[tuple[Any, ...], dtype[generic[Any]]] | tuple[ndarray[tuple[Any, ...], dtype[generic[Any]]]] | None = ..., *, dtype: type[Any] | dtype[Any] | _SupportsDType[dtype[Any]] | tuple[Any, Any] | list[Any] | _DTypeDict | str | None = ..., where: _SupportsArray[dtype[numpy.bool[builtins.bool]]] | _NestedSequence[_SupportsArray[dtype[numpy.bool[builtins.bool]]]] | builtins.bool | _NestedSequence[builtins.bool] | None = ..., casting: Literal['no', 'equiv', 'safe', 'same_kind', 'unsafe'] = ..., order: Literal['K', 'A', 'C', 'F'] | None = ..., subok: bool = ..., signature: tuple[str | None, str | None, str | None] | str | None = ...) -> ndarray[tuple[Any, ...], dtype[Any]] | Any
gwexpy/types/metadata.py:678: error: Signature of "__pow__" incompatible with supertype "numpy.ndarray"  [override]
gwexpy/types/metadata.py:678: note:      Superclass:
gwexpy/types/metadata.py:678: note:          @overload
gwexpy/types/metadata.py:678: note:          def __pow__(self, int | numpy.bool[builtins.bool], None = ..., /) -> ndarray[tuple[Any, ...], dtype[Any]]
gwexpy/types/metadata.py:678: note:          @overload
gwexpy/types/metadata.py:678: note:          def __pow__(self, _SupportsArray[dtype[numpy.bool[builtins.bool]]] | _NestedSequence[_SupportsArray[dtype[numpy.bool[builtins.bool]]]] | builtins.bool | _NestedSequence[builtins.bool], None = ..., /) -> ndarray[tuple[Any, ...], dtype[Any]]
gwexpy/types/metadata.py:678: note:          @overload
gwexpy/types/metadata.py:678: note:          def __pow__(self, _SupportsArray[dtype[numpy.bool[builtins.bool]]] | _NestedSequence[_SupportsArray[dtype[numpy.bool[builtins.bool]]]] | builtins.bool | _NestedSequence[builtins.bool], None = ..., /) -> ndarray[tuple[Any, ...], dtype[signedinteger[_8Bit]]]
gwexpy/types/metadata.py:678: note:          @overload
gwexpy/types/metadata.py:678: note:          def [_NumberT: number[Any, int | float | complex]] __pow__(self, _SupportsArray[dtype[_NumberT]] | _NestedSequence[_SupportsArray[dtype[_NumberT]]], None = ..., /) -> ndarray[tuple[Any, ...], dtype[_NumberT]]
gwexpy/types/metadata.py:678: note:          @overload
gwexpy/types/metadata.py:678: note:          def __pow__(self, _SupportsArray[dtype[floating[_64Bit] | floating[_32Bit] | floating[_16Bit] | integer[Any] | numpy.bool[builtins.bool]]] | _NestedSequence[_SupportsArray[dtype[floating[_64Bit] | floating[_32Bit] | floating[_16Bit] | integer[Any] | numpy.bool[builtins.bool]]]] | float | _NestedSequence[float], None = ..., /) -> ndarray[tuple[Any, ...], dtype[float64]]
gwexpy/types/metadata.py:678: note:          @overload
gwexpy/types/metadata.py:678: note:          def __pow__(self, _SupportsArray[dtype[floating[_64Bit]]] | _NestedSequence[_SupportsArray[dtype[floating[_64Bit]]]], None = ..., /) -> ndarray[tuple[Any, ...], dtype[float64]]
gwexpy/types/metadata.py:678: note:          @overload
gwexpy/types/metadata.py:678: note:          def __pow__(self, _SupportsArray[dtype[number[_64Bit, int | float | complex] | number[_32Bit, int | float | complex] | floating[_16Bit] | integer[Any] | numpy.bool[builtins.bool]]] | _NestedSequence[_SupportsArray[dtype[number[_64Bit, int | float | complex] | number[_32Bit, int | float | complex] | floating[_16Bit] | integer[Any] | numpy.bool[builtins.bool]]]] | complex | _NestedSequence[complex], None = ..., /) -> ndarray[tuple[Any, ...], dtype[complex128]]
gwexpy/types/metadata.py:678: note:          @overload
gwexpy/types/metadata.py:678: note:          def __pow__(self, _SupportsArray[dtype[complexfloating[_64Bit, _64Bit]]] | _NestedSequence[_SupportsArray[dtype[complexfloating[_64Bit, _64Bit]]]], None = ..., /) -> ndarray[tuple[Any, ...], dtype[complex128]]
gwexpy/types/metadata.py:678: note:          @overload
gwexpy/types/metadata.py:678: note:          def __pow__(self, _SupportsArray[dtype[numpy.bool[builtins.bool] | unsignedinteger[Any]]] | _NestedSequence[_SupportsArray[dtype[numpy.bool[builtins.bool] | unsignedinteger[Any]]]] | builtins.bool | _NestedSequence[builtins.bool], None = ..., /) -> ndarray[tuple[Any, ...], dtype[unsignedinteger[Any]]]
gwexpy/types/metadata.py:678: note:          @overload
gwexpy/types/metadata.py:678: note:          def __pow__(self, _SupportsArray[dtype[numpy.bool[builtins.bool] | integer[Any]]] | _NestedSequence[_SupportsArray[dtype[numpy.bool[builtins.bool] | integer[Any]]]] | int | _NestedSequence[int], None = ..., /) -> ndarray[tuple[Any, ...], dtype[signedinteger[Any]]]
gwexpy/types/metadata.py:678: note:          @overload
gwexpy/types/metadata.py:678: note:          def __pow__(self, _SupportsArray[dtype[numpy.bool[builtins.bool] | integer[Any] | floating[Any]]] | _NestedSequence[_SupportsArray[dtype[numpy.bool[builtins.bool] | integer[Any] | floating[Any]]]] | float | _NestedSequence[float], None = ..., /) -> ndarray[tuple[Any, ...], dtype[floating[Any]]]
gwexpy/types/metadata.py:678: note:          @overload
gwexpy/types/metadata.py:678: note:          def __pow__(self, _SupportsArray[dtype[numpy.bool[builtins.bool] | number[Any, int | float | complex]]] | _NestedSequence[_SupportsArray[dtype[numpy.bool[builtins.bool] | number[Any, int | float | complex]]]] | complex | _NestedSequence[complex], None = ..., /) -> ndarray[tuple[Any, ...], dtype[complexfloating[Any, Any]]]
gwexpy/types/metadata.py:678: note:          @overload
gwexpy/types/metadata.py:678: note:          def __pow__(self, _SupportsArray[dtype[numpy.bool[builtins.bool] | number[Any, int | float | complex]]] | _NestedSequence[_SupportsArray[dtype[numpy.bool[builtins.bool] | number[Any, int | float | complex]]]] | complex | _NestedSequence[complex], None = ..., /) -> ndarray[tuple[Any, ...], dtype[number[Any, int | float | complex]]]
gwexpy/types/metadata.py:678: note:          @overload
gwexpy/types/metadata.py:678: note:          def __pow__(self, Any, None = ..., /) -> Any
gwexpy/types/metadata.py:678: note:          @overload
gwexpy/types/metadata.py:678: note:          def __pow__(self, _SupportsArray[dtype[object_]] | _NestedSequence[_SupportsArray[dtype[object_]]], None = ..., /) -> Any
gwexpy/types/metadata.py:678: note:      Subclass:
gwexpy/types/metadata.py:678: note:          def __pow__(self, Any, /) -> Any
gwexpy/types/mixin/mixin_legacy.py:80: error: "PhaseMethodsMixin" has no attribute "degree"  [attr-defined]
gwexpy/types/mixin/mixin_legacy.py:81: error: "PhaseMethodsMixin" has no attribute "radian"  [attr-defined]
gwexpy/gui/nds/sim_thread.py:12: error: Name "QtCore.QThread" is not defined  [name-defined]
gwexpy/gui/nds/audio_thread.py:22: error: Name "QtCore.QThread" is not defined  [name-defined]
gwexpy/types/series_matrix_structure.py:175: error: "MetaDataMatrix" has no attribute "value"  [attr-defined]
gwexpy/spectrogram/matrix_analysis.py:54: error: Argument 1 to "iscomplexobj" has incompatible type "_SpectrogramMatrixLike"; expected "_HasDType[Any] | Buffer | _SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] | complex | bytes | str | _NestedSequence[complex | bytes | str]"  [arg-type]
gwexpy/types/axis_api.py:94: error: "AxisApiMixin" has no attribute "copy"  [attr-defined]
gwexpy/types/axis_api.py:185: error: "AxisApiMixin" has no attribute "copy"  [attr-defined]
gwexpy/types/axis_api.py:195: error: Incompatible types in assignment (expression has type "tuple[Any, ...] | list[Any]", variable has type "tuple[Any, ...]")  [assignment]
gwexpy/types/axis_api.py:226: error: "transpose" undefined in superclass  [misc]
gwexpy/timeseries/_resampling.py:622: error: Incompatible types in assignment (expression has type "ndarray[Any, Any] | ndarray[tuple[Any, ...], dtype[signedinteger[_32Bit | _64Bit]]]", variable has type "ndarray[tuple[Any, ...], dtype[float64]]")  [assignment]
gwexpy/interop/obspy_.py:215: error: Incompatible types in assignment (expression has type "ndarray[tuple[int], dtype[Any]]", variable has type "list[Any]")  [assignment]
gwexpy/gui/data_sources.py:23: error: Name "QtCore.QObject" is not defined  [name-defined]
gwexpy/gui/data_sources.py:83: error: Name "QtCore.QTimer" is not defined  [name-defined]
gwexpy/gui/data_sources.py:90: error: Module has no attribute "QTimer"  [attr-defined]
gwexpy/gui/nds/cache.py:43: error: Name "QtCore.QObject" is not defined  [name-defined]
gwexpy/types/series_matrix_io.py:81: error: Argument 1 to "tile" has incompatible type "XIndex | Any | ndarray[tuple[Any, ...], dtype[Any]] | None"; expected "_SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]]"  [arg-type]
gwexpy/timeseries/utils.py:114: error: Incompatible types in assignment (expression has type "builtins.bool", variable has type "numpy.bool[builtins.bool]")  [assignment]
gwexpy/timeseries/utils.py:245: error: Incompatible types in assignment (expression has type "builtins.bool", variable has type "numpy.bool[builtins.bool]")  [assignment]
gwexpy/types/mixin/signal_interop.py:52: error: "SignalAnalysisMixin" has no attribute "value"  [attr-defined]
gwexpy/types/mixin/signal_interop.py:53: error: "SignalAnalysisMixin" has no attribute "value"  [attr-defined]
gwexpy/types/mixin/signal_interop.py:55: error: "SignalAnalysisMixin" has no attribute "unit"  [attr-defined]
gwexpy/types/mixin/signal_interop.py:58: error: "SignalAnalysisMixin" has no attribute "value"  [attr-defined]
gwexpy/types/mixin/signal_interop.py:72: error: "SignalAnalysisMixin" has no attribute "unit"  [attr-defined]
gwexpy/types/mixin/signal_interop.py:74: error: "SignalAnalysisMixin" has no attribute "value"  [attr-defined]
gwexpy/types/mixin/signal_interop.py:88: error: "SignalAnalysisMixin" has no attribute "unit"  [attr-defined]
gwexpy/types/mixin/signal_interop.py:91: error: "SignalAnalysisMixin" has no attribute "value"  [attr-defined]
gwexpy/types/mixin/signal_interop.py:121: error: "SignalAnalysisMixin" has no attribute "copy"  [attr-defined]
gwexpy/types/mixin/signal_interop.py:128: error: Too many arguments for "SignalAnalysisMixin"  [call-arg]
gwexpy/types/mixin/signal_interop.py:128: error: Unexpected keyword argument "unit" for "SignalAnalysisMixin"  [call-arg]
gwexpy/types/mixin/signal_interop.py:131: error: "SignalAnalysisMixin" has no attribute "name"  [attr-defined]
gwexpy/types/mixin/signal_interop.py:132: error: "SignalAnalysisMixin" has no attribute "channel"  [attr-defined]
/home/washimi/miniforge3/envs/ws-base/lib/python3.12/site-packages/mypy/typeshed/stdlib/builtins.pyi:117: note: "SignalAnalysisMixin" defined here
gwexpy/types/mixin/signal_interop.py:128: error: Unexpected keyword argument "name" for "SignalAnalysisMixin"  [call-arg]
gwexpy/types/mixin/signal_interop.py:128: error: Unexpected keyword argument "channel" for "SignalAnalysisMixin"  [call-arg]
gwexpy/types/mixin/signal_interop.py:163: error: "SignalAnalysisMixin" has no attribute "value"  [attr-defined]
gwexpy/types/mixin/signal_interop.py:165: error: "SignalAnalysisMixin" has no attribute "value"  [attr-defined]
gwexpy/types/mixin/signal_interop.py:167: error: "SignalAnalysisMixin" has no attribute "value"  [attr-defined]
gwexpy/types/mixin/signal_interop.py:173: error: "SignalAnalysisMixin" has no attribute "unit"  [attr-defined]
gwexpy/types/mixin/signal_interop.py:241: error: Value of type "SignalAnalysisMixin" is not indexable  [index]
gwexpy/types/mixin/signal_interop.py:244: error: Value of type "SignalAnalysisMixin" is not indexable  [index]
gwexpy/types/mixin/signal_interop.py:245: error: "SignalAnalysisMixin" has no attribute "name"  [attr-defined]
gwexpy/types/mixin/signal_interop.py:246: error: "SignalAnalysisMixin" has no attribute "name"  [attr-defined]
gwexpy/types/array3d.py:160: error: Value of type "Any | None" is not indexable  [index]
gwexpy/frequencyseries/bifrequencymap.py:460: error: Incompatible types in assignment (expression has type overloaded function, variable has type overloaded function)  [assignment]
gwexpy/frequencyseries/bifrequencymap.py:462: error: Incompatible types in assignment (expression has type overloaded function, variable has type overloaded function)  [assignment]
gwexpy/frequencyseries/bifrequencymap.py:464: error: Incompatible types in assignment (expression has type overloaded function, variable has type overloaded function)  [assignment]
gwexpy/frequencyseries/bifrequencymap.py:466: error: Incompatible types in assignment (expression has type overloaded function, variable has type overloaded function)  [assignment]
gwexpy/frequencyseries/bifrequencymap.py:475: error: Incompatible redefinition (redefinition with type "Callable[[Any], Any]", original type overloaded function)  [misc]
gwexpy/frequencyseries/bifrequencymap.py:720: error: List comprehension has incompatible type List[ndarray[tuple[int, int], dtype[Any]]]; expected List[ndarray[tuple[int, int, int], dtype[Any]]]  [misc]
gwexpy/analysis/bruco.py:229: error: No overload variant of "__call__" of "_UFunc_Nin2_Nout1" matches argument types "ndarray[tuple[int, int], dtype[Any]]", "None"  [call-overload]
gwexpy/analysis/bruco.py:229: note: Possible overload variants:
gwexpy/analysis/bruco.py:229: note:     def __call__(complex | str | bytes | generic[Any], complex | str | bytes | generic[Any], /, out: None = ..., *, dtype: type[Any] | dtype[Any] | _SupportsDType[dtype[Any]] | tuple[Any, Any] | list[Any] | _DTypeDict | str | None = ..., where: _SupportsArray[dtype[numpy.bool[builtins.bool]]] | _NestedSequence[_SupportsArray[dtype[numpy.bool[builtins.bool]]]] | builtins.bool | _NestedSequence[builtins.bool] | None = ..., casting: Literal['no', 'equiv', 'safe', 'same_kind', 'unsafe'] = ..., order: Literal['K', 'A', 'C', 'F'] | None = ..., subok: bool = ..., signature: tuple[str | None, str | None, str | None] | str | None = ...) -> Any
gwexpy/analysis/bruco.py:229: note:     def __call__(Buffer | _SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] | complex | bytes | str | _NestedSequence[complex | bytes | str], ndarray[tuple[Any, ...], dtype[generic[Any]]], /, out: ndarray[tuple[Any, ...], dtype[generic[Any]]] | tuple[ndarray[tuple[Any, ...], dtype[generic[Any]]]] | None = ..., *, dtype: type[Any] | dtype[Any] | _SupportsDType[dtype[Any]] | tuple[Any, Any] | list[Any] | _DTypeDict | str | None = ..., where: _SupportsArray[dtype[numpy.bool[builtins.bool]]] | _NestedSequence[_SupportsArray[dtype[numpy.bool[builtins.bool]]]] | builtins.bool | _NestedSequence[builtins.bool] | None = ..., casting: Literal['no', 'equiv', 'safe', 'same_kind', 'unsafe'] = ..., order: Literal['K', 'A', 'C', 'F'] | None = ..., subok: bool = ..., signature: tuple[str | None, str | None, str | None] | str | None = ...) -> ndarray[tuple[Any, ...], dtype[Any]]
gwexpy/analysis/bruco.py:229: note:     def __call__(ndarray[tuple[Any, ...], dtype[generic[Any]]], Buffer | _SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] | complex | bytes | str | _NestedSequence[complex | bytes | str], /, out: ndarray[tuple[Any, ...], dtype[generic[Any]]] | tuple[ndarray[tuple[Any, ...], dtype[generic[Any]]]] | None = ..., *, dtype: type[Any] | dtype[Any] | _SupportsDType[dtype[Any]] | tuple[Any, Any] | list[Any] | _DTypeDict | str | None = ..., where: _SupportsArray[dtype[numpy.bool[builtins.bool]]] | _NestedSequence[_SupportsArray[dtype[numpy.bool[builtins.bool]]]] | builtins.bool | _NestedSequence[builtins.bool] | None = ..., casting: Literal['no', 'equiv', 'safe', 'same_kind', 'unsafe'] = ..., order: Literal['K', 'A', 'C', 'F'] | None = ..., subok: bool = ..., signature: tuple[str | None, str | None, str | None] | str | None = ...) -> ndarray[tuple[Any, ...], dtype[Any]]
gwexpy/analysis/bruco.py:229: note:     def __call__(Buffer | _SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] | complex | bytes | str | _NestedSequence[complex | bytes | str], Buffer | _SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] | complex | bytes | str | _NestedSequence[complex | bytes | str], /, out: ndarray[tuple[Any, ...], dtype[generic[Any]]] | tuple[ndarray[tuple[Any, ...], dtype[generic[Any]]]], *, dtype: type[Any] | dtype[Any] | _SupportsDType[dtype[Any]] | tuple[Any, Any] | list[Any] | _DTypeDict | str | None = ..., where: _SupportsArray[dtype[numpy.bool[builtins.bool]]] | _NestedSequence[_SupportsArray[dtype[numpy.bool[builtins.bool]]]] | builtins.bool | _NestedSequence[builtins.bool] | None = ..., casting: Literal['no', 'equiv', 'safe', 'same_kind', 'unsafe'] = ..., order: Literal['K', 'A', 'C', 'F'] | None = ..., subok: bool = ..., signature: tuple[str | None, str | None, str | None] | str | None = ...) -> ndarray[tuple[Any, ...], dtype[Any]]
gwexpy/analysis/bruco.py:229: note:     def __call__(Buffer | _SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] | complex | bytes | str | _NestedSequence[complex | bytes | str], Buffer | _SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] | complex | bytes | str | _NestedSequence[complex | bytes | str], /, out: ndarray[tuple[Any, ...], dtype[generic[Any]]] | tuple[ndarray[tuple[Any, ...], dtype[generic[Any]]]] | None = ..., *, dtype: type[Any] | dtype[Any] | _SupportsDType[dtype[Any]] | tuple[Any, Any] | list[Any] | _DTypeDict | str | None = ..., where: _SupportsArray[dtype[numpy.bool[builtins.bool]]] | _NestedSequence[_SupportsArray[dtype[numpy.bool[builtins.bool]]]] | builtins.bool | _NestedSequence[builtins.bool] | None = ..., casting: Literal['no', 'equiv', 'safe', 'same_kind', 'unsafe'] = ..., order: Literal['K', 'A', 'C', 'F'] | None = ..., subok: bool = ..., signature: tuple[str | None, str | None, str | None] | str | None = ...) -> ndarray[tuple[Any, ...], dtype[Any]] | Any
gwexpy/types/seriesmatrix_validation.py:420: error: Item "ndarray[Any, Any]" of "ndarray[Any, Any] | Any" has no attribute "unit"  [union-attr]
gwexpy/types/seriesmatrix_validation.py:421: error: Item "ndarray[Any, Any]" of "ndarray[Any, Any] | Any" has no attribute "value"  [union-attr]
gwexpy/types/series_matrix_validation_mixin.py:100: error: Item "ndarray[tuple[Any, ...], dtype[Any]]" of "ndarray[tuple[Any, ...], dtype[Any]] | Any | Any" has no attribute "to_value"  [union-attr]
gwexpy/types/series_matrix_validation_mixin.py:101: error: Item "ndarray[tuple[Any, ...], dtype[Any]]" of "ndarray[tuple[Any, ...], dtype[Any]] | Any | Any" has no attribute "to_value"  [union-attr]
gwexpy/types/series_matrix_math.py:92: error: No overload variant of "__call__" of "_GUFunc_Nin2_Nout1" matches argument types "SeriesMatrixMathMixin", "Any"  [call-overload]
gwexpy/types/series_matrix_math.py:92: note: Possible overload variants:
gwexpy/types/series_matrix_math.py:92: note:     def __call__(self, Buffer | _SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] | complex | bytes | str | _NestedSequence[complex | bytes | str], Buffer | _SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] | complex | bytes | str | _NestedSequence[complex | bytes | str], /, out: None = ..., *, casting: Literal['no', 'equiv', 'safe', 'same_kind', 'unsafe'] = ..., order: Literal['K', 'A', 'C', 'F'] | None = ..., dtype: type[Any] | dtype[Any] | _SupportsDType[dtype[Any]] | tuple[Any, Any] | list[Any] | _DTypeDict | str | None = ..., subok: bool = ..., signature: str | tuple[str | None, str | None, str | None] = ..., axes: list[tuple[SupportsIndex, SupportsIndex]] = ...) -> Any
gwexpy/types/series_matrix_math.py:92: note:     def __call__(self, Buffer | _SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] | complex | bytes | str | _NestedSequence[complex | bytes | str], Buffer | _SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] | complex | bytes | str | _NestedSequence[complex | bytes | str], /, out: ndarray[tuple[Any, ...], dtype[Any]] | tuple[ndarray[tuple[Any, ...], dtype[Any]]], *, casting: Literal['no', 'equiv', 'safe', 'same_kind', 'unsafe'] = ..., order: Literal['K', 'A', 'C', 'F'] | None = ..., dtype: type[Any] | dtype[Any] | _SupportsDType[dtype[Any]] | tuple[Any, Any] | list[Any] | _DTypeDict | str | None = ..., subok: bool = ..., signature: str | tuple[str | None, str | None, str | None] = ..., axes: list[tuple[SupportsIndex, SupportsIndex]] = ...) -> ndarray[tuple[Any, ...], dtype[Any]]
gwexpy/types/series_matrix_math.py:420: error: No overload variant of "__call__" of "_UFunc_Nin1_Nout1" matches argument type "SeriesMatrixMathMixin"  [call-overload]
gwexpy/types/series_matrix_math.py:420: note: Possible overload variants:
gwexpy/types/series_matrix_math.py:420: note:     def __call__(self, complex | str | bytes | generic[Any], /, out: None = ..., *, where: _SupportsArray[dtype[numpy.bool[builtins.bool]]] | _NestedSequence[_SupportsArray[dtype[numpy.bool[builtins.bool]]]] | builtins.bool | _NestedSequence[builtins.bool] | None = ..., casting: Literal['no', 'equiv', 'safe', 'same_kind', 'unsafe'] = ..., order: Literal['K', 'A', 'C', 'F'] | None = ..., dtype: type[Any] | dtype[Any] | _SupportsDType[dtype[Any]] | tuple[Any, Any] | list[Any] | _DTypeDict | str | None = ..., subok: bool = ..., signature: str | tuple[str | None, str | None] = ...) -> Any
gwexpy/types/series_matrix_math.py:420: note:     def __call__(self, Buffer | _SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] | complex | bytes | str | _NestedSequence[complex | bytes | str], /, out: ndarray[tuple[Any, ...], dtype[Any]] | tuple[ndarray[tuple[Any, ...], dtype[Any]]] | None = ..., *, where: _SupportsArray[dtype[numpy.bool[builtins.bool]]] | _NestedSequence[_SupportsArray[dtype[numpy.bool[builtins.bool]]]] | builtins.bool | _NestedSequence[builtins.bool] | None = ..., casting: Literal['no', 'equiv', 'safe', 'same_kind', 'unsafe'] = ..., order: Literal['K', 'A', 'C', 'F'] | None = ..., dtype: type[Any] | dtype[Any] | _SupportsDType[dtype[Any]] | tuple[Any, Any] | list[Any] | _DTypeDict | str | None = ..., subok: bool = ..., signature: str | tuple[str | None, str | None] = ...) -> ndarray[tuple[Any, ...], dtype[Any]]
gwexpy/types/series_matrix_math.py:420: note:     def __call__(self, _SupportsArrayUFunc, /, out: ndarray[tuple[Any, ...], dtype[Any]] | tuple[ndarray[tuple[Any, ...], dtype[Any]]] | None = ..., *, where: _SupportsArray[dtype[numpy.bool[builtins.bool]]] | _NestedSequence[_SupportsArray[dtype[numpy.bool[builtins.bool]]]] | builtins.bool | _NestedSequence[builtins.bool] | None = ..., casting: Literal['no', 'equiv', 'safe', 'same_kind', 'unsafe'] = ..., order: Literal['K', 'A', 'C', 'F'] | None = ..., dtype: type[Any] | dtype[Any] | _SupportsDType[dtype[Any]] | tuple[Any, Any] | list[Any] | _DTypeDict | str | None = ..., subok: bool = ..., signature: str | tuple[str | None, str | None] = ...) -> Any
gwexpy/timeseries/matrix_spectral.py:39: error: Argument 1 to "rfftfreq" has incompatible type "Any | None"; expected "int | integer[Any]"  [arg-type]
gwexpy/interop/control_.py:118: error: Incompatible types in assignment (expression has type "list[float]", variable has type "ndarray[tuple[Any, ...], dtype[Any]]")  [assignment]
gwexpy/types/seriesmatrix_base.py:57: error: Definition of "astype" in base class "SeriesMatrixStructureMixin" is incompatible with definition in base class "ndarray"  [misc]
gwexpy/types/seriesmatrix_base.py:57: error: Definition of "diagonal" in base class "SeriesMatrixMathMixin" is incompatible with definition in base class "ndarray"  [misc]
gwexpy/types/seriesmatrix_base.py:57: error: Definition of "imag" in base class "SeriesMatrixStructureMixin" is incompatible with definition in base class "ndarray"  [misc]
gwexpy/types/seriesmatrix_base.py:57: error: Definition of "real" in base class "SeriesMatrixStructureMixin" is incompatible with definition in base class "ndarray"  [misc]
gwexpy/types/seriesmatrix_base.py:57: error: Definition of "reshape" in base class "SeriesMatrixStructureMixin" is incompatible with definition in base class "ndarray"  [misc]
gwexpy/types/seriesmatrix_base.py:57: error: Definition of "std" in base class "StatisticalMethodsMixin" is incompatible with definition in base class "_ArrayOrScalarCommon"  [misc]
gwexpy/types/seriesmatrix_base.py:57: error: Definition of "trace" in base class "SeriesMatrixMathMixin" is incompatible with definition in base class "ndarray"  [misc]
gwexpy/types/seriesmatrix_base.py:57: error: Definition of "var" in base class "StatisticalMethodsMixin" is incompatible with definition in base class "_ArrayOrScalarCommon"  [misc]
gwexpy/types/seriesmatrix_base.py:57: error: Definition of "view" in base class "SeriesMatrixCoreMixin" is incompatible with definition in base class "ndarray"  [misc]
gwexpy/types/seriesmatrix_base.py:98: error: Incompatible types in assignment (expression has type "object", variable has type "ndarray[tuple[Any, ...], dtype[Any]] | None")  [assignment]
gwexpy/types/seriesmatrix_base.py:100: error: Incompatible types in assignment (expression has type "object", variable has type "ndarray[tuple[Any, ...], dtype[Any]] | None")  [assignment]
gwexpy/types/seriesmatrix_base.py:169: error: Argument "xindex" to "_check_shape_consistency" has incompatible type "XIndex | Any | ndarray[tuple[Any, ...], dtype[Any]]"; expected "ndarray[tuple[Any, ...], dtype[Any]] | None"  [arg-type]
gwexpy/types/seriesmatrix_base.py:220: error: Argument 3 to "__array_ufunc__" of "ndarray" has incompatible type "str"; expected "Literal['__call__', 'reduce', 'reduceat', 'accumulate', 'outer', 'at']"  [arg-type]
gwexpy/types/seriesmatrix_base.py:378: error: Incompatible types in assignment (expression has type "dtype[Any]", variable has type "type[numpy.bool[builtins.bool]]")  [assignment]
gwexpy/types/seriesmatrix_base.py:380: error: Incompatible types in assignment (expression has type "dtype[Any]", variable has type "type[numpy.bool[builtins.bool]]")  [assignment]
gwexpy/frequencyseries/frequencyseries.py:93: error: Incompatible types in assignment (expression has type "ndarray[tuple[Any, ...], dtype[floating[Any]]]", variable has type "floating[Any]")  [assignment]
gwexpy/spectrogram/matrix.py:17: error: Definition of "astype" in base class "SeriesMatrixStructureMixin" is incompatible with definition in base class "ndarray"  [misc]
gwexpy/spectrogram/matrix.py:17: error: Definition of "diagonal" in base class "SeriesMatrixMathMixin" is incompatible with definition in base class "ndarray"  [misc]
gwexpy/spectrogram/matrix.py:17: error: Definition of "imag" in base class "SeriesMatrixStructureMixin" is incompatible with definition in base class "ndarray"  [misc]
gwexpy/spectrogram/matrix.py:17: error: Definition of "real" in base class "SeriesMatrixStructureMixin" is incompatible with definition in base class "ndarray"  [misc]
gwexpy/spectrogram/matrix.py:17: error: Definition of "reshape" in base class "SeriesMatrixStructureMixin" is incompatible with definition in base class "ndarray"  [misc]
gwexpy/spectrogram/matrix.py:17: error: Definition of "std" in base class "StatisticalMethodsMixin" is incompatible with definition in base class "_ArrayOrScalarCommon"  [misc]
gwexpy/spectrogram/matrix.py:17: error: Definition of "trace" in base class "SeriesMatrixMathMixin" is incompatible with definition in base class "ndarray"  [misc]
gwexpy/spectrogram/matrix.py:17: error: Definition of "var" in base class "StatisticalMethodsMixin" is incompatible with definition in base class "_ArrayOrScalarCommon"  [misc]
gwexpy/spectrogram/matrix.py:17: error: Definition of "view" in base class "SeriesMatrixCoreMixin" is incompatible with definition in base class "ndarray"  [misc]
gwexpy/spectrogram/matrix.py:111: error: Invalid self argument "SpectrogramMatrix" to attribute function "times" with type "Callable[[_SpectrogramMatrixCoreLike, Any], None]"  [misc]
gwexpy/spectrogram/matrix.py:112: error: Invalid self argument "SpectrogramMatrix" to attribute function "frequencies" with type "Callable[[_SpectrogramMatrixCoreLike, Any], None]"  [misc]
gwexpy/spectrogram/matrix.py:150: error: Incompatible types in assignment (expression has type "None", variable has type "MetaDataDict")  [assignment]
gwexpy/spectrogram/matrix.py:151: error: Incompatible types in assignment (expression has type "None", variable has type "MetaDataDict")  [assignment]
gwexpy/spectrogram/matrix.py:152: error: Incompatible types in assignment (expression has type "None", variable has type "MetaDataMatrix")  [assignment]
gwexpy/spectrogram/matrix.py:175: error: Invalid self argument "SpectrogramMatrix" to attribute function "frequencies" with type "Callable[[_SpectrogramMatrixCoreLike, Any], None]"  [misc]
gwexpy/spectrogram/matrix.py:266: error: "ndarray[tuple[Any, ...], dtype[Any]]" has no attribute "unit"  [attr-defined]
gwexpy/spectrogram/matrix.py:283: error: "ndarray[tuple[Any, ...], dtype[Any]]" has no attribute "name"  [attr-defined]
gwexpy/spectrogram/matrix.py:284: error: "ndarray[tuple[Any, ...], dtype[Any]]" has no attribute "channel"  [attr-defined]
gwexpy/spectrogram/matrix.py:302: error: "ndarray[tuple[Any, ...], dtype[Any]]" has no attribute "unit"  [attr-defined]
gwexpy/spectrogram/matrix.py:303: error: "ndarray[tuple[Any, ...], dtype[Any]]" has no attribute "unit"  [attr-defined]
gwexpy/spectrogram/matrix.py:334: error: "ndarray[tuple[Any, ...], dtype[Any]]" has no attribute "name"  [attr-defined]
gwexpy/spectrogram/matrix.py:335: error: "ndarray[tuple[Any, ...], dtype[Any]]" has no attribute "channel"  [attr-defined]
gwexpy/spectrogram/matrix.py:356: error: Invalid self argument "SpectrogramMatrix" to attribute function "times" with type "Callable[[_SpectrogramMatrixCoreLike], Any]"  [misc]
gwexpy/spectrogram/matrix.py:357: error: Invalid self argument "SpectrogramMatrix" to attribute function "frequencies" with type "Callable[[_SpectrogramMatrixCoreLike], Any]"  [misc]
gwexpy/spectrogram/matrix.py:438: error: Invalid self argument "SpectrogramMatrix" to attribute function "times" with type "Callable[[_SpectrogramMatrixCoreLike], Any]"  [misc]
gwexpy/spectrogram/matrix.py:439: error: Invalid self argument "SpectrogramMatrix" to attribute function "times" with type "Callable[[_SpectrogramMatrixCoreLike], Any]"  [misc]
gwexpy/spectrogram/matrix.py:570: error: Incompatible types in assignment (expression has type "int | integer[Any]", variable has type "int")  [assignment]
gwexpy/spectrogram/matrix.py:579: error: Incompatible types in assignment (expression has type "int | integer[Any]", variable has type "int")  [assignment]
gwexpy/spectrogram/matrix.py:597: error: Invalid self argument "SpectrogramMatrix" to attribute function "times" with type "Callable[[_SpectrogramMatrixCoreLike], Any]"  [misc]
gwexpy/spectrogram/matrix.py:598: error: Invalid self argument "SpectrogramMatrix" to attribute function "frequencies" with type "Callable[[_SpectrogramMatrixCoreLike], Any]"  [misc]
gwexpy/spectrogram/matrix.py:611: error: Invalid self argument "SpectrogramMatrix" to attribute function "times" with type "Callable[[_SpectrogramMatrixCoreLike, Any], None]"  [misc]
gwexpy/spectrogram/matrix.py:612: error: Invalid self argument "SpectrogramMatrix" to attribute function "frequencies" with type "Callable[[_SpectrogramMatrixCoreLike, Any], None]"  [misc]
gwexpy/spectrogram/matrix.py:631: error: Incompatible types in assignment (expression has type "ndarray[tuple[Any, ...], dtype[Any]]", variable has type "MetaDataMatrix")  [assignment]
gwexpy/spectrogram/matrix.py:648: error: Incompatible types in assignment (expression has type "ndarray[tuple[Any, ...], dtype[Any]]", variable has type "MetaDataMatrix")  [assignment]
gwexpy/frequencyseries/matrix.py:15: error: Definition of "astype" in base class "SeriesMatrixStructureMixin" is incompatible with definition in base class "ndarray"  [misc]
gwexpy/frequencyseries/matrix.py:15: error: Definition of "diagonal" in base class "SeriesMatrixMathMixin" is incompatible with definition in base class "ndarray"  [misc]
gwexpy/frequencyseries/matrix.py:15: error: Definition of "imag" in base class "SeriesMatrixStructureMixin" is incompatible with definition in base class "ndarray"  [misc]
gwexpy/frequencyseries/matrix.py:15: error: Definition of "real" in base class "SeriesMatrixStructureMixin" is incompatible with definition in base class "ndarray"  [misc]
gwexpy/frequencyseries/matrix.py:15: error: Definition of "reshape" in base class "SeriesMatrixStructureMixin" is incompatible with definition in base class "ndarray"  [misc]
gwexpy/frequencyseries/matrix.py:15: error: Definition of "std" in base class "StatisticalMethodsMixin" is incompatible with definition in base class "_ArrayOrScalarCommon"  [misc]
gwexpy/frequencyseries/matrix.py:15: error: Definition of "trace" in base class "SeriesMatrixMathMixin" is incompatible with definition in base class "ndarray"  [misc]
gwexpy/frequencyseries/matrix.py:15: error: Definition of "var" in base class "StatisticalMethodsMixin" is incompatible with definition in base class "_ArrayOrScalarCommon"  [misc]
gwexpy/frequencyseries/matrix.py:15: error: Definition of "view" in base class "SeriesMatrixCoreMixin" is incompatible with definition in base class "ndarray"  [misc]
gwexpy/timeseries/matrix.py:29: error: Definition of "astype" in base class "SeriesMatrixStructureMixin" is incompatible with definition in base class "ndarray"  [misc]
gwexpy/timeseries/matrix.py:29: error: Definition of "diagonal" in base class "SeriesMatrixMathMixin" is incompatible with definition in base class "ndarray"  [misc]
gwexpy/timeseries/matrix.py:29: error: Definition of "imag" in base class "SeriesMatrixStructureMixin" is incompatible with definition in base class "ndarray"  [misc]
gwexpy/timeseries/matrix.py:29: error: Definition of "max" in base class "TimeSeriesMatrixAnalysisMixin" is incompatible with definition in base class "_ArrayOrScalarCommon"  [misc]
gwexpy/timeseries/matrix.py:29: error: Definition of "mean" in base class "TimeSeriesMatrixAnalysisMixin" is incompatible with definition in base class "_ArrayOrScalarCommon"  [misc]
gwexpy/timeseries/matrix.py:29: error: Definition of "min" in base class "TimeSeriesMatrixAnalysisMixin" is incompatible with definition in base class "_ArrayOrScalarCommon"  [misc]
gwexpy/timeseries/matrix.py:29: error: Definition of "real" in base class "SeriesMatrixStructureMixin" is incompatible with definition in base class "ndarray"  [misc]
gwexpy/timeseries/matrix.py:29: error: Definition of "reshape" in base class "SeriesMatrixStructureMixin" is incompatible with definition in base class "ndarray"  [misc]
gwexpy/timeseries/matrix.py:29: error: Definition of "std" in base class "TimeSeriesMatrixAnalysisMixin" is incompatible with definition in base class "_ArrayOrScalarCommon"  [misc]
gwexpy/timeseries/matrix.py:29: error: Definition of "trace" in base class "SeriesMatrixMathMixin" is incompatible with definition in base class "ndarray"  [misc]
gwexpy/timeseries/matrix.py:29: error: Definition of "var" in base class "StatisticalMethodsMixin" is incompatible with definition in base class "_ArrayOrScalarCommon"  [misc]
gwexpy/timeseries/matrix.py:29: error: Definition of "view" in base class "SeriesMatrixCoreMixin" is incompatible with definition in base class "ndarray"  [misc]
gwexpy/analysis/response.py:96: error: Argument 6 to "pcolormesh" of "Axes" has incompatible type "**dict[str, object]"; expected "float | None"  [arg-type]
gwexpy/analysis/response.py:96: error: Argument 6 to "pcolormesh" of "Axes" has incompatible type "**dict[str, object]"; expected "str | Colormap | None"  [arg-type]
gwexpy/analysis/response.py:96: error: Argument 6 to "pcolormesh" of "Axes" has incompatible type "**dict[str, object]"; expected "Colorizer | None"  [arg-type]
gwexpy/analysis/response.py:96: error: Argument 6 to "pcolormesh" of "Axes" has incompatible type "**dict[str, object]"; expected "bool"  [arg-type]
gwexpy/analysis/response.py:118: error: Incompatible types in assignment (expression has type "signedinteger[_32Bit | _64Bit]", variable has type "int | None")  [assignment]
gwexpy/analysis/response.py:217: error: Incompatible types in assignment (expression has type "float", variable has type "floating[Any]")  [assignment]
gwexpy/fields/base.py:424: error: "FuncAnimation" has no attribute "_fig"  [attr-defined]
scripts/verify_scalarfield_physics.py:150: error: Item "ndarray[tuple[Any, ...], dtype[Any]]" of "XIndex | Any | ndarray[tuple[Any, ...], dtype[Any]]" has no attribute "value"  [union-attr]
scripts/verify_scalarfield_physics.py:212: error: Item "ndarray[tuple[Any, ...], dtype[Any]]" of "XIndex | Any | ndarray[tuple[Any, ...], dtype[Any]]" has no attribute "unit"  [union-attr]
scripts/verify_scalarfield_physics.py:214: error: Item "ndarray[tuple[Any, ...], dtype[Any]]" of "XIndex | Any | ndarray[tuple[Any, ...], dtype[Any]]" has no attribute "unit"  [union-attr]
scripts/verify_scalarfield_physics.py:216: error: Item "ndarray[tuple[Any, ...], dtype[Any]]" of "XIndex | Any | ndarray[tuple[Any, ...], dtype[Any]]" has no attribute "unit"  [union-attr]
scripts/verify_scalarfield_physics.py:218: error: Item "ndarray[tuple[Any, ...], dtype[Any]]" of "XIndex | Any | ndarray[tuple[Any, ...], dtype[Any]]" has no attribute "unit"  [union-attr]
scripts/verify_scalarfield_physics.py:226: error: Item "ndarray[tuple[Any, ...], dtype[Any]]" of "XIndex | Any | ndarray[tuple[Any, ...], dtype[Any]]" has no attribute "unit"  [union-attr]
scripts/verify_scalarfield_physics.py:230: error: Item "ndarray[tuple[Any, ...], dtype[Any]]" of "XIndex | Any | ndarray[tuple[Any, ...], dtype[Any]]" has no attribute "unit"  [union-attr]
scripts/verify_scalarfield_physics.py:236: error: Item "ndarray[tuple[Any, ...], dtype[Any]]" of "XIndex | Any | ndarray[tuple[Any, ...], dtype[Any]]" has no attribute "unit"  [union-attr]
scripts/verify_scalarfield_physics.py:239: error: Item "ndarray[tuple[Any, ...], dtype[Any]]" of "XIndex | Any | ndarray[tuple[Any, ...], dtype[Any]]" has no attribute "unit"  [union-attr]
Found 157 errors in 31 files (checked 324 source files)
