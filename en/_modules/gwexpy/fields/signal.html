

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>gwexpy.fields.signal &mdash; gwexpy  documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=9edc463e" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=5929fcd5"></script>
      <script src="../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            gwexpy
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../guide/installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../guide/quickstart.html">Quickstart</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../guide/tutorials/index.html">Tutorials</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../reference/api/index.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../reference/en/index.html">Detailed Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../reference/ja/index.html">詳細リファレンス</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">gwexpy</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">gwexpy.fields.signal</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for gwexpy.fields.signal</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Signal processing utilities for ScalarField.</span>

<span class="sd">This module provides spectral analysis, correlation, and coherence tools</span>
<span class="sd">for 4D field data, following the Phase 3 signal processing extension plan.</span>

<span class="sd">Key features:</span>
<span class="sd">- PSD estimation (Welch method)</span>
<span class="sd">- Frequency-space mapping</span>
<span class="sd">- Cross-correlation and time delay estimation</span>
<span class="sd">- Coherence analysis</span>

<span class="sd">All functions preserve axis metadata and units, returning gwexpy-compatible</span>
<span class="sd">data containers (FrequencySeries, TimeSeries, ScalarField).</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">__future__</span><span class="w"> </span><span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">TYPE_CHECKING</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Literal</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">astropy</span><span class="w"> </span><span class="kn">import</span> <span class="n">units</span> <span class="k">as</span> <span class="n">u</span>

<span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">astropy.units</span><span class="w"> </span><span class="kn">import</span> <span class="n">Quantity</span>

    <span class="kn">from</span><span class="w"> </span><span class="nn">gwexpy.fields</span><span class="w"> </span><span class="kn">import</span> <span class="n">ScalarField</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">gwexpy.fields.collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">FieldDict</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">gwexpy.frequencyseries</span><span class="w"> </span><span class="kn">import</span> <span class="n">FrequencySeries</span><span class="p">,</span> <span class="n">FrequencySeriesList</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">gwexpy.timeseries</span><span class="w"> </span><span class="kn">import</span> <span class="n">TimeSeries</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;spectral_density&quot;</span><span class="p">,</span>
    <span class="s2">&quot;compute_psd&quot;</span><span class="p">,</span>
    <span class="s2">&quot;freq_space_map&quot;</span><span class="p">,</span>
    <span class="s2">&quot;compute_freq_space&quot;</span><span class="p">,</span>
    <span class="s2">&quot;compute_xcorr&quot;</span><span class="p">,</span>
    <span class="s2">&quot;time_delay_map&quot;</span><span class="p">,</span>
    <span class="s2">&quot;coherence_map&quot;</span><span class="p">,</span>
<span class="p">]</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_validate_regular_time_axis</span><span class="p">(</span><span class="n">field</span><span class="p">:</span> <span class="n">ScalarField</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">Unit</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Validate that ScalarField has a regular time axis suitable for FFT/PSD.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tuple</span>
<span class="sd">        (dt_value, dt_unit): Time step value and unit.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If axis0_domain is not &#39;time&#39; or axis is irregular.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">field</span><span class="o">.</span><span class="n">axis0_domain</span> <span class="o">!=</span> <span class="s2">&quot;time&quot;</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Signal processing requires axis0_domain=&#39;time&#39;, &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;got &#39;</span><span class="si">{</span><span class="n">field</span><span class="o">.</span><span class="n">axis0_domain</span><span class="si">}</span><span class="s2">&#39;&quot;</span>
        <span class="p">)</span>

    <span class="kn">from</span><span class="w"> </span><span class="nn">..types.axis</span><span class="w"> </span><span class="kn">import</span> <span class="n">AxisDescriptor</span>

    <span class="n">ax</span> <span class="o">=</span> <span class="n">AxisDescriptor</span><span class="p">(</span><span class="n">field</span><span class="o">.</span><span class="n">_axis0_name</span><span class="p">,</span> <span class="n">field</span><span class="o">.</span><span class="n">_axis0_index</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">ax</span><span class="o">.</span><span class="n">regular</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Time axis must be regularly spaced for spectral analysis. &quot;</span>
            <span class="s2">&quot;Consider resampling the data to a uniform time grid.&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">ax</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Time axis must have at least 2 points for spectral analysis.&quot;</span><span class="p">)</span>

    <span class="n">dt</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">delta</span>
    <span class="k">if</span> <span class="n">dt</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Time axis must be regularly spaced for spectral analysis. &quot;</span>
            <span class="s2">&quot;Consider resampling the data to a uniform time grid.&quot;</span>
        <span class="p">)</span>
    <span class="n">dt_value</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>
    <span class="n">dt_unit</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="s2">&quot;unit&quot;</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">dimensionless_unscaled</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dt_value</span><span class="p">,</span> <span class="n">dt_unit</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_validate_axis_for_spectral</span><span class="p">(</span>
    <span class="n">field</span><span class="p">:</span> <span class="n">ScalarField</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">str</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">Unit</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Validate axis for spectral density computation.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tuple</span>
<span class="sd">        (axis_int, delta_value, delta_unit, domain): axis index, sample spacing,</span>
<span class="sd">        spacing unit, and current domain (&#39;time&#39; or &#39;real&#39;).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">..types.axis</span><span class="w"> </span><span class="kn">import</span> <span class="n">AxisDescriptor</span>

    <span class="c1"># Resolve axis name to index</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">axis_int</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">_get_axis_index</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">axis_int</span> <span class="o">=</span> <span class="n">axis</span>

    <span class="k">if</span> <span class="n">axis_int</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">axis_int</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;axis must be 0-3, got </span><span class="si">{</span><span class="n">axis_int</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Get axis info</span>
    <span class="n">axis_mapping</span> <span class="o">=</span> <span class="p">{</span>
        <span class="mi">0</span><span class="p">:</span> <span class="p">(</span><span class="n">field</span><span class="o">.</span><span class="n">_axis0_name</span><span class="p">,</span> <span class="n">field</span><span class="o">.</span><span class="n">_axis0_index</span><span class="p">,</span> <span class="n">field</span><span class="o">.</span><span class="n">_axis0_domain</span><span class="p">),</span>
        <span class="mi">1</span><span class="p">:</span> <span class="p">(</span>
            <span class="n">field</span><span class="o">.</span><span class="n">_axis1_name</span><span class="p">,</span>
            <span class="n">field</span><span class="o">.</span><span class="n">_axis1_index</span><span class="p">,</span>
            <span class="n">field</span><span class="o">.</span><span class="n">_space_domains</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">field</span><span class="o">.</span><span class="n">_axis1_name</span><span class="p">,</span> <span class="s2">&quot;real&quot;</span><span class="p">),</span>
        <span class="p">),</span>
        <span class="mi">2</span><span class="p">:</span> <span class="p">(</span>
            <span class="n">field</span><span class="o">.</span><span class="n">_axis2_name</span><span class="p">,</span>
            <span class="n">field</span><span class="o">.</span><span class="n">_axis2_index</span><span class="p">,</span>
            <span class="n">field</span><span class="o">.</span><span class="n">_space_domains</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">field</span><span class="o">.</span><span class="n">_axis2_name</span><span class="p">,</span> <span class="s2">&quot;real&quot;</span><span class="p">),</span>
        <span class="p">),</span>
        <span class="mi">3</span><span class="p">:</span> <span class="p">(</span>
            <span class="n">field</span><span class="o">.</span><span class="n">_axis3_name</span><span class="p">,</span>
            <span class="n">field</span><span class="o">.</span><span class="n">_axis3_index</span><span class="p">,</span>
            <span class="n">field</span><span class="o">.</span><span class="n">_space_domains</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">field</span><span class="o">.</span><span class="n">_axis3_name</span><span class="p">,</span> <span class="s2">&quot;real&quot;</span><span class="p">),</span>
        <span class="p">),</span>
    <span class="p">}</span>
    <span class="n">ax_name</span><span class="p">,</span> <span class="n">ax_index</span><span class="p">,</span> <span class="n">domain</span> <span class="o">=</span> <span class="n">axis_mapping</span><span class="p">[</span><span class="n">axis_int</span><span class="p">]</span>

    <span class="c1"># Validate regular spacing</span>
    <span class="n">ax_desc</span> <span class="o">=</span> <span class="n">AxisDescriptor</span><span class="p">(</span><span class="n">ax_name</span><span class="p">,</span> <span class="n">ax_index</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">ax_desc</span><span class="o">.</span><span class="n">regular</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Axis &#39;</span><span class="si">{</span><span class="n">ax_name</span><span class="si">}</span><span class="s2">&#39; must be regularly spaced for spectral analysis. &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;Consider resampling to a uniform grid.&quot;</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="n">ax_desc</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Axis &#39;</span><span class="si">{</span><span class="n">ax_name</span><span class="si">}</span><span class="s2">&#39; must have at least 2 points.&quot;</span><span class="p">)</span>

    <span class="n">delta</span> <span class="o">=</span> <span class="n">ax_desc</span><span class="o">.</span><span class="n">delta</span>
    <span class="k">if</span> <span class="n">delta</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Axis &#39;</span><span class="si">{</span><span class="n">ax_name</span><span class="si">}</span><span class="s2">&#39; does not have a defined spacing.&quot;</span><span class="p">)</span>

    <span class="c1"># Check domain is appropriate</span>
    <span class="k">if</span> <span class="n">axis_int</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">domain</span> <span class="o">==</span> <span class="s2">&quot;frequency&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;spectral_density requires axis0_domain=&#39;time&#39;. &quot;</span>
                <span class="s2">&quot;Use ifft_time first to transform to time domain.&quot;</span>
            <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">domain</span> <span class="o">==</span> <span class="s2">&quot;k&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;spectral_density requires axis &#39;</span><span class="si">{</span><span class="n">ax_name</span><span class="si">}</span><span class="s2">&#39; in &#39;real&#39; domain. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Use ifft_space first to transform to real space.&quot;</span>
            <span class="p">)</span>

    <span class="n">delta_value</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">,</span> <span class="n">delta</span><span class="p">)</span>
    <span class="n">delta_unit</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="s2">&quot;unit&quot;</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">dimensionless_unscaled</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">axis_int</span><span class="p">,</span> <span class="n">delta_value</span><span class="p">,</span> <span class="n">delta_unit</span><span class="p">,</span> <span class="n">domain</span>


<span class="k">def</span><span class="w"> </span><span class="nf">spectral_density</span><span class="p">(</span>
    <span class="n">field</span><span class="p">:</span> <span class="n">ScalarField</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">str</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">method</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;welch&quot;</span><span class="p">,</span> <span class="s2">&quot;fft&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;welch&quot;</span><span class="p">,</span>
    <span class="n">nperseg</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">noverlap</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">window</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;hann&quot;</span><span class="p">,</span>
    <span class="n">detrend</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="nb">bool</span> <span class="o">=</span> <span class="s2">&quot;constant&quot;</span><span class="p">,</span>
    <span class="n">scaling</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;density&quot;</span><span class="p">,</span> <span class="s2">&quot;spectrum&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;density&quot;</span><span class="p">,</span>
    <span class="n">average</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;mean&quot;</span><span class="p">,</span> <span class="s2">&quot;median&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;mean&quot;</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ScalarField</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute spectral density along any axis.</span>

<span class="sd">    This is the generalized spectral density function that works on:</span>
<span class="sd">    - Time axis (axis=0): Returns power spectral density vs frequency</span>
<span class="sd">    - Space axes (axis=1,2,3): Returns spatial spectral density vs wavenumber</span>

<span class="sd">    The output maintains 4D shape, with the specified axis transformed</span>
<span class="sd">    from its original domain (time-&gt;frequency, position-&gt;wavenumber).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    field : ScalarField</span>
<span class="sd">        Input 4D field. For time axis, axis0_domain must be &#39;time&#39;.</span>
<span class="sd">        For space axes, the axis must be in &#39;real&#39; domain.</span>
<span class="sd">    axis : int or str</span>
<span class="sd">        Axis to transform. Can be integer (0-3) or axis name.</span>
<span class="sd">        Default is 0 (time axis).</span>
<span class="sd">    method : {&#39;welch&#39;, &#39;fft&#39;}</span>
<span class="sd">        Estimation method. &#39;welch&#39; for averaged periodogram,</span>
<span class="sd">        &#39;fft&#39; for direct FFT magnitude squared. Default &#39;welch&#39;.</span>
<span class="sd">    nperseg : int, optional</span>
<span class="sd">        Segment length for Welch method. Default min(256, axis_length).</span>
<span class="sd">    noverlap : int, optional</span>
<span class="sd">        Overlap for Welch. Default nperseg // 2.</span>
<span class="sd">    window : str</span>
<span class="sd">        Window function. Default &#39;hann&#39;.</span>
<span class="sd">    detrend : str or bool</span>
<span class="sd">        Detrending: &#39;constant&#39;, &#39;linear&#39;, or False. Default &#39;constant&#39;.</span>
<span class="sd">    scaling : {&#39;density&#39;, &#39;spectrum&#39;}</span>
<span class="sd">        &#39;density&#39; divides by frequency/wavenumber resolution,</span>
<span class="sd">        &#39;spectrum&#39; gives total power in each bin. Default &#39;density&#39;.</span>
<span class="sd">    average : {&#39;mean&#39;, &#39;median&#39;}</span>
<span class="sd">        Averaging for Welch. Default &#39;mean&#39;.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ScalarField</span>
<span class="sd">        Spectral density field with the specified axis transformed:</span>
<span class="sd">        - axis0: frequency (if axis=0) or unchanged</span>
<span class="sd">        - axis0_domain: &#39;frequency&#39; (if axis=0)</span>
<span class="sd">        - space_domains: &#39;k&#39; for transformed spatial axis</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If axis is already in spectral domain, or is irregular.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from astropy import units as u</span>
<span class="sd">    &gt;&gt;&gt; from gwexpy.fields import ScalarField</span>
<span class="sd">    &gt;&gt;&gt; # Time PSD (all spatial points)</span>
<span class="sd">    &gt;&gt;&gt; psd_field = spectral_density(field, axis=0)</span>
<span class="sd">    &gt;&gt;&gt; psd_field.axis0_domain  # &#39;frequency&#39;</span>

<span class="sd">    &gt;&gt;&gt; # Spatial wavenumber spectrum along x</span>
<span class="sd">    &gt;&gt;&gt; kx_spec = spectral_density(field, axis=&#39;x&#39;)</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    For time axis (axis=0), this is equivalent to applying Welch PSD</span>
<span class="sd">    estimation to every spatial point independently.</span>

<span class="sd">    For spatial axes, this computes the spatial power spectrum,</span>
<span class="sd">    where the output unit is ``field.unit**2 / (1/dx.unit)`` assuming</span>
<span class="sd">    density scaling.</span>

<span class="sd">    The wavenumber definition follows the convention k = 1/λ (not angular).</span>
<span class="sd">    To get angular wavenumber (2π/λ), multiply the output axis by 2π.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">scipy.signal</span><span class="w"> </span><span class="kn">import</span> <span class="n">welch</span>

    <span class="n">axis_int</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span> <span class="n">delta_unit</span><span class="p">,</span> <span class="n">domain</span> <span class="o">=</span> <span class="n">_validate_axis_for_spectral</span><span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>

    <span class="n">n_axis</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis_int</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">nperseg</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">nperseg</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mi">256</span><span class="p">,</span> <span class="n">n_axis</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">noverlap</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">noverlap</span> <span class="o">=</span> <span class="n">nperseg</span> <span class="o">//</span> <span class="mi">2</span>

    <span class="n">fs</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">delta</span>  <span class="c1"># Sampling frequency (temporal or spatial)</span>

    <span class="c1"># Apply Welch along specified axis</span>
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;welch&quot;</span><span class="p">:</span>
        <span class="n">freqs</span><span class="p">,</span> <span class="n">psd</span> <span class="o">=</span> <span class="n">welch</span><span class="p">(</span>
            <span class="n">field</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
            <span class="n">fs</span><span class="o">=</span><span class="n">fs</span><span class="p">,</span>
            <span class="n">axis</span><span class="o">=</span><span class="n">axis_int</span><span class="p">,</span>
            <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span>
            <span class="n">nperseg</span><span class="o">=</span><span class="n">nperseg</span><span class="p">,</span>
            <span class="n">noverlap</span><span class="o">=</span><span class="n">noverlap</span><span class="p">,</span>
            <span class="n">detrend</span><span class="o">=</span><span class="n">detrend</span><span class="p">,</span>
            <span class="n">scaling</span><span class="o">=</span><span class="n">scaling</span><span class="p">,</span>
            <span class="n">average</span><span class="o">=</span><span class="n">average</span><span class="p">,</span>
            <span class="n">return_onesided</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>  <span class="c1"># Real-valued input assumed</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>  <span class="c1"># fft method</span>
        <span class="c1"># Direct FFT-based PSD</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis_int</span><span class="p">]</span>
        <span class="n">fft_result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfft</span><span class="p">(</span><span class="n">field</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis_int</span><span class="p">)</span>
        <span class="n">psd</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">fft_result</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">n</span><span class="o">**</span><span class="mi">2</span>

        <span class="c1"># One-sided correction</span>
        <span class="n">slices</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="mi">4</span>
        <span class="n">slices</span><span class="p">[</span><span class="n">axis_int</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">psd</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slices</span><span class="p">)]</span> <span class="o">*=</span> <span class="mi">2</span>

        <span class="k">if</span> <span class="n">scaling</span> <span class="o">==</span> <span class="s2">&quot;density&quot;</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">fs</span> <span class="o">/</span> <span class="n">n</span>
            <span class="n">psd</span> <span class="o">=</span> <span class="n">psd</span> <span class="o">/</span> <span class="n">df</span>

        <span class="n">freqs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfftfreq</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="n">delta</span><span class="p">)</span>

    <span class="c1"># Determine output unit</span>
    <span class="n">freq_unit</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">delta_unit</span>
    <span class="k">if</span> <span class="n">field</span><span class="o">.</span><span class="n">unit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">scaling</span> <span class="o">==</span> <span class="s2">&quot;density&quot;</span><span class="p">:</span>
            <span class="n">psd_unit</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">unit</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">freq_unit</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">psd_unit</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">unit</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">psd_unit</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">dimensionless_unscaled</span>

    <span class="c1"># Build output ScalarField</span>
    <span class="n">freq_axis</span> <span class="o">=</span> <span class="n">freqs</span> <span class="o">*</span> <span class="n">freq_unit</span>

    <span class="c1"># Determine new axis names and domains</span>
    <span class="k">if</span> <span class="n">axis_int</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">new_axis0_domain</span> <span class="o">=</span> <span class="s2">&quot;frequency&quot;</span>
        <span class="n">new_axis_names</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s2">&quot;f&quot;</span><span class="p">,</span> <span class="n">field</span><span class="o">.</span><span class="n">_axis1_name</span><span class="p">,</span> <span class="n">field</span><span class="o">.</span><span class="n">_axis2_name</span><span class="p">,</span> <span class="n">field</span><span class="o">.</span><span class="n">_axis3_name</span>
        <span class="p">]</span>
        <span class="n">new_space_domains</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">field</span><span class="o">.</span><span class="n">_space_domains</span><span class="p">)</span>
        <span class="n">new_axes</span> <span class="o">=</span> <span class="p">{</span>
            <span class="mi">0</span><span class="p">:</span> <span class="n">freq_axis</span><span class="p">,</span>
            <span class="mi">1</span><span class="p">:</span> <span class="n">field</span><span class="o">.</span><span class="n">_axis1_index</span><span class="p">,</span>
            <span class="mi">2</span><span class="p">:</span> <span class="n">field</span><span class="o">.</span><span class="n">_axis2_index</span><span class="p">,</span>
            <span class="mi">3</span><span class="p">:</span> <span class="n">field</span><span class="o">.</span><span class="n">_axis3_index</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">new_axis0_domain</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">_axis0_domain</span>
        <span class="n">new_axis_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">field</span><span class="o">.</span><span class="n">axis_names</span><span class="p">)</span>
        <span class="n">new_space_domains</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">field</span><span class="o">.</span><span class="n">_space_domains</span><span class="p">)</span>

        <span class="c1"># Rename spatial axis to k-variant</span>
        <span class="n">old_name</span> <span class="o">=</span> <span class="n">new_axis_names</span><span class="p">[</span><span class="n">axis_int</span><span class="p">]</span>
        <span class="n">new_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;k</span><span class="si">{</span><span class="n">old_name</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="n">new_axis_names</span><span class="p">[</span><span class="n">axis_int</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_name</span>

        <span class="c1"># Update domain</span>
        <span class="k">if</span> <span class="n">old_name</span> <span class="ow">in</span> <span class="n">new_space_domains</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">new_space_domains</span><span class="p">[</span><span class="n">old_name</span><span class="p">]</span>
        <span class="n">new_space_domains</span><span class="p">[</span><span class="n">new_name</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;k&quot;</span>

        <span class="n">new_axes</span> <span class="o">=</span> <span class="p">{</span>
            <span class="mi">0</span><span class="p">:</span> <span class="n">field</span><span class="o">.</span><span class="n">_axis0_index</span><span class="p">,</span>
            <span class="mi">1</span><span class="p">:</span> <span class="n">field</span><span class="o">.</span><span class="n">_axis1_index</span><span class="p">,</span>
            <span class="mi">2</span><span class="p">:</span> <span class="n">field</span><span class="o">.</span><span class="n">_axis2_index</span><span class="p">,</span>
            <span class="mi">3</span><span class="p">:</span> <span class="n">field</span><span class="o">.</span><span class="n">_axis3_index</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="n">new_axes</span><span class="p">[</span><span class="n">axis_int</span><span class="p">]</span> <span class="o">=</span> <span class="n">freq_axis</span>

    <span class="kn">from</span><span class="w"> </span><span class="nn">gwexpy.fields</span><span class="w"> </span><span class="kn">import</span> <span class="n">ScalarField</span> <span class="k">as</span> <span class="n">SF</span>

    <span class="k">return</span> <span class="n">SF</span><span class="p">(</span>
        <span class="n">psd</span><span class="p">,</span>
        <span class="n">unit</span><span class="o">=</span><span class="n">psd_unit</span><span class="p">,</span>
        <span class="n">axis0</span><span class="o">=</span><span class="n">new_axes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
        <span class="n">axis1</span><span class="o">=</span><span class="n">new_axes</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
        <span class="n">axis2</span><span class="o">=</span><span class="n">new_axes</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
        <span class="n">axis3</span><span class="o">=</span><span class="n">new_axes</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
        <span class="n">axis_names</span><span class="o">=</span><span class="n">new_axis_names</span><span class="p">,</span>
        <span class="n">axis0_domain</span><span class="o">=</span><span class="n">new_axis0_domain</span><span class="p">,</span>
        <span class="n">space_domain</span><span class="o">=</span><span class="n">new_space_domains</span><span class="p">,</span>
    <span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_extract_timeseries_1d</span><span class="p">(</span>
    <span class="n">field</span><span class="p">:</span> <span class="n">ScalarField</span><span class="p">,</span>
    <span class="n">point</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Quantity</span><span class="p">,</span> <span class="n">Quantity</span><span class="p">,</span> <span class="n">Quantity</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">Unit</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Extract 1D time series at a spatial point.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tuple</span>
<span class="sd">        (data_1d, fs, data_unit): 1D array, sampling frequency, and unit.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">gwexpy.plot._coord</span><span class="w"> </span><span class="kn">import</span> <span class="n">nearest_index</span>

    <span class="n">dt_value</span><span class="p">,</span> <span class="n">dt_unit</span> <span class="o">=</span> <span class="n">_validate_regular_time_axis</span><span class="p">(</span><span class="n">field</span><span class="p">)</span>
    <span class="n">fs</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">dt_value</span>  <span class="c1"># sampling frequency in 1/dt_unit</span>

    <span class="n">x_val</span><span class="p">,</span> <span class="n">y_val</span><span class="p">,</span> <span class="n">z_val</span> <span class="o">=</span> <span class="n">point</span>
    <span class="n">i1</span> <span class="o">=</span> <span class="n">nearest_index</span><span class="p">(</span><span class="n">field</span><span class="o">.</span><span class="n">_axis1_index</span><span class="p">,</span> <span class="n">x_val</span><span class="p">)</span>
    <span class="n">i2</span> <span class="o">=</span> <span class="n">nearest_index</span><span class="p">(</span><span class="n">field</span><span class="o">.</span><span class="n">_axis2_index</span><span class="p">,</span> <span class="n">y_val</span><span class="p">)</span>
    <span class="n">i3</span> <span class="o">=</span> <span class="n">nearest_index</span><span class="p">(</span><span class="n">field</span><span class="o">.</span><span class="n">_axis3_index</span><span class="p">,</span> <span class="n">z_val</span><span class="p">)</span>

    <span class="n">data_1d</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">value</span><span class="p">[:,</span> <span class="n">i1</span><span class="p">,</span> <span class="n">i2</span><span class="p">,</span> <span class="n">i3</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">data_1d</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">field</span><span class="o">.</span><span class="n">unit</span>


<div class="viewcode-block" id="compute_psd">
<a class="viewcode-back" href="../../../reference/api/fields.html#gwexpy.fields.compute_psd">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">compute_psd</span><span class="p">(</span>
    <span class="n">field</span><span class="p">:</span> <span class="n">ScalarField</span><span class="p">,</span>
    <span class="n">point_or_region</span><span class="p">:</span> <span class="p">(</span>
        <span class="nb">tuple</span><span class="p">[</span><span class="n">Quantity</span><span class="p">,</span> <span class="n">Quantity</span><span class="p">,</span> <span class="n">Quantity</span><span class="p">]</span>
        <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="n">Quantity</span><span class="p">,</span> <span class="n">Quantity</span><span class="p">,</span> <span class="n">Quantity</span><span class="p">]]</span>
        <span class="o">|</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span>
    <span class="p">),</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">nperseg</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">noverlap</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">window</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;hann&quot;</span><span class="p">,</span>
    <span class="n">detrend</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="nb">bool</span> <span class="o">=</span> <span class="s2">&quot;constant&quot;</span><span class="p">,</span>
    <span class="n">scaling</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;density&quot;</span><span class="p">,</span> <span class="s2">&quot;spectrum&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;density&quot;</span><span class="p">,</span>
    <span class="n">average</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;mean&quot;</span><span class="p">,</span> <span class="s2">&quot;median&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;mean&quot;</span><span class="p">,</span>
    <span class="n">return_onesided</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">FrequencySeries</span> <span class="o">|</span> <span class="n">FrequencySeriesList</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute power spectral density using Welch&#39;s method.</span>

<span class="sd">    Extracts time series from one or more spatial points/regions and</span>
<span class="sd">    estimates their PSD using scipy.signal.welch.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    field : ScalarField</span>
<span class="sd">        Input 4D field with axis0_domain=&#39;time&#39;.</span>
<span class="sd">    point_or_region : tuple, list of tuples, or dict</span>
<span class="sd">        Spatial location(s) to extract:</span>
<span class="sd">        - Single point: ``(x, y, z)`` tuple of Quantities</span>
<span class="sd">        - Multiple points: list of ``(x, y, z)`` tuples</span>
<span class="sd">        - Region dict: ``{&#39;x&#39;: slice or value, &#39;y&#39;: ..., &#39;z&#39;: ...}``</span>
<span class="sd">          If region, averages over all points in the region.</span>
<span class="sd">    nperseg : int, optional</span>
<span class="sd">        Length of each segment. Default is min(256, len(time_axis)).</span>
<span class="sd">    noverlap : int, optional</span>
<span class="sd">        Number of overlapping points. Default is nperseg // 2.</span>
<span class="sd">    window : str</span>
<span class="sd">        Window function name. Default is &#39;hann&#39;.</span>
<span class="sd">    detrend : str or bool</span>
<span class="sd">        Detrending method: &#39;constant&#39;, &#39;linear&#39;, or False. Default &#39;constant&#39;.</span>
<span class="sd">    scaling : {&#39;density&#39;, &#39;spectrum&#39;}</span>
<span class="sd">        &#39;density&#39; for PSD (V²/Hz), &#39;spectrum&#39; for power spectrum (V²).</span>
<span class="sd">        Default is &#39;density&#39;.</span>
<span class="sd">    average : {&#39;mean&#39;, &#39;median&#39;}</span>
<span class="sd">        Averaging method for segments. Default is &#39;mean&#39;.</span>
<span class="sd">    return_onesided : bool</span>
<span class="sd">        If True, return one-sided spectrum for real data. Default True.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    FrequencySeries or FrequencySeriesList</span>
<span class="sd">        - Single point: FrequencySeries with PSD values</span>
<span class="sd">        - Multiple points: FrequencySeriesList</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If time axis is not regularly spaced or axis0_domain != &#39;time&#39;.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from astropy import units as u</span>
<span class="sd">    &gt;&gt;&gt; psd = compute_psd(field, (1.0*u.m, 2.0*u.m, 0.0*u.m))</span>
<span class="sd">    &gt;&gt;&gt; psd.frequencies  # Frequency axis with units</span>

<span class="sd">    &gt;&gt;&gt; # Multiple points</span>
<span class="sd">    &gt;&gt;&gt; points = [(0*u.m, 0*u.m, 0*u.m), (1*u.m, 0*u.m, 0*u.m)]</span>
<span class="sd">    &gt;&gt;&gt; psd_list = compute_psd(field, points)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">scipy.signal</span><span class="w"> </span><span class="kn">import</span> <span class="n">welch</span>

    <span class="kn">from</span><span class="w"> </span><span class="nn">gwexpy.frequencyseries</span><span class="w"> </span><span class="kn">import</span> <span class="n">FrequencySeries</span><span class="p">,</span> <span class="n">FrequencySeriesList</span>

    <span class="n">dt_value</span><span class="p">,</span> <span class="n">dt_unit</span> <span class="o">=</span> <span class="n">_validate_regular_time_axis</span><span class="p">(</span><span class="n">field</span><span class="p">)</span>
    <span class="n">fs</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">dt_value</span>

    <span class="n">nt</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">nperseg</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">nperseg</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mi">256</span><span class="p">,</span> <span class="n">nt</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">noverlap</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">noverlap</span> <span class="o">=</span> <span class="n">nperseg</span> <span class="o">//</span> <span class="mi">2</span>

    <span class="c1"># Determine extraction mode</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">point_or_region</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="c1"># Region mode: extract and average</span>
        <span class="n">data_1d</span> <span class="o">=</span> <span class="n">_extract_region_average</span><span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="n">point_or_region</span><span class="p">)</span>
        <span class="n">points_data</span> <span class="o">=</span> <span class="p">[(</span><span class="n">data_1d</span><span class="p">,</span> <span class="s2">&quot;region_avg&quot;</span><span class="p">)]</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">point_or_region</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="c1"># Multiple points</span>
        <span class="n">points_data</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">pt</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">point_or_region</span><span class="p">):</span>
            <span class="n">data_1d</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_extract_timeseries_1d</span><span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="n">pt</span><span class="p">)</span>
            <span class="n">label</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;point_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="n">points_data</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">data_1d</span><span class="p">,</span> <span class="n">label</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Single point</span>
        <span class="n">data_1d</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_extract_timeseries_1d</span><span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="n">point_or_region</span><span class="p">)</span>
        <span class="n">points_data</span> <span class="o">=</span> <span class="p">[(</span><span class="n">data_1d</span><span class="p">,</span> <span class="s2">&quot;point_0&quot;</span><span class="p">)]</span>

    <span class="c1"># Compute PSD for each</span>
    <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">freq_unit</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">dt_unit</span>

    <span class="k">for</span> <span class="n">data_1d</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">points_data</span><span class="p">:</span>
        <span class="n">freqs</span><span class="p">,</span> <span class="n">psd_values</span> <span class="o">=</span> <span class="n">welch</span><span class="p">(</span>
            <span class="n">data_1d</span><span class="p">,</span>
            <span class="n">fs</span><span class="o">=</span><span class="n">fs</span><span class="p">,</span>
            <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span>
            <span class="n">nperseg</span><span class="o">=</span><span class="n">nperseg</span><span class="p">,</span>
            <span class="n">noverlap</span><span class="o">=</span><span class="n">noverlap</span><span class="p">,</span>
            <span class="n">detrend</span><span class="o">=</span><span class="n">detrend</span><span class="p">,</span>
            <span class="n">scaling</span><span class="o">=</span><span class="n">scaling</span><span class="p">,</span>
            <span class="n">average</span><span class="o">=</span><span class="n">average</span><span class="p">,</span>
            <span class="n">return_onesided</span><span class="o">=</span><span class="n">return_onesided</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Determine PSD unit</span>
        <span class="k">if</span> <span class="n">field</span><span class="o">.</span><span class="n">unit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">scaling</span> <span class="o">==</span> <span class="s2">&quot;density&quot;</span><span class="p">:</span>
                <span class="n">psd_unit</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">unit</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">freq_unit</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># spectrum</span>
                <span class="n">psd_unit</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">unit</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">psd_unit</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">dimensionless_unscaled</span>

        <span class="n">fs_obj</span> <span class="o">=</span> <span class="n">FrequencySeries</span><span class="p">(</span>
            <span class="n">psd_values</span><span class="p">,</span>
            <span class="n">frequencies</span><span class="o">=</span><span class="n">freqs</span> <span class="o">*</span> <span class="n">freq_unit</span><span class="p">,</span>
            <span class="n">unit</span><span class="o">=</span><span class="n">psd_unit</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="n">label</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fs_obj</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">results</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">FrequencySeriesList</span><span class="p">(</span><span class="n">results</span><span class="p">)</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">_extract_region_average</span><span class="p">(</span>
    <span class="n">field</span><span class="p">:</span> <span class="n">ScalarField</span><span class="p">,</span>
    <span class="n">region</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Extract time series averaged over a spatial region.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    region : dict</span>
<span class="sd">        Dictionary with keys &#39;x&#39;, &#39;y&#39;, &#39;z&#39; specifying slices or values.</span>
<span class="sd">        Use slice(None) for full axis, or a single Quantity for a point.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">gwexpy.plot._coord</span><span class="w"> </span><span class="kn">import</span> <span class="n">nearest_index</span><span class="p">,</span> <span class="n">slice_from_index</span>

    <span class="n">slices</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span>  <span class="c1"># t, x, y, z</span>

    <span class="n">axes_info</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">field</span><span class="o">.</span><span class="n">_axis1_index</span><span class="p">),</span>
        <span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">field</span><span class="o">.</span><span class="n">_axis2_index</span><span class="p">),</span>
        <span class="p">(</span><span class="s2">&quot;z&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">field</span><span class="o">.</span><span class="n">_axis3_index</span><span class="p">),</span>
    <span class="p">]</span>

    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">axis_index</span> <span class="ow">in</span> <span class="n">axes_info</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">region</span><span class="p">:</span>
            <span class="n">spec</span> <span class="o">=</span> <span class="n">region</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">spec</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
                <span class="n">slices</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">spec</span>
            <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">spec</span><span class="p">,</span> <span class="s2">&quot;unit&quot;</span><span class="p">):</span>
                <span class="c1"># Single value -&gt; convert to index</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">nearest_index</span><span class="p">(</span><span class="n">axis_index</span><span class="p">,</span> <span class="n">spec</span><span class="p">)</span>
                <span class="n">slices</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">slice_from_index</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">slices</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">spec</span>

    <span class="c1"># Extract region</span>
    <span class="n">extracted</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slices</span><span class="p">)]</span>

    <span class="c1"># Average over spatial dimensions (axes 1, 2, 3 after slicing)</span>
    <span class="c1"># The time axis is always 0</span>
    <span class="n">spatial_axes</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">extracted</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">extracted</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">spatial_axes</span><span class="p">)</span>


<div class="viewcode-block" id="freq_space_map">
<a class="viewcode-back" href="../../../reference/api/fields.html#gwexpy.fields.freq_space_map">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">freq_space_map</span><span class="p">(</span>
    <span class="n">field</span><span class="p">:</span> <span class="n">ScalarField</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">at</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Quantity</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">method</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;welch&quot;</span><span class="p">,</span> <span class="s2">&quot;fft&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;welch&quot;</span><span class="p">,</span>
    <span class="n">nperseg</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">noverlap</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">window</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;hann&quot;</span><span class="p">,</span>
    <span class="n">detrend</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="nb">bool</span> <span class="o">=</span> <span class="s2">&quot;constant&quot;</span><span class="p">,</span>
    <span class="n">scaling</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;density&quot;</span><span class="p">,</span> <span class="s2">&quot;spectrum&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;density&quot;</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ScalarField</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute frequency-space map along a spatial axis.</span>

<span class="sd">    Scans along the specified spatial axis, computing PSD at each position</span>
<span class="sd">    while fixing other spatial coordinates. Produces a 2D map with</span>
<span class="sd">    frequency on one axis and spatial coordinate on the other.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    field : ScalarField</span>
<span class="sd">        Input 4D field with axis0_domain=&#39;time&#39;.</span>
<span class="sd">    axis : str</span>
<span class="sd">        Spatial axis to scan along (&#39;x&#39;, &#39;y&#39;, or &#39;z&#39;).</span>
<span class="sd">    at : dict, optional</span>
<span class="sd">        Fixed values for the other two spatial axes.</span>
<span class="sd">        Example: ``{&#39;y&#39;: 0*u.m, &#39;z&#39;: 0*u.m}`` when axis=&#39;x&#39;.</span>
<span class="sd">    method : {&#39;welch&#39;, &#39;fft&#39;}</span>
<span class="sd">        PSD estimation method. Default is &#39;welch&#39;.</span>
<span class="sd">    nperseg : int, optional</span>
<span class="sd">        Segment length for Welch method. Default is min(256, nt).</span>
<span class="sd">    noverlap : int, optional</span>
<span class="sd">        Overlap for Welch method. Default is nperseg // 2.</span>
<span class="sd">    window : str</span>
<span class="sd">        Window function. Default is &#39;hann&#39;.</span>
<span class="sd">    detrend : str or bool</span>
<span class="sd">        Detrending method. Default is &#39;constant&#39;.</span>
<span class="sd">    scaling : {&#39;density&#39;, &#39;spectrum&#39;}</span>
<span class="sd">        PSD scaling. Default is &#39;density&#39;.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ScalarField</span>
<span class="sd">        2D frequency-space map stored as ScalarField with:</span>
<span class="sd">        - axis0: frequency (with axis0_domain=&#39;frequency&#39;)</span>
<span class="sd">        - axis1: spatial coordinate</span>
<span class="sd">        - axis2, axis3: length-1 dummy axes</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from astropy import units as u</span>
<span class="sd">    &gt;&gt;&gt; fsmap = freq_space_map(field, &#39;x&#39;, at={&#39;y&#39;: 0*u.m, &#39;z&#39;: 0*u.m})</span>
<span class="sd">    &gt;&gt;&gt; fsmap.shape  # (n_freq, n_x, 1, 1)</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    compute_psd : Single-point PSD computation.</span>
<span class="sd">    compute_freq_space : Alias for this function.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">scipy.signal</span><span class="w"> </span><span class="kn">import</span> <span class="n">welch</span>

    <span class="kn">from</span><span class="w"> </span><span class="nn">gwexpy.plot._coord</span><span class="w"> </span><span class="kn">import</span> <span class="n">nearest_index</span><span class="p">,</span> <span class="n">slice_from_index</span>

    <span class="n">dt_value</span><span class="p">,</span> <span class="n">dt_unit</span> <span class="o">=</span> <span class="n">_validate_regular_time_axis</span><span class="p">(</span><span class="n">field</span><span class="p">)</span>
    <span class="n">fs</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">dt_value</span>

    <span class="n">nt</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">nperseg</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">nperseg</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mi">256</span><span class="p">,</span> <span class="n">nt</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">noverlap</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">noverlap</span> <span class="o">=</span> <span class="n">nperseg</span> <span class="o">//</span> <span class="mi">2</span>

    <span class="c1"># Map axis name to index</span>
    <span class="n">axis_int</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">_get_axis_index</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">axis_int</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot use time axis for freq_space_map. Use compute_psd.&quot;</span><span class="p">)</span>

    <span class="c1"># Get axis coordinates</span>
    <span class="n">axis_mapping</span> <span class="o">=</span> <span class="p">{</span>
        <span class="mi">1</span><span class="p">:</span> <span class="p">(</span><span class="n">field</span><span class="o">.</span><span class="n">_axis1_name</span><span class="p">,</span> <span class="n">field</span><span class="o">.</span><span class="n">_axis1_index</span><span class="p">),</span>
        <span class="mi">2</span><span class="p">:</span> <span class="p">(</span><span class="n">field</span><span class="o">.</span><span class="n">_axis2_name</span><span class="p">,</span> <span class="n">field</span><span class="o">.</span><span class="n">_axis2_index</span><span class="p">),</span>
        <span class="mi">3</span><span class="p">:</span> <span class="p">(</span><span class="n">field</span><span class="o">.</span><span class="n">_axis3_name</span><span class="p">,</span> <span class="n">field</span><span class="o">.</span><span class="n">_axis3_index</span><span class="p">),</span>
    <span class="p">}</span>
    <span class="n">scan_axis_name</span><span class="p">,</span> <span class="n">scan_axis_index</span> <span class="o">=</span> <span class="n">axis_mapping</span><span class="p">[</span><span class="n">axis_int</span><span class="p">]</span>
    <span class="n">n_scan</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">scan_axis_index</span><span class="p">)</span>

    <span class="c1"># Build base slice with fixed coordinates</span>
    <span class="k">if</span> <span class="n">at</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">at</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="n">slices</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="mi">4</span>  <span class="c1"># t, x, y, z</span>

    <span class="k">for</span> <span class="n">ax_int</span><span class="p">,</span> <span class="p">(</span><span class="n">ax_name</span><span class="p">,</span> <span class="n">ax_index</span><span class="p">)</span> <span class="ow">in</span> <span class="n">axis_mapping</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">ax_int</span> <span class="o">==</span> <span class="n">axis_int</span><span class="p">:</span>
            <span class="k">continue</span>  <span class="c1"># We&#39;ll iterate over this axis</span>

        <span class="k">if</span> <span class="n">ax_name</span> <span class="ow">in</span> <span class="n">at</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">nearest_index</span><span class="p">(</span><span class="n">ax_index</span><span class="p">,</span> <span class="n">at</span><span class="p">[</span><span class="n">ax_name</span><span class="p">])</span>
            <span class="n">slices</span><span class="p">[</span><span class="n">ax_int</span><span class="p">]</span> <span class="o">=</span> <span class="n">slice_from_index</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">ax_index</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">slices</span><span class="p">[</span><span class="n">ax_int</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Axis &#39;</span><span class="si">{</span><span class="n">ax_name</span><span class="si">}</span><span class="s2">&#39; has length </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">ax_index</span><span class="p">)</span><span class="si">}</span><span class="s2"> &gt; 1. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Specify its value in &#39;at&#39;.&quot;</span>
            <span class="p">)</span>

    <span class="c1"># Compute PSD at each position along scan axis</span>
    <span class="n">psd_list</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">i_pos</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_scan</span><span class="p">):</span>
        <span class="n">slices</span><span class="p">[</span><span class="n">axis_int</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">i_pos</span><span class="p">,</span> <span class="n">i_pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">data_1d</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slices</span><span class="p">)]</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;welch&quot;</span><span class="p">:</span>
            <span class="n">freqs</span><span class="p">,</span> <span class="n">psd_values</span> <span class="o">=</span> <span class="n">welch</span><span class="p">(</span>
                <span class="n">data_1d</span><span class="p">,</span>
                <span class="n">fs</span><span class="o">=</span><span class="n">fs</span><span class="p">,</span>
                <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span>
                <span class="n">nperseg</span><span class="o">=</span><span class="n">nperseg</span><span class="p">,</span>
                <span class="n">noverlap</span><span class="o">=</span><span class="n">noverlap</span><span class="p">,</span>
                <span class="n">detrend</span><span class="o">=</span><span class="n">detrend</span><span class="p">,</span>
                <span class="n">scaling</span><span class="o">=</span><span class="n">scaling</span><span class="p">,</span>
                <span class="n">return_onesided</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># fft</span>
            <span class="n">fft_result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfft</span><span class="p">(</span><span class="n">data_1d</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_1d</span><span class="p">)</span>
            <span class="n">psd_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">fft_result</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
            <span class="n">psd_values</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*=</span> <span class="mi">2</span>  <span class="c1"># One-sided correction</span>
            <span class="n">freqs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfftfreq</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data_1d</span><span class="p">),</span> <span class="n">d</span><span class="o">=</span><span class="n">dt_value</span><span class="p">)</span>

        <span class="n">psd_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">psd_values</span><span class="p">)</span>

    <span class="c1"># Stack into 2D array: (n_freq, n_scan)</span>
    <span class="n">psd_2d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">psd_list</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

    <span class="c1"># Reshape to 4D: (n_freq, n_scan, 1, 1) or appropriate dimension</span>
    <span class="c1"># We need to place n_scan at the correct axis position</span>
    <span class="n">shape_4d</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">freqs</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">shape_4d</span><span class="p">[</span><span class="n">axis_int</span><span class="p">]</span> <span class="o">=</span> <span class="n">n_scan</span>
    <span class="n">psd_4d</span> <span class="o">=</span> <span class="n">psd_2d</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape_4d</span><span class="p">)</span>

    <span class="c1"># Build axis arrays</span>
    <span class="n">freq_unit</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">dt_unit</span>
    <span class="n">freq_axis</span> <span class="o">=</span> <span class="n">freqs</span> <span class="o">*</span> <span class="n">freq_unit</span>

    <span class="c1"># Dummy axes for non-scan spatial axes</span>
    <span class="n">dummy_axes</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">ax_int</span><span class="p">,</span> <span class="p">(</span><span class="n">ax_name</span><span class="p">,</span> <span class="n">ax_index</span><span class="p">)</span> <span class="ow">in</span> <span class="n">axis_mapping</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">ax_int</span> <span class="o">==</span> <span class="n">axis_int</span><span class="p">:</span>
            <span class="n">dummy_axes</span><span class="p">[</span><span class="n">ax_int</span><span class="p">]</span> <span class="o">=</span> <span class="n">scan_axis_index</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Use the single fixed value</span>
            <span class="k">if</span> <span class="n">ax_name</span> <span class="ow">in</span> <span class="n">at</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">nearest_index</span><span class="p">(</span><span class="n">ax_index</span><span class="p">,</span> <span class="n">at</span><span class="p">[</span><span class="n">ax_name</span><span class="p">])</span>
                <span class="n">dummy_axes</span><span class="p">[</span><span class="n">ax_int</span><span class="p">]</span> <span class="o">=</span> <span class="n">ax_index</span><span class="p">[</span><span class="n">idx</span> <span class="p">:</span> <span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dummy_axes</span><span class="p">[</span><span class="n">ax_int</span><span class="p">]</span> <span class="o">=</span> <span class="n">ax_index</span><span class="p">[:</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># Determine unit</span>
    <span class="k">if</span> <span class="n">field</span><span class="o">.</span><span class="n">unit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">scaling</span> <span class="o">==</span> <span class="s2">&quot;density&quot;</span><span class="p">:</span>
            <span class="n">psd_unit</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">unit</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">freq_unit</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">psd_unit</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">unit</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">psd_unit</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">dimensionless_unscaled</span>

    <span class="kn">from</span><span class="w"> </span><span class="nn">gwexpy.fields</span><span class="w"> </span><span class="kn">import</span> <span class="n">ScalarField</span>

    <span class="k">return</span> <span class="n">ScalarField</span><span class="p">(</span>
        <span class="n">psd_4d</span><span class="p">,</span>
        <span class="n">unit</span><span class="o">=</span><span class="n">psd_unit</span><span class="p">,</span>
        <span class="n">axis0</span><span class="o">=</span><span class="n">freq_axis</span><span class="p">,</span>
        <span class="n">axis1</span><span class="o">=</span><span class="n">dummy_axes</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
        <span class="n">axis2</span><span class="o">=</span><span class="n">dummy_axes</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
        <span class="n">axis3</span><span class="o">=</span><span class="n">dummy_axes</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
        <span class="n">axis_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;f&quot;</span><span class="p">,</span> <span class="n">field</span><span class="o">.</span><span class="n">_axis1_name</span><span class="p">,</span> <span class="n">field</span><span class="o">.</span><span class="n">_axis2_name</span><span class="p">,</span> <span class="n">field</span><span class="o">.</span><span class="n">_axis3_name</span><span class="p">],</span>
        <span class="n">axis0_domain</span><span class="o">=</span><span class="s2">&quot;frequency&quot;</span><span class="p">,</span>
        <span class="n">space_domain</span><span class="o">=</span><span class="n">field</span><span class="o">.</span><span class="n">_space_domains</span><span class="p">,</span>
    <span class="p">)</span></div>



<span class="c1"># Alias</span>
<span class="n">compute_freq_space</span> <span class="o">=</span> <span class="n">freq_space_map</span>


<div class="viewcode-block" id="compute_xcorr">
<a class="viewcode-back" href="../../../reference/api/fields.html#gwexpy.fields.compute_xcorr">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">compute_xcorr</span><span class="p">(</span>
    <span class="n">field</span><span class="p">:</span> <span class="n">ScalarField</span><span class="p">,</span>
    <span class="n">point_a</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Quantity</span><span class="p">,</span> <span class="n">Quantity</span><span class="p">,</span> <span class="n">Quantity</span><span class="p">],</span>
    <span class="n">point_b</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Quantity</span><span class="p">,</span> <span class="n">Quantity</span><span class="p">,</span> <span class="n">Quantity</span><span class="p">],</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">max_lag</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="n">Quantity</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">mode</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;full&quot;</span><span class="p">,</span> <span class="s2">&quot;same&quot;</span><span class="p">,</span> <span class="s2">&quot;valid&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;full&quot;</span><span class="p">,</span>
    <span class="n">normalize</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">detrend</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">window</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TimeSeries</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute cross-correlation between two spatial points.</span>

<span class="sd">    Calculates the normalized (or unnormalized) cross-correlation function</span>
<span class="sd">    between time series extracted at two spatial locations.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    field : ScalarField</span>
<span class="sd">        Input 4D field with axis0_domain=&#39;time&#39;.</span>
<span class="sd">    point_a, point_b : tuple of Quantity</span>
<span class="sd">        Spatial coordinates (x, y, z) for the two points.</span>
<span class="sd">    max_lag : int or Quantity, optional</span>
<span class="sd">        Maximum lag to compute. If Quantity, converted to samples.</span>
<span class="sd">        If None, uses all available lags.</span>
<span class="sd">    mode : {&#39;full&#39;, &#39;same&#39;, &#39;valid&#39;}</span>
<span class="sd">        Correlation mode (see numpy.correlate). Default is &#39;full&#39;.</span>
<span class="sd">    normalize : bool</span>
<span class="sd">        If True, normalize to [-1, 1] range. Default True.</span>
<span class="sd">    detrend : bool</span>
<span class="sd">        If True, remove mean before correlation. Default True.</span>
<span class="sd">    window : str, optional</span>
<span class="sd">        Window function to apply before correlation. Default None.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    TimeSeries</span>
<span class="sd">        Cross-correlation function with lag axis in time units.</span>
<span class="sd">        Positive lag means point_b leads point_a.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from astropy import units as u</span>
<span class="sd">    &gt;&gt;&gt; xcorr = compute_xcorr(field, (0*u.m, 0*u.m, 0*u.m), (1*u.m, 0*u.m, 0*u.m))</span>
<span class="sd">    &gt;&gt;&gt; xcorr.times  # Lag axis</span>
<span class="sd">    &gt;&gt;&gt; xcorr.value  # Correlation values</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The correlation is computed as ``correlate(a, b, mode)``, where</span>
<span class="sd">    positive values in the output correspond to ``b`` leading ``a``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">scipy.signal</span><span class="w"> </span><span class="kn">import</span> <span class="n">correlate</span><span class="p">,</span> <span class="n">get_window</span>

    <span class="kn">from</span><span class="w"> </span><span class="nn">gwexpy.timeseries</span><span class="w"> </span><span class="kn">import</span> <span class="n">TimeSeries</span>

    <span class="c1"># Extract time series</span>
    <span class="n">dt_value</span><span class="p">,</span> <span class="n">dt_unit</span> <span class="o">=</span> <span class="n">_validate_regular_time_axis</span><span class="p">(</span><span class="n">field</span><span class="p">)</span>
    <span class="n">data_a</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_extract_timeseries_1d</span><span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="n">point_a</span><span class="p">)</span>
    <span class="n">data_b</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_extract_timeseries_1d</span><span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="n">point_b</span><span class="p">)</span>

    <span class="c1"># Detrend</span>
    <span class="k">if</span> <span class="n">detrend</span><span class="p">:</span>
        <span class="n">data_a</span> <span class="o">=</span> <span class="n">data_a</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">data_a</span><span class="p">)</span>
        <span class="n">data_b</span> <span class="o">=</span> <span class="n">data_b</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">data_b</span><span class="p">)</span>

    <span class="c1"># Apply window</span>
    <span class="k">if</span> <span class="n">window</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_a</span><span class="p">)</span>
        <span class="n">win</span> <span class="o">=</span> <span class="n">get_window</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
        <span class="n">data_a</span> <span class="o">=</span> <span class="n">data_a</span> <span class="o">*</span> <span class="n">win</span>
        <span class="n">data_b</span> <span class="o">=</span> <span class="n">data_b</span> <span class="o">*</span> <span class="n">win</span>

    <span class="c1"># Compute correlation</span>
    <span class="n">corr</span> <span class="o">=</span> <span class="n">correlate</span><span class="p">(</span><span class="n">data_a</span><span class="p">,</span> <span class="n">data_b</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>

    <span class="c1"># Normalize</span>
    <span class="k">if</span> <span class="n">normalize</span><span class="p">:</span>
        <span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">data_a</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">data_b</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">norm</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">corr</span> <span class="o">=</span> <span class="n">corr</span> <span class="o">/</span> <span class="n">norm</span>

    <span class="c1"># Build lag axis</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_a</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;full&quot;</span><span class="p">:</span>
        <span class="n">lags</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="n">n</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;same&quot;</span><span class="p">:</span>
        <span class="n">lags</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">n</span> <span class="o">//</span> <span class="mi">2</span><span class="p">),</span> <span class="n">n</span> <span class="o">-</span> <span class="n">n</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>  <span class="c1"># valid</span>
        <span class="n">lags</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">corr</span><span class="p">))</span>

    <span class="n">lag_times</span> <span class="o">=</span> <span class="n">lags</span> <span class="o">*</span> <span class="n">dt_value</span> <span class="o">*</span> <span class="n">dt_unit</span>

    <span class="c1"># Apply max_lag truncation</span>
    <span class="k">if</span> <span class="n">max_lag</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">max_lag</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">Quantity</span><span class="p">):</span>
            <span class="n">max_lag_samples</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">max_lag</span><span class="o">.</span><span class="n">to_value</span><span class="p">(</span><span class="n">dt_unit</span><span class="p">)</span> <span class="o">/</span> <span class="n">dt_value</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">max_lag_samples</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">max_lag</span><span class="p">)</span>

        <span class="n">center</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lags</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="n">start</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">center</span> <span class="o">-</span> <span class="n">max_lag_samples</span><span class="p">)</span>
        <span class="n">end</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lags</span><span class="p">),</span> <span class="n">center</span> <span class="o">+</span> <span class="n">max_lag_samples</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">corr</span> <span class="o">=</span> <span class="n">corr</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span>
        <span class="n">lag_times</span> <span class="o">=</span> <span class="n">lag_times</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">TimeSeries</span><span class="p">(</span>
        <span class="n">corr</span><span class="p">,</span>
        <span class="n">times</span><span class="o">=</span><span class="n">lag_times</span><span class="p">,</span>
        <span class="n">unit</span><span class="o">=</span><span class="n">u</span><span class="o">.</span><span class="n">dimensionless_unscaled</span> <span class="k">if</span> <span class="n">normalize</span> <span class="k">else</span> <span class="n">field</span><span class="o">.</span><span class="n">unit</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span>
        <span class="n">name</span><span class="o">=</span><span class="s2">&quot;xcorr&quot;</span><span class="p">,</span>
    <span class="p">)</span></div>



<div class="viewcode-block" id="time_delay_map">
<a class="viewcode-back" href="../../../reference/api/fields.html#gwexpy.fields.time_delay_map">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">time_delay_map</span><span class="p">(</span>
    <span class="n">field</span><span class="p">:</span> <span class="n">ScalarField</span><span class="p">,</span>
    <span class="n">ref_point</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Quantity</span><span class="p">,</span> <span class="n">Quantity</span><span class="p">,</span> <span class="n">Quantity</span><span class="p">],</span>
    <span class="n">plane</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;xy&quot;</span><span class="p">,</span>
    <span class="n">at</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Quantity</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">max_lag</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="n">Quantity</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">stride</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">roi</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">slice</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">normalize</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">detrend</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ScalarField</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute time delay map from a reference point to a 2D slice.</span>

<span class="sd">    For each point in the specified plane, computes cross-correlation</span>
<span class="sd">    with the reference point and extracts the lag at maximum correlation.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    field : ScalarField</span>
<span class="sd">        Input 4D field with axis0_domain=&#39;time&#39;.</span>
<span class="sd">    ref_point : tuple of Quantity</span>
<span class="sd">        Reference point coordinates (x, y, z).</span>
<span class="sd">    plane : str</span>
<span class="sd">        2D plane to map: &#39;xy&#39;, &#39;xz&#39;, or &#39;yz&#39;. Default &#39;xy&#39;.</span>
<span class="sd">    at : dict, optional</span>
<span class="sd">        Fixed value for the axis not in the plane.</span>
<span class="sd">        Example: ``{&#39;z&#39;: 0*u.m}`` when plane=&#39;xy&#39;.</span>
<span class="sd">    max_lag : int or Quantity, optional</span>
<span class="sd">        Maximum lag to search for peak. Default uses all lags.</span>
<span class="sd">    stride : int</span>
<span class="sd">        Subsample stride to reduce computation. Default 1 (no subsampling).</span>
<span class="sd">    roi : dict, optional</span>
<span class="sd">        Region of interest as dict of slices. Example:</span>
<span class="sd">        ``{&#39;x&#39;: slice(10, 50), &#39;y&#39;: slice(20, 80)}``</span>
<span class="sd">    normalize : bool</span>
<span class="sd">        Normalize correlation. Default True.</span>
<span class="sd">    detrend : bool</span>
<span class="sd">        Detrend before correlation. Default True.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ScalarField</span>
<span class="sd">        Time delay map as ScalarField slice with delay values in time units.</span>
<span class="sd">        Shape matches the input plane dimensions (with stride applied).</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from astropy import units as u</span>
<span class="sd">    &gt;&gt;&gt; delay_map = time_delay_map(</span>
<span class="sd">    ...     field,</span>
<span class="sd">    ...     ref_point=(0*u.m, 0*u.m, 0*u.m),</span>
<span class="sd">    ...     plane=&#39;xy&#39;,</span>
<span class="sd">    ...     at={&#39;z&#39;: 0*u.m}</span>
<span class="sd">    ... )</span>
<span class="sd">    &gt;&gt;&gt; delay_map.plot_map2d(&#39;xy&#39;)</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Positive delay means the point leads the reference.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">scipy.signal</span><span class="w"> </span><span class="kn">import</span> <span class="n">correlate</span>

    <span class="kn">from</span><span class="w"> </span><span class="nn">gwexpy.plot._coord</span><span class="w"> </span><span class="kn">import</span> <span class="n">nearest_index</span>

    <span class="n">dt_value</span><span class="p">,</span> <span class="n">dt_unit</span> <span class="o">=</span> <span class="n">_validate_regular_time_axis</span><span class="p">(</span><span class="n">field</span><span class="p">)</span>

    <span class="c1"># Extract reference time series</span>
    <span class="n">ref_data</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_extract_timeseries_1d</span><span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="n">ref_point</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">detrend</span><span class="p">:</span>
        <span class="n">ref_data</span> <span class="o">=</span> <span class="n">ref_data</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">ref_data</span><span class="p">)</span>

    <span class="c1"># Parse plane to get the two axes</span>
    <span class="n">plane_map</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;xy&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>  <span class="c1"># scan x, y; fix z</span>
        <span class="s2">&quot;xz&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>  <span class="c1"># scan x, z; fix y</span>
        <span class="s2">&quot;yz&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>  <span class="c1"># scan y, z; fix x</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="n">plane</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">plane_map</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid plane &#39;</span><span class="si">{</span><span class="n">plane</span><span class="si">}</span><span class="s2">&#39;. Must be &#39;xy&#39;, &#39;xz&#39;, or &#39;yz&#39;.&quot;</span><span class="p">)</span>

    <span class="n">ax1_int</span><span class="p">,</span> <span class="n">ax2_int</span><span class="p">,</span> <span class="n">fix_int</span> <span class="o">=</span> <span class="n">plane_map</span><span class="p">[</span><span class="n">plane</span><span class="o">.</span><span class="n">lower</span><span class="p">()]</span>

    <span class="c1"># Get axis info</span>
    <span class="n">axis_mapping</span> <span class="o">=</span> <span class="p">{</span>
        <span class="mi">1</span><span class="p">:</span> <span class="p">(</span><span class="n">field</span><span class="o">.</span><span class="n">_axis1_name</span><span class="p">,</span> <span class="n">field</span><span class="o">.</span><span class="n">_axis1_index</span><span class="p">),</span>
        <span class="mi">2</span><span class="p">:</span> <span class="p">(</span><span class="n">field</span><span class="o">.</span><span class="n">_axis2_name</span><span class="p">,</span> <span class="n">field</span><span class="o">.</span><span class="n">_axis2_index</span><span class="p">),</span>
        <span class="mi">3</span><span class="p">:</span> <span class="p">(</span><span class="n">field</span><span class="o">.</span><span class="n">_axis3_name</span><span class="p">,</span> <span class="n">field</span><span class="o">.</span><span class="n">_axis3_index</span><span class="p">),</span>
    <span class="p">}</span>

    <span class="n">ax1_name</span><span class="p">,</span> <span class="n">ax1_index</span> <span class="o">=</span> <span class="n">axis_mapping</span><span class="p">[</span><span class="n">ax1_int</span><span class="p">]</span>
    <span class="n">ax2_name</span><span class="p">,</span> <span class="n">ax2_index</span> <span class="o">=</span> <span class="n">axis_mapping</span><span class="p">[</span><span class="n">ax2_int</span><span class="p">]</span>
    <span class="n">fix_name</span><span class="p">,</span> <span class="n">fix_index</span> <span class="o">=</span> <span class="n">axis_mapping</span><span class="p">[</span><span class="n">fix_int</span><span class="p">]</span>

    <span class="c1"># Fixed axis</span>
    <span class="k">if</span> <span class="n">at</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">at</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="n">fix_name</span> <span class="ow">in</span> <span class="n">at</span><span class="p">:</span>
        <span class="n">fix_idx</span> <span class="o">=</span> <span class="n">nearest_index</span><span class="p">(</span><span class="n">fix_index</span><span class="p">,</span> <span class="n">at</span><span class="p">[</span><span class="n">fix_name</span><span class="p">])</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">fix_index</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">fix_idx</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Axis &#39;</span><span class="si">{</span><span class="n">fix_name</span><span class="si">}</span><span class="s2">&#39; has length </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">fix_index</span><span class="p">)</span><span class="si">}</span><span class="s2"> &gt; 1. &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;Specify its value in &#39;at&#39;.&quot;</span>
        <span class="p">)</span>

    <span class="c1"># Apply ROI and stride</span>
    <span class="k">if</span> <span class="n">roi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">roi</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="n">ax1_slice</span> <span class="o">=</span> <span class="n">roi</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">ax1_name</span><span class="p">,</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">))</span>
    <span class="n">ax2_slice</span> <span class="o">=</span> <span class="n">roi</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">ax2_name</span><span class="p">,</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">))</span>

    <span class="n">ax1_indices</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="o">*</span><span class="n">ax1_slice</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ax1_index</span><span class="p">)))[::</span><span class="n">stride</span><span class="p">]</span>
    <span class="n">ax2_indices</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="o">*</span><span class="n">ax2_slice</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ax2_index</span><span class="p">)))[::</span><span class="n">stride</span><span class="p">]</span>

    <span class="n">n1</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ax1_indices</span><span class="p">)</span>
    <span class="n">n2</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ax2_indices</span><span class="p">)</span>

    <span class="c1"># Compute delay for each point</span>
    <span class="n">delay_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">))</span>
    <span class="n">nt</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Max lag in samples</span>
    <span class="k">if</span> <span class="n">max_lag</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">max_lag</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">Quantity</span><span class="p">):</span>
            <span class="n">max_lag_samples</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">max_lag</span><span class="o">.</span><span class="n">to_value</span><span class="p">(</span><span class="n">dt_unit</span><span class="p">)</span> <span class="o">/</span> <span class="n">dt_value</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">max_lag_samples</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">max_lag</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">max_lag_samples</span> <span class="o">=</span> <span class="n">nt</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="k">for</span> <span class="n">i1</span><span class="p">,</span> <span class="n">idx1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ax1_indices</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i2</span><span class="p">,</span> <span class="n">idx2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ax2_indices</span><span class="p">):</span>
            <span class="c1"># Build index for extraction</span>
            <span class="n">slices</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">slices</span><span class="p">[</span><span class="n">ax1_int</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx1</span>
            <span class="n">slices</span><span class="p">[</span><span class="n">ax2_int</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx2</span>
            <span class="n">slices</span><span class="p">[</span><span class="n">fix_int</span><span class="p">]</span> <span class="o">=</span> <span class="n">fix_idx</span>

            <span class="n">data</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slices</span><span class="p">)]</span>
            <span class="k">if</span> <span class="n">detrend</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">data</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

            <span class="c1"># Cross-correlation</span>
            <span class="n">corr</span> <span class="o">=</span> <span class="n">correlate</span><span class="p">(</span><span class="n">ref_data</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;full&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">normalize</span><span class="p">:</span>
                <span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ref_data</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">data</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">norm</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">corr</span> <span class="o">=</span> <span class="n">corr</span> <span class="o">/</span> <span class="n">norm</span>

            <span class="c1"># Find peak within max_lag</span>
            <span class="n">lags</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">nt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="n">nt</span><span class="p">)</span>
            <span class="n">center</span> <span class="o">=</span> <span class="n">nt</span> <span class="o">-</span> <span class="mi">1</span>

            <span class="n">start</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">center</span> <span class="o">-</span> <span class="n">max_lag_samples</span><span class="p">)</span>
            <span class="n">end</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lags</span><span class="p">),</span> <span class="n">center</span> <span class="o">+</span> <span class="n">max_lag_samples</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

            <span class="n">search_corr</span> <span class="o">=</span> <span class="n">corr</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span>
            <span class="n">search_lags</span> <span class="o">=</span> <span class="n">lags</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span>

            <span class="n">peak_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">search_corr</span><span class="p">))</span>
            <span class="n">delay_samples</span> <span class="o">=</span> <span class="n">search_lags</span><span class="p">[</span><span class="n">peak_idx</span><span class="p">]</span>
            <span class="n">delay_values</span><span class="p">[</span><span class="n">i1</span><span class="p">,</span> <span class="n">i2</span><span class="p">]</span> <span class="o">=</span> <span class="n">delay_samples</span> <span class="o">*</span> <span class="n">dt_value</span>

    <span class="c1"># Build output ScalarField</span>
    <span class="c1"># Shape: (1, n1 or 1, n2 or 1, 1) depending on plane</span>
    <span class="n">shape_4d</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">shape_4d</span><span class="p">[</span><span class="n">ax1_int</span><span class="p">]</span> <span class="o">=</span> <span class="n">n1</span>
    <span class="n">shape_4d</span><span class="p">[</span><span class="n">ax2_int</span><span class="p">]</span> <span class="o">=</span> <span class="n">n2</span>
    <span class="n">delay_4d</span> <span class="o">=</span> <span class="n">delay_values</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape_4d</span><span class="p">)</span>

    <span class="c1"># Build axis arrays</span>
    <span class="n">ax1_val</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">ax1_index</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">,</span> <span class="n">ax1_index</span><span class="p">)</span>
    <span class="n">ax1_unit</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">ax1_index</span><span class="p">,</span> <span class="s2">&quot;unit&quot;</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">dimensionless_unscaled</span><span class="p">)</span>
    <span class="n">ax2_val</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">ax2_index</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">,</span> <span class="n">ax2_index</span><span class="p">)</span>
    <span class="n">ax2_unit</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">ax2_index</span><span class="p">,</span> <span class="s2">&quot;unit&quot;</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">dimensionless_unscaled</span><span class="p">)</span>

    <span class="n">ax1_out</span> <span class="o">=</span> <span class="n">ax1_val</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">ax1_indices</span><span class="p">)]</span> <span class="o">*</span> <span class="n">ax1_unit</span>
    <span class="n">ax2_out</span> <span class="o">=</span> <span class="n">ax2_val</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">ax2_indices</span><span class="p">)]</span> <span class="o">*</span> <span class="n">ax2_unit</span>

    <span class="n">axes_out</span> <span class="o">=</span> <span class="p">{</span>
        <span class="mi">1</span><span class="p">:</span> <span class="n">field</span><span class="o">.</span><span class="n">_axis1_index</span><span class="p">[:</span><span class="mi">1</span><span class="p">],</span>
        <span class="mi">2</span><span class="p">:</span> <span class="n">field</span><span class="o">.</span><span class="n">_axis2_index</span><span class="p">[:</span><span class="mi">1</span><span class="p">],</span>
        <span class="mi">3</span><span class="p">:</span> <span class="n">field</span><span class="o">.</span><span class="n">_axis3_index</span><span class="p">[:</span><span class="mi">1</span><span class="p">],</span>
    <span class="p">}</span>
    <span class="n">axes_out</span><span class="p">[</span><span class="n">ax1_int</span><span class="p">]</span> <span class="o">=</span> <span class="n">ax1_out</span>
    <span class="n">axes_out</span><span class="p">[</span><span class="n">ax2_int</span><span class="p">]</span> <span class="o">=</span> <span class="n">ax2_out</span>
    <span class="n">axes_out</span><span class="p">[</span><span class="n">fix_int</span><span class="p">]</span> <span class="o">=</span> <span class="n">fix_index</span><span class="p">[</span><span class="n">fix_idx</span> <span class="p">:</span> <span class="n">fix_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

    <span class="kn">from</span><span class="w"> </span><span class="nn">gwexpy.fields</span><span class="w"> </span><span class="kn">import</span> <span class="n">ScalarField</span>

    <span class="k">return</span> <span class="n">ScalarField</span><span class="p">(</span>
        <span class="n">delay_4d</span><span class="p">,</span>
        <span class="n">unit</span><span class="o">=</span><span class="n">dt_unit</span><span class="p">,</span>
        <span class="n">axis0</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">])</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">s</span><span class="p">,</span>  <span class="c1"># Dummy time axis</span>
        <span class="n">axis1</span><span class="o">=</span><span class="n">axes_out</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
        <span class="n">axis2</span><span class="o">=</span><span class="n">axes_out</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
        <span class="n">axis3</span><span class="o">=</span><span class="n">axes_out</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
        <span class="n">axis_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;t&quot;</span><span class="p">,</span> <span class="n">field</span><span class="o">.</span><span class="n">_axis1_name</span><span class="p">,</span> <span class="n">field</span><span class="o">.</span><span class="n">_axis2_name</span><span class="p">,</span> <span class="n">field</span><span class="o">.</span><span class="n">_axis3_name</span><span class="p">],</span>
        <span class="n">axis0_domain</span><span class="o">=</span><span class="s2">&quot;time&quot;</span><span class="p">,</span>
        <span class="n">space_domain</span><span class="o">=</span><span class="n">field</span><span class="o">.</span><span class="n">_space_domains</span><span class="p">,</span>
    <span class="p">)</span></div>



<div class="viewcode-block" id="coherence_map">
<a class="viewcode-back" href="../../../reference/api/fields.html#gwexpy.fields.coherence_map">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">coherence_map</span><span class="p">(</span>
    <span class="n">field</span><span class="p">:</span> <span class="n">ScalarField</span><span class="p">,</span>
    <span class="n">ref_point</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Quantity</span><span class="p">,</span> <span class="n">Quantity</span><span class="p">,</span> <span class="n">Quantity</span><span class="p">],</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">plane</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;xy&quot;</span><span class="p">,</span>
    <span class="n">at</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Quantity</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">band</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Quantity</span><span class="p">,</span> <span class="n">Quantity</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">nperseg</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">noverlap</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">window</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;hann&quot;</span><span class="p">,</span>
    <span class="n">stride</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ScalarField</span> <span class="o">|</span> <span class="n">FieldDict</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute magnitude-squared coherence map from a reference point.</span>

<span class="sd">    Calculates coherence between the reference time series and all points</span>
<span class="sd">    in the specified 2D slice.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    field : ScalarField</span>
<span class="sd">        Input 4D field with axis0_domain=&#39;time&#39;.</span>
<span class="sd">    ref_point : tuple of Quantity</span>
<span class="sd">        Reference point coordinates (x, y, z).</span>
<span class="sd">    plane : str</span>
<span class="sd">        2D plane to map: &#39;xy&#39;, &#39;xz&#39;, or &#39;yz&#39;. Default &#39;xy&#39;.</span>
<span class="sd">    at : dict, optional</span>
<span class="sd">        Fixed value for the axis not in the plane.</span>
<span class="sd">    band : tuple of Quantity, optional</span>
<span class="sd">        Frequency band ``(fmin, fmax)`` to average coherence over.</span>
<span class="sd">        If None, returns coherence at all frequencies.</span>
<span class="sd">    nperseg : int, optional</span>
<span class="sd">        Segment length for coherence estimation. Default min(256, nt).</span>
<span class="sd">    noverlap : int, optional</span>
<span class="sd">        Overlap for segments. Default nperseg // 2.</span>
<span class="sd">    window : str</span>
<span class="sd">        Window function. Default &#39;hann&#39;.</span>
<span class="sd">    stride : int</span>
<span class="sd">        Subsample stride. Default 1.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ScalarField or FieldDict</span>
<span class="sd">        - If band is specified: ScalarField with scalar coherence values (0-1).</span>
<span class="sd">        - If band is None: FieldDict with keys as frequency indices,</span>
<span class="sd">          or a single ScalarField with frequency as axis0.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from astropy import units as u</span>
<span class="sd">    &gt;&gt;&gt; coh_map = coherence_map(</span>
<span class="sd">    ...     field,</span>
<span class="sd">    ...     ref_point=(0*u.m, 0*u.m, 0*u.m),</span>
<span class="sd">    ...     plane=&#39;xy&#39;,</span>
<span class="sd">    ...     at={&#39;z&#39;: 0*u.m},</span>
<span class="sd">    ...     band=(10*u.Hz, 100*u.Hz)</span>
<span class="sd">    ... )</span>
<span class="sd">    &gt;&gt;&gt; coh_map.plot_map2d(&#39;xy&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">scipy.signal</span><span class="w"> </span><span class="kn">import</span> <span class="n">coherence</span>

    <span class="kn">from</span><span class="w"> </span><span class="nn">gwexpy.plot._coord</span><span class="w"> </span><span class="kn">import</span> <span class="n">nearest_index</span>

    <span class="n">dt_value</span><span class="p">,</span> <span class="n">dt_unit</span> <span class="o">=</span> <span class="n">_validate_regular_time_axis</span><span class="p">(</span><span class="n">field</span><span class="p">)</span>
    <span class="n">fs</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">dt_value</span>

    <span class="n">nt</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">nperseg</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">nperseg</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mi">256</span><span class="p">,</span> <span class="n">nt</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">noverlap</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">noverlap</span> <span class="o">=</span> <span class="n">nperseg</span> <span class="o">//</span> <span class="mi">2</span>

    <span class="c1"># Extract reference time series</span>
    <span class="n">ref_data</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_extract_timeseries_1d</span><span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="n">ref_point</span><span class="p">)</span>

    <span class="c1"># Parse plane</span>
    <span class="n">plane_map</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;xy&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
        <span class="s2">&quot;xz&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
        <span class="s2">&quot;yz&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="n">plane</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">plane_map</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid plane &#39;</span><span class="si">{</span><span class="n">plane</span><span class="si">}</span><span class="s2">&#39;. Must be &#39;xy&#39;, &#39;xz&#39;, or &#39;yz&#39;.&quot;</span><span class="p">)</span>

    <span class="n">ax1_int</span><span class="p">,</span> <span class="n">ax2_int</span><span class="p">,</span> <span class="n">fix_int</span> <span class="o">=</span> <span class="n">plane_map</span><span class="p">[</span><span class="n">plane</span><span class="o">.</span><span class="n">lower</span><span class="p">()]</span>

    <span class="n">axis_mapping</span> <span class="o">=</span> <span class="p">{</span>
        <span class="mi">1</span><span class="p">:</span> <span class="p">(</span><span class="n">field</span><span class="o">.</span><span class="n">_axis1_name</span><span class="p">,</span> <span class="n">field</span><span class="o">.</span><span class="n">_axis1_index</span><span class="p">),</span>
        <span class="mi">2</span><span class="p">:</span> <span class="p">(</span><span class="n">field</span><span class="o">.</span><span class="n">_axis2_name</span><span class="p">,</span> <span class="n">field</span><span class="o">.</span><span class="n">_axis2_index</span><span class="p">),</span>
        <span class="mi">3</span><span class="p">:</span> <span class="p">(</span><span class="n">field</span><span class="o">.</span><span class="n">_axis3_name</span><span class="p">,</span> <span class="n">field</span><span class="o">.</span><span class="n">_axis3_index</span><span class="p">),</span>
    <span class="p">}</span>

    <span class="n">ax1_name</span><span class="p">,</span> <span class="n">ax1_index</span> <span class="o">=</span> <span class="n">axis_mapping</span><span class="p">[</span><span class="n">ax1_int</span><span class="p">]</span>
    <span class="n">ax2_name</span><span class="p">,</span> <span class="n">ax2_index</span> <span class="o">=</span> <span class="n">axis_mapping</span><span class="p">[</span><span class="n">ax2_int</span><span class="p">]</span>
    <span class="n">fix_name</span><span class="p">,</span> <span class="n">fix_index</span> <span class="o">=</span> <span class="n">axis_mapping</span><span class="p">[</span><span class="n">fix_int</span><span class="p">]</span>

    <span class="c1"># Fixed axis</span>
    <span class="k">if</span> <span class="n">at</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">at</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="n">fix_name</span> <span class="ow">in</span> <span class="n">at</span><span class="p">:</span>
        <span class="n">fix_idx</span> <span class="o">=</span> <span class="n">nearest_index</span><span class="p">(</span><span class="n">fix_index</span><span class="p">,</span> <span class="n">at</span><span class="p">[</span><span class="n">fix_name</span><span class="p">])</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">fix_index</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">fix_idx</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Axis &#39;</span><span class="si">{</span><span class="n">fix_name</span><span class="si">}</span><span class="s2">&#39; has length </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">fix_index</span><span class="p">)</span><span class="si">}</span><span class="s2"> &gt; 1. &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;Specify its value in &#39;at&#39;.&quot;</span>
        <span class="p">)</span>

    <span class="c1"># Apply stride</span>
    <span class="n">ax1_indices</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ax1_index</span><span class="p">))[::</span><span class="n">stride</span><span class="p">]</span>
    <span class="n">ax2_indices</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ax2_index</span><span class="p">))[::</span><span class="n">stride</span><span class="p">]</span>
    <span class="n">n1</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ax1_indices</span><span class="p">)</span>
    <span class="n">n2</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ax2_indices</span><span class="p">)</span>

    <span class="c1"># Compute coherence for each point</span>
    <span class="c1"># First compute for one point to get frequency axis</span>
    <span class="n">test_slices</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),</span> <span class="n">ax1_indices</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ax2_indices</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">fix_idx</span><span class="p">]</span>
    <span class="n">test_slices</span> <span class="o">=</span> <span class="n">_build_extraction_slices</span><span class="p">(</span>
        <span class="n">ax1_int</span><span class="p">,</span> <span class="n">ax2_int</span><span class="p">,</span> <span class="n">fix_int</span><span class="p">,</span> <span class="n">ax1_indices</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ax2_indices</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">fix_idx</span>
    <span class="p">)</span>
    <span class="n">test_data</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">test_slices</span><span class="p">)]</span>
    <span class="n">freqs</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">coherence</span><span class="p">(</span>
        <span class="n">ref_data</span><span class="p">,</span> <span class="n">test_data</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="n">fs</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span>
        <span class="n">nperseg</span><span class="o">=</span><span class="n">nperseg</span><span class="p">,</span> <span class="n">noverlap</span><span class="o">=</span><span class="n">noverlap</span>
    <span class="p">)</span>

    <span class="n">n_freq</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">freqs</span><span class="p">)</span>
    <span class="n">coh_3d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_freq</span><span class="p">,</span> <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">i1</span><span class="p">,</span> <span class="n">idx1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ax1_indices</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i2</span><span class="p">,</span> <span class="n">idx2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ax2_indices</span><span class="p">):</span>
            <span class="n">slices</span> <span class="o">=</span> <span class="n">_build_extraction_slices</span><span class="p">(</span>
                <span class="n">ax1_int</span><span class="p">,</span> <span class="n">ax2_int</span><span class="p">,</span> <span class="n">fix_int</span><span class="p">,</span> <span class="n">idx1</span><span class="p">,</span> <span class="n">idx2</span><span class="p">,</span> <span class="n">fix_idx</span>
            <span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slices</span><span class="p">)]</span>

            <span class="n">_</span><span class="p">,</span> <span class="n">cxy</span> <span class="o">=</span> <span class="n">coherence</span><span class="p">(</span>
                <span class="n">ref_data</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="n">fs</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span>
                <span class="n">nperseg</span><span class="o">=</span><span class="n">nperseg</span><span class="p">,</span> <span class="n">noverlap</span><span class="o">=</span><span class="n">noverlap</span>
            <span class="p">)</span>
            <span class="n">coh_3d</span><span class="p">[:,</span> <span class="n">i1</span><span class="p">,</span> <span class="n">i2</span><span class="p">]</span> <span class="o">=</span> <span class="n">cxy</span>

    <span class="n">freq_unit</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">dt_unit</span>
    <span class="n">freq_axis</span> <span class="o">=</span> <span class="n">freqs</span> <span class="o">*</span> <span class="n">freq_unit</span>

    <span class="c1"># Band averaging if specified</span>
    <span class="k">if</span> <span class="n">band</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">fmin</span><span class="p">,</span> <span class="n">fmax</span> <span class="o">=</span> <span class="n">band</span>
        <span class="n">fmin_val</span> <span class="o">=</span> <span class="n">fmin</span><span class="o">.</span><span class="n">to_value</span><span class="p">(</span><span class="n">freq_unit</span><span class="p">)</span>
        <span class="n">fmax_val</span> <span class="o">=</span> <span class="n">fmax</span><span class="o">.</span><span class="n">to_value</span><span class="p">(</span><span class="n">freq_unit</span><span class="p">)</span>

        <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">freqs</span> <span class="o">&gt;=</span> <span class="n">fmin_val</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">freqs</span> <span class="o">&lt;=</span> <span class="n">fmax_val</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">mask</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;No frequencies in band [</span><span class="si">{</span><span class="n">fmin</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">fmax</span><span class="si">}</span><span class="s2">]. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Available range: [</span><span class="si">{</span><span class="n">freqs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">freqs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">] </span><span class="si">{</span><span class="n">freq_unit</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="n">coh_band</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">coh_3d</span><span class="p">[</span><span class="n">mask</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Build 4D output</span>
        <span class="n">shape_4d</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">shape_4d</span><span class="p">[</span><span class="n">ax1_int</span><span class="p">]</span> <span class="o">=</span> <span class="n">n1</span>
        <span class="n">shape_4d</span><span class="p">[</span><span class="n">ax2_int</span><span class="p">]</span> <span class="o">=</span> <span class="n">n2</span>
        <span class="n">coh_4d</span> <span class="o">=</span> <span class="n">coh_band</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape_4d</span><span class="p">)</span>

        <span class="n">ax1_val</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">ax1_index</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">,</span> <span class="n">ax1_index</span><span class="p">)</span>
        <span class="n">ax1_unit</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">ax1_index</span><span class="p">,</span> <span class="s2">&quot;unit&quot;</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">dimensionless_unscaled</span><span class="p">)</span>
        <span class="n">ax2_val</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">ax2_index</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">,</span> <span class="n">ax2_index</span><span class="p">)</span>
        <span class="n">ax2_unit</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">ax2_index</span><span class="p">,</span> <span class="s2">&quot;unit&quot;</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">dimensionless_unscaled</span><span class="p">)</span>

        <span class="n">ax1_out</span> <span class="o">=</span> <span class="n">ax1_val</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">ax1_indices</span><span class="p">)]</span> <span class="o">*</span> <span class="n">ax1_unit</span>
        <span class="n">ax2_out</span> <span class="o">=</span> <span class="n">ax2_val</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">ax2_indices</span><span class="p">)]</span> <span class="o">*</span> <span class="n">ax2_unit</span>

        <span class="n">axes_out</span> <span class="o">=</span> <span class="p">{</span>
            <span class="mi">1</span><span class="p">:</span> <span class="n">field</span><span class="o">.</span><span class="n">_axis1_index</span><span class="p">[:</span><span class="mi">1</span><span class="p">],</span>
            <span class="mi">2</span><span class="p">:</span> <span class="n">field</span><span class="o">.</span><span class="n">_axis2_index</span><span class="p">[:</span><span class="mi">1</span><span class="p">],</span>
            <span class="mi">3</span><span class="p">:</span> <span class="n">field</span><span class="o">.</span><span class="n">_axis3_index</span><span class="p">[:</span><span class="mi">1</span><span class="p">],</span>
        <span class="p">}</span>
        <span class="n">axes_out</span><span class="p">[</span><span class="n">ax1_int</span><span class="p">]</span> <span class="o">=</span> <span class="n">ax1_out</span>
        <span class="n">axes_out</span><span class="p">[</span><span class="n">ax2_int</span><span class="p">]</span> <span class="o">=</span> <span class="n">ax2_out</span>
        <span class="n">axes_out</span><span class="p">[</span><span class="n">fix_int</span><span class="p">]</span> <span class="o">=</span> <span class="n">fix_index</span><span class="p">[</span><span class="n">fix_idx</span> <span class="p">:</span> <span class="n">fix_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

        <span class="kn">from</span><span class="w"> </span><span class="nn">gwexpy.fields</span><span class="w"> </span><span class="kn">import</span> <span class="n">ScalarField</span>

        <span class="k">return</span> <span class="n">ScalarField</span><span class="p">(</span>
            <span class="n">coh_4d</span><span class="p">,</span>
            <span class="n">unit</span><span class="o">=</span><span class="n">u</span><span class="o">.</span><span class="n">dimensionless_unscaled</span><span class="p">,</span>
            <span class="n">axis0</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">])</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">s</span><span class="p">,</span>
            <span class="n">axis1</span><span class="o">=</span><span class="n">axes_out</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">axis2</span><span class="o">=</span><span class="n">axes_out</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
            <span class="n">axis3</span><span class="o">=</span><span class="n">axes_out</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
            <span class="n">axis_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;t&quot;</span><span class="p">,</span> <span class="n">field</span><span class="o">.</span><span class="n">_axis1_name</span><span class="p">,</span> <span class="n">field</span><span class="o">.</span><span class="n">_axis2_name</span><span class="p">,</span> <span class="n">field</span><span class="o">.</span><span class="n">_axis3_name</span><span class="p">],</span>
            <span class="n">axis0_domain</span><span class="o">=</span><span class="s2">&quot;time&quot;</span><span class="p">,</span>
            <span class="n">space_domain</span><span class="o">=</span><span class="n">field</span><span class="o">.</span><span class="n">_space_domains</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Return with frequency axis</span>
        <span class="n">shape_4d</span> <span class="o">=</span> <span class="p">[</span><span class="n">n_freq</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">shape_4d</span><span class="p">[</span><span class="n">ax1_int</span><span class="p">]</span> <span class="o">=</span> <span class="n">n1</span>
        <span class="n">shape_4d</span><span class="p">[</span><span class="n">ax2_int</span><span class="p">]</span> <span class="o">=</span> <span class="n">n2</span>
        <span class="n">coh_4d</span> <span class="o">=</span> <span class="n">coh_3d</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape_4d</span><span class="p">)</span>

        <span class="n">ax1_val</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">ax1_index</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">,</span> <span class="n">ax1_index</span><span class="p">)</span>
        <span class="n">ax1_unit</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">ax1_index</span><span class="p">,</span> <span class="s2">&quot;unit&quot;</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">dimensionless_unscaled</span><span class="p">)</span>
        <span class="n">ax2_val</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">ax2_index</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">,</span> <span class="n">ax2_index</span><span class="p">)</span>
        <span class="n">ax2_unit</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">ax2_index</span><span class="p">,</span> <span class="s2">&quot;unit&quot;</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">dimensionless_unscaled</span><span class="p">)</span>

        <span class="n">ax1_out</span> <span class="o">=</span> <span class="n">ax1_val</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">ax1_indices</span><span class="p">)]</span> <span class="o">*</span> <span class="n">ax1_unit</span>
        <span class="n">ax2_out</span> <span class="o">=</span> <span class="n">ax2_val</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">ax2_indices</span><span class="p">)]</span> <span class="o">*</span> <span class="n">ax2_unit</span>

        <span class="n">axes_out</span> <span class="o">=</span> <span class="p">{</span>
            <span class="mi">1</span><span class="p">:</span> <span class="n">field</span><span class="o">.</span><span class="n">_axis1_index</span><span class="p">[:</span><span class="mi">1</span><span class="p">],</span>
            <span class="mi">2</span><span class="p">:</span> <span class="n">field</span><span class="o">.</span><span class="n">_axis2_index</span><span class="p">[:</span><span class="mi">1</span><span class="p">],</span>
            <span class="mi">3</span><span class="p">:</span> <span class="n">field</span><span class="o">.</span><span class="n">_axis3_index</span><span class="p">[:</span><span class="mi">1</span><span class="p">],</span>
        <span class="p">}</span>
        <span class="n">axes_out</span><span class="p">[</span><span class="n">ax1_int</span><span class="p">]</span> <span class="o">=</span> <span class="n">ax1_out</span>
        <span class="n">axes_out</span><span class="p">[</span><span class="n">ax2_int</span><span class="p">]</span> <span class="o">=</span> <span class="n">ax2_out</span>
        <span class="n">axes_out</span><span class="p">[</span><span class="n">fix_int</span><span class="p">]</span> <span class="o">=</span> <span class="n">fix_index</span><span class="p">[</span><span class="n">fix_idx</span> <span class="p">:</span> <span class="n">fix_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

        <span class="kn">from</span><span class="w"> </span><span class="nn">gwexpy.fields</span><span class="w"> </span><span class="kn">import</span> <span class="n">ScalarField</span>

        <span class="k">return</span> <span class="n">ScalarField</span><span class="p">(</span>
            <span class="n">coh_4d</span><span class="p">,</span>
            <span class="n">unit</span><span class="o">=</span><span class="n">u</span><span class="o">.</span><span class="n">dimensionless_unscaled</span><span class="p">,</span>
            <span class="n">axis0</span><span class="o">=</span><span class="n">freq_axis</span><span class="p">,</span>
            <span class="n">axis1</span><span class="o">=</span><span class="n">axes_out</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">axis2</span><span class="o">=</span><span class="n">axes_out</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
            <span class="n">axis3</span><span class="o">=</span><span class="n">axes_out</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
            <span class="n">axis_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;f&quot;</span><span class="p">,</span> <span class="n">field</span><span class="o">.</span><span class="n">_axis1_name</span><span class="p">,</span> <span class="n">field</span><span class="o">.</span><span class="n">_axis2_name</span><span class="p">,</span> <span class="n">field</span><span class="o">.</span><span class="n">_axis3_name</span><span class="p">],</span>
            <span class="n">axis0_domain</span><span class="o">=</span><span class="s2">&quot;frequency&quot;</span><span class="p">,</span>
            <span class="n">space_domain</span><span class="o">=</span><span class="n">field</span><span class="o">.</span><span class="n">_space_domains</span><span class="p">,</span>
        <span class="p">)</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">_build_extraction_slices</span><span class="p">(</span>
    <span class="n">ax1_int</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">ax2_int</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">fix_int</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">idx1</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">idx2</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">fix_idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Build slice tuple for extracting 1D time series from specific spatial indices.&quot;&quot;&quot;</span>
    <span class="n">slices</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">slices</span><span class="p">[</span><span class="n">ax1_int</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx1</span>
    <span class="n">slices</span><span class="p">[</span><span class="n">ax2_int</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx2</span>
    <span class="n">slices</span><span class="p">[</span><span class="n">fix_int</span><span class="p">]</span> <span class="o">=</span> <span class="n">fix_idx</span>
    <span class="k">return</span> <span class="n">slices</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2026, gwexpy contributors.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>